From 09bc2cc394f5fe1264b49879e0231e19cdac236a Mon Sep 17 00:00:00 2001
From: Riccardo Ferrazzo <f.riccardo87@gmail.com>
Date: Sat, 1 Jan 2022 15:36:22 +0000
Subject: [PATCH] unipi: add spi driver

---
 drivers/Kconfig                |    2 +
 drivers/Makefile               |    1 +
 drivers/unipi/Kconfig          |    7 +
 drivers/unipi/Makefile         |    2 +
 drivers/unipi/unipi_common.h   |  220 +++
 drivers/unipi/unipi_gpio.c     |  230 +++
 drivers/unipi/unipi_gpio.h     |   47 +
 drivers/unipi/unipi_iio.c      |  544 ++++++++
 drivers/unipi/unipi_iio.h      |  135 ++
 drivers/unipi/unipi_misc.c     |   88 ++
 drivers/unipi/unipi_misc.h     |   46 +
 drivers/unipi/unipi_platform.c | 2404 ++++++++++++++++++++++++++++++++
 drivers/unipi/unipi_platform.h |  394 ++++++
 drivers/unipi/unipi_spi.c      | 1639 ++++++++++++++++++++++
 drivers/unipi/unipi_spi.h      |  222 +++
 drivers/unipi/unipi_sysfs.c    | 1367 ++++++++++++++++++
 drivers/unipi/unipi_sysfs.h    |   41 +
 drivers/unipi/unipi_tty.c      | 1117 +++++++++++++++
 drivers/unipi/unipi_tty.h      |   23 +
 drivers/unipi/unipi_uart.c     |  792 +++++++++++
 drivers/unipi/unipi_uart.h     |   53 +
 21 files changed, 9374 insertions(+)
 create mode 100644 drivers/unipi/Kconfig
 create mode 100644 drivers/unipi/Makefile
 create mode 100644 drivers/unipi/unipi_common.h
 create mode 100644 drivers/unipi/unipi_gpio.c
 create mode 100644 drivers/unipi/unipi_gpio.h
 create mode 100644 drivers/unipi/unipi_iio.c
 create mode 100644 drivers/unipi/unipi_iio.h
 create mode 100644 drivers/unipi/unipi_misc.c
 create mode 100644 drivers/unipi/unipi_misc.h
 create mode 100644 drivers/unipi/unipi_platform.c
 create mode 100644 drivers/unipi/unipi_platform.h
 create mode 100644 drivers/unipi/unipi_spi.c
 create mode 100644 drivers/unipi/unipi_spi.h
 create mode 100644 drivers/unipi/unipi_sysfs.c
 create mode 100644 drivers/unipi/unipi_sysfs.h
 create mode 100644 drivers/unipi/unipi_tty.c
 create mode 100644 drivers/unipi/unipi_tty.h
 create mode 100644 drivers/unipi/unipi_uart.c
 create mode 100644 drivers/unipi/unipi_uart.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 8befa53f43be..4a84dad6a910 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -228,4 +228,6 @@ source "drivers/interconnect/Kconfig"
 
 source "drivers/counter/Kconfig"
 
+source "drivers/unipi/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index aaef17cc6512..f57fe77fe901 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -186,3 +186,4 @@ obj-$(CONFIG_SIOX)		+= siox/
 obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
+obj-$(CONFIG_UNIPI)		+= unipi/
diff --git a/drivers/unipi/Kconfig b/drivers/unipi/Kconfig
new file mode 100644
index 000000000000..eb64fe2929ff
--- /dev/null
+++ b/drivers/unipi/Kconfig
@@ -0,0 +1,7 @@
+config UNIPI
+    tristate "Enable Unipi Neuron board extensions"
+    select SPI
+    select IIO
+    select GPIOLIB
+    ---help---
+        Enables the support for unipi IO extension modules
\ No newline at end of file
diff --git a/drivers/unipi/Makefile b/drivers/unipi/Makefile
new file mode 100644
index 000000000000..d08b71e69681
--- /dev/null
+++ b/drivers/unipi/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_UNIPI) += unipi.o
+unipi-y += unipi_tty.o unipi_gpio.o unipi_iio.o unipi_misc.o unipi_platform.o unipi_spi.o unipi_sysfs.o unipi_uart.o
\ No newline at end of file
diff --git a/drivers/unipi/unipi_common.h b/drivers/unipi/unipi_common.h
new file mode 100644
index 000000000000..857eefb89ad3
--- /dev/null
+++ b/drivers/unipi/unipi_common.h
@@ -0,0 +1,220 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_COMMON_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_COMMON_H_
+
+/************
+ * Includes *
+ ************/
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
+#include <linux/i2c.h>
+#include <linux/iio/iio.h>
+#include <uapi/linux/iio/types.h>
+#include <linux/iio/sysfs.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/spi/spi.h>
+#include <linux/leds.h>
+#include <linux/uaccess.h>
+#include <asm/termbits.h>
+//#include <asm/gpio.h>
+
+/***************
+ * Definitions *
+ ***************/
+//#define UNIPISPI_USE_RX_THREAD
+
+#define NEURONSPI_SCHED_REQUIRED 1 // Older kernels do not require sched/types to be specifically imported
+#if NEURONSPI_SCHED_REQUIRED > 0
+	#include <uapi/linux/sched/types.h>
+#endif
+#define NEURONSPI_MAJOR_VERSIONSTRING "Version 1.80:2021:11:24"
+
+#define NEURONSPI_MAX_DEVS				7	//Maximal SPI card count
+#define NEURONSPI_MAX_UART				16
+#define NEURONSPI_BUFFER_MAX			1152
+#define NEURONSPI_HEADER_LENGTH 		10
+#define NEURONSPI_FIRST_MESSAGE_LENGTH	6
+#define NEURONSPI_FIRST_MESSAGE_ALLOC	8
+#define NEURONSPI_EDGE_DELAY			10
+#define NEURONSPI_B_PER_WORD 			8
+#define NEURONSPI_DEFAULT_FREQ			600000
+#define NEURONSPI_COMMON_FREQ			12000000
+
+#define NEURONSPI_SYSLED_REGISTER 	509
+
+#if defined(CONFIG_ARM64)
+/* on NanoPi there are only 12MHz and 6MHz available, not in between */
+   #define NEURONSPI_SLOWER_FREQ			6000000
+#else
+   #define NEURONSPI_SLOWER_FREQ			7500000
+#endif
+
+#if defined(CONFIG_ARM64)
+#define NEURONSPI_MAX_TX				2048
+#else
+#define NEURONSPI_MAX_TX				60
+#endif
+
+//#define NEURONSPI_MAX_TX				256
+#define NEURONSPI_MAX_BAUD				115200
+#define NEURONSPI_FIFO_SIZE				256
+#define NEURONSPI_FIFO_MIN_CONTINUOUS	50
+#define NEURONSPI_DETAILED_DEBUG		0
+#define NEURONSPI_LAST_TRANSFER_DELAY	40
+#define MAX_RX_QUEUE_LEN                16
+
+#define NEURON_DEVICE_NAME 				"unipispi"
+#define NEURON_DEVICE_CLASS 			"modbus_spi"
+#define NEURON_DRIVER_NAME				"UNIPISPI"
+#define PORT_NEURONSPI					184
+
+#define STRICT_RESERVING
+#define NEURONSPI_ALWAYS_EXPORT
+
+#define NEURONSPI_GET_COIL_READ_PHASE2_BYTE_LENGTH(X)	((((X) + 15) >> 4) << 1)
+
+/********************
+ * Module Constants *
+ ********************/
+
+#define NEURONSPI_NO_INTERRUPT_MODELS_LEN 				4
+static const u16 NEURONSPI_NO_INTERRUPT_MODELS[NEURONSPI_NO_INTERRUPT_MODELS_LEN] = {
+		0xb10, 0xc10, 0xf10, 0xb20
+};
+
+/*******************
+ * Data Structures *
+ *******************/
+
+struct neuronspi_op_buffer
+{
+    u8  first_message[8];
+    u8  *second_message;
+};
+
+
+#define CB_WRITESTRING 1
+#define CB_GETTXFIFO  2
+#define START_TX       3
+
+struct neuronspi_port
+{
+	struct uart_port			port;
+	u8							dev_index;  // index into global array neuronspi_s_dev 
+	u8							dev_port;   // index of port on neuronspi device
+    struct neuronspi_driver_data  *n_spi;     // shorthand to n_spi 
+    
+    u8                          rx_remain;
+    int                         accept_rx;
+	struct kthread_work			flush_work;
+    
+	struct kthread_work			tx_work;
+    u16                         tx_fifo_reg;  // register in neuronspi device modbus map to read internal tx fifo length
+                                              // 0 if undefined
+    u16                         tx_fifo_len;  // estimates char count in neuron internal tx fifo
+	struct hrtimer				tx_timer;
+
+	s32							baud;
+    s64                         one_char_nsec;
+
+    spinlock_t                  rx_in_progress_lock;
+    int                         rx_in_progress;
+    struct neuronspi_op_buffer  rx_send_buf;
+    struct neuronspi_op_buffer  rx_recv_buf;
+    u8                          rx_send_msg[NEURONSPI_FIFO_SIZE+4];
+    u8                          rx_recv_msg[NEURONSPI_FIFO_SIZE+4];
+
+    spinlock_t                  txop_lock;
+    int                         pending_txop;
+    struct neuronspi_op_buffer  tx_send_buf;
+    struct neuronspi_op_buffer  tx_recv_buf;
+    u8                          tx_send_msg[NEURONSPI_FIFO_SIZE+4];
+    u8                          tx_recv_msg[NEURONSPI_FIFO_SIZE+4];
+};
+
+struct neuronspi_uart_data
+{
+	struct neuronspi_port			*p;             // array p[p_count]
+	u8								p_count;
+};
+
+// Instantiated once per SPI device
+struct neuronspi_driver_data
+{
+	s32 neuron_index;
+	u8 reserved_device;
+
+	struct kthread_worker   *primary_worker;
+	struct kthread_work		irq_work;
+    struct hrtimer			poll_timer;
+    int                     poll_enabled;
+
+	struct platform_device *board_device;
+
+	struct regmap *reg_map;
+	struct mutex device_lock;
+	struct neuronspi_board_features *features;
+	struct neuronspi_board_regstart_table *regstart_table;
+	struct spinlock sysfs_regmap_lock;
+
+	u8  combination_id;
+	u16 firmware_version;
+	u8  no_irq;
+	u32 ideal_frequency;
+	u8 uart_count_to_probe;
+	int uart_count;
+	int uart_pindex;
+
+	u16 sysfs_regmap_target;
+	u16 sysfs_register_target;
+	u16 sysfs_counter_target;
+    
+    //struct neuronspi_op_buffer  idle_recv_buf;
+    cycles_t last_cs_cycles;
+};
+
+
+/*
+struct neuronspi_direct_acc
+{
+	void __iomem		*vaddr;
+	u32					size;
+};
+*/
+
+/*********************
+ * Data Declarations *
+ *********************/
+
+extern struct spi_device    *neuronspi_s_dev[NEURONSPI_MAX_DEVS];
+extern struct task_struct   *neuronspi_invalidate_thread;
+
+extern int                  neuronspi_model_id;
+
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_COMMON_H_ */
diff --git a/drivers/unipi/unipi_gpio.c b/drivers/unipi/unipi_gpio.c
new file mode 100644
index 000000000000..3ab41cf16ccc
--- /dev/null
+++ b/drivers/unipi/unipi_gpio.c
@@ -0,0 +1,230 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_gpio.h"
+#include "unipi_spi.h"
+
+/************************
+ * Non-static Functions *
+ ************************/
+
+int neuronspi_spi_gpio_di_get(struct spi_device* spi_dev, u32 id)
+{
+	unsigned int recv_buf;
+	bool ret = 0;
+	u32 offset = id / 16;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	regmap_read(d_data->reg_map, d_data->regstart_table->di_val_reg + offset, &recv_buf);
+	if (recv_buf & (0x1 << (id % 16))) {
+		ret = 1;
+	}
+	return ret;
+}
+
+int neuronspi_spi_gpio_do_set(struct spi_device* spi_dev, u32 id, int value)
+{
+	u32 current_value = 0;
+	bool ret = 0;
+	u32 offset = id / 16;
+	u16 off_val = value << (id % 16);
+	u16 mask = ~(1 << (id % 16));
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	regmap_read(d_data->reg_map, d_data->regstart_table->do_val_reg + offset, &current_value);
+	current_value&= mask;
+	current_value|= off_val;
+	regmap_write(d_data->reg_map, d_data->regstart_table->do_val_reg + offset, current_value);
+	return ret;
+}
+
+int neuronspi_spi_gpio_ro_set(struct spi_device* spi_dev, u32 id, int value)
+{
+	u32 current_value = 0;
+	bool ret = 0;
+	u32 offset = id / 16;
+	u16 off_val = value << (id % 16);
+	u16 mask = ~(1 << (id % 16));
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	regmap_read(d_data->reg_map, d_data->regstart_table->ro_val_reg + offset, &current_value);
+	current_value&= mask;
+	current_value|= off_val;
+	regmap_write(d_data->reg_map, d_data->regstart_table->ro_val_reg + offset, current_value);
+	return ret;
+}
+
+
+int neuronspi_gpio_di_direction_input(struct gpio_chip *chip, unsigned offset) {
+	return 0;
+}
+
+int neuronspi_gpio_di_direction_output(struct gpio_chip *chip, unsigned offset, int value) {
+	return -EINVAL;
+}
+
+int neuronspi_gpio_di_get(struct gpio_chip *chip, unsigned offset) {
+	struct neuronspi_gpio_port *n_di = gpiochip_get_data(chip);
+	struct spi_device *spi = n_di->spi;
+	return neuronspi_spi_gpio_di_get(spi, n_di->io_index);
+}
+
+int neuronspi_gpio_do_direction_output(struct gpio_chip *chip, unsigned offset, int value) {
+	return 0;
+}
+
+void neuronspi_gpio_do_set(struct gpio_chip *chip, unsigned offset, int value) {
+	struct neuronspi_gpio_port *n_do = gpiochip_get_data(chip);
+	struct spi_device *spi = n_do->spi;
+	neuronspi_spi_gpio_do_set(spi, n_do->io_index, value);
+}
+
+int neuronspi_gpio_ro_direction_output(struct gpio_chip *chip, unsigned offset, int value) {
+	return 0;
+}
+
+void neuronspi_gpio_ro_set(struct gpio_chip *chip, unsigned offset, int value) {
+	struct neuronspi_gpio_port *n_ro = gpiochip_get_data(chip);
+	struct spi_device *spi = n_ro->spi;
+	neuronspi_spi_gpio_ro_set(spi, n_ro->io_index, value);
+}
+
+
+struct neuronspi_gpio_driver * neuronspi_di_probe(int io_count, int neuron_index, struct platform_device *board_device)
+{
+	struct neuronspi_gpio_driver* di_driver;
+	struct neuronspi_gpio_port* pdi_driver;
+	int i;
+    char buf[20];
+
+	if (io_count <= 0) return NULL;
+
+	di_driver = kzalloc(sizeof(struct neuronspi_gpio_driver) + (sizeof(struct neuronspi_gpio_port)) * (io_count-1), GFP_ATOMIC);
+	for (i = 0; i < io_count; i++) {
+		pdi_driver = di_driver->ports + i;
+        scnprintf(buf, 20, "di_%d_%02d", neuron_index+1, i+1);
+		pdi_driver->io_index = i;
+		pdi_driver->spi = neuronspi_s_dev[neuron_index];
+				
+		pdi_driver->plat_dev = platform_device_alloc(buf, -1);
+		pdi_driver->plat_dev->dev.parent = &(board_device->dev);
+		pdi_driver->plat_dev->dev.groups = neuron_gpio_di_attr_groups;
+		pdi_driver->plat_dev->dev.driver = &neuronspi_spi_driver.driver;
+		platform_device_add(pdi_driver->plat_dev);
+
+		platform_set_drvdata(pdi_driver->plat_dev, pdi_driver);
+		pdi_driver->gpio_c.owner = THIS_MODULE;
+		pdi_driver->gpio_c.parent = &(pdi_driver->plat_dev->dev);
+		pdi_driver->gpio_c.label = "neuron_di";
+		pdi_driver->gpio_c.can_sleep = 1;
+		pdi_driver->gpio_c.ngpio = 1;
+		pdi_driver->gpio_c.base = -1;
+		pdi_driver->gpio_c.direction_input = neuronspi_gpio_di_direction_input;
+		pdi_driver->gpio_c.get = neuronspi_gpio_di_get;
+		gpiochip_add_data(&pdi_driver->gpio_c, pdi_driver);
+	}  
+    di_driver->count = io_count;
+	return di_driver;
+}
+
+struct neuronspi_gpio_driver * neuronspi_ro_probe(int io_count, int neuron_index, struct platform_device *board_device)
+{
+	struct neuronspi_gpio_driver* ro_driver;
+	struct neuronspi_gpio_port* gpio_port;
+	int i;
+    char buf[20];
+
+	if (io_count <= 0) return NULL;
+
+	ro_driver = kzalloc(sizeof(struct neuronspi_gpio_driver) + (sizeof(struct neuronspi_gpio_port)) * (io_count-1), GFP_ATOMIC);
+	for (i = 0; i < io_count; i++) {
+		gpio_port = ro_driver->ports + i;
+
+        scnprintf(buf, 20, "ro_%d_%02d", neuron_index+1, i+1);
+		gpio_port->io_index = i;
+		gpio_port->spi = neuronspi_s_dev[neuron_index];
+				
+		gpio_port->plat_dev = platform_device_alloc(buf, -1);
+		gpio_port->plat_dev->dev.parent = &(board_device->dev);
+		gpio_port->plat_dev->dev.groups = neuron_gpio_ro_attr_groups;
+		gpio_port->plat_dev->dev.driver = &neuronspi_spi_driver.driver;
+		platform_device_add(gpio_port->plat_dev);
+
+		platform_set_drvdata(gpio_port->plat_dev, gpio_port);
+		gpio_port->gpio_c.owner = THIS_MODULE;
+		gpio_port->gpio_c.parent = &(gpio_port->plat_dev->dev);
+		gpio_port->gpio_c.label = "neuron_ro";
+		gpio_port->gpio_c.can_sleep = 1;
+		gpio_port->gpio_c.ngpio = 1;
+		gpio_port->gpio_c.base = -1;
+		gpio_port->gpio_c.direction_output = neuronspi_gpio_ro_direction_output;
+		gpio_port->gpio_c.set = neuronspi_gpio_ro_set;
+		gpiochip_add_data(&gpio_port->gpio_c, gpio_port);
+
+	}
+    ro_driver->count = io_count;
+	return ro_driver;
+}
+
+struct neuronspi_gpio_driver * neuronspi_do_probe(int io_count, int neuron_index, struct platform_device *board_device)
+{
+	struct neuronspi_gpio_driver* do_driver;
+	struct neuronspi_gpio_port* gpio_port;
+	int i;
+    char buf[20];
+
+	if (io_count <= 0) return NULL;
+
+	do_driver = kzalloc(sizeof(struct neuronspi_gpio_driver) + (sizeof(struct neuronspi_gpio_port)) * (io_count-1), GFP_ATOMIC);
+	for (i = 0; i < io_count; i++) {
+		gpio_port = do_driver->ports + i;
+
+        scnprintf(buf, 20, "do_%d_%02d", neuron_index+1, i+1);
+		gpio_port->io_index = i;
+		gpio_port->spi = neuronspi_s_dev[neuron_index];
+				
+		gpio_port->plat_dev = platform_device_alloc(buf, -1);
+		gpio_port->plat_dev->dev.parent = &(board_device->dev);
+		gpio_port->plat_dev->dev.groups = neuron_gpio_do_attr_groups;
+		gpio_port->plat_dev->dev.driver = &neuronspi_spi_driver.driver;
+		platform_device_add(gpio_port->plat_dev);
+
+		platform_set_drvdata(gpio_port->plat_dev, gpio_port);
+		gpio_port->gpio_c.owner = THIS_MODULE;
+		gpio_port->gpio_c.parent = &(gpio_port->plat_dev->dev);
+		gpio_port->gpio_c.label = "neuron_do";
+		gpio_port->gpio_c.can_sleep = 1;
+		gpio_port->gpio_c.ngpio = 1;
+		gpio_port->gpio_c.base = -1;
+		gpio_port->gpio_c.direction_output = neuronspi_gpio_do_direction_output;
+		gpio_port->gpio_c.set = neuronspi_gpio_do_set;
+		gpiochip_add_data(&gpio_port->gpio_c, gpio_port);
+
+	}
+    do_driver->count = io_count;
+	return do_driver;
+}
+
+void neuronspi_gpio_remove(struct neuronspi_gpio_driver * gpio_driver)
+{
+    int i;
+	for (i = 0; i < gpio_driver->count; i++) {
+        gpiochip_remove(&gpio_driver->ports[i].gpio_c);
+		platform_set_drvdata(gpio_driver->ports[i].plat_dev, 0);
+		platform_device_unregister(gpio_driver->ports[i].plat_dev);
+    }
+	kfree(gpio_driver);
+    
+}
diff --git a/drivers/unipi/unipi_gpio.h b/drivers/unipi/unipi_gpio.h
new file mode 100644
index 000000000000..f379046cdd12
--- /dev/null
+++ b/drivers/unipi/unipi_gpio.h
@@ -0,0 +1,47 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_GPIO_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_GPIO_H_
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_common.h"
+
+
+struct neuronspi_gpio_port {
+	struct spi_device* spi;
+	struct gpio_chip gpio_c;
+	struct platform_device *plat_dev;
+	u8 io_index;
+};
+
+struct neuronspi_gpio_driver {
+    int count;
+    struct neuronspi_gpio_port ports[1];
+};
+
+
+/*************************
+ * Function Declarations *
+ *************************/
+
+struct neuronspi_gpio_driver * neuronspi_di_probe(int di_count, int neuron_index, struct platform_device *board_device);
+struct neuronspi_gpio_driver * neuronspi_ro_probe(int ro_count, int neuron_index, struct platform_device *board_device);
+struct neuronspi_gpio_driver * neuronspi_do_probe(int do_count, int neuron_index, struct platform_device *board_device);
+void neuronspi_gpio_remove(struct neuronspi_gpio_driver * gpio_driver);
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_GPIO_H_ */
diff --git a/drivers/unipi/unipi_iio.c b/drivers/unipi/unipi_iio.c
new file mode 100644
index 000000000000..1eb28207f351
--- /dev/null
+++ b/drivers/unipi/unipi_iio.c
@@ -0,0 +1,544 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_iio.h"
+#include "unipi_spi.h"
+
+/************************
+ * Non-static Functions *
+ ************************/
+/*
+ * NOTE: This function uses 64-bit fixed-point arithmetic,
+ * which necessitates using the do_div macro to avoid unnecessary long/long division.
+ */
+ 
+/*
+ * Convert float32 (low_val:hight_val) to integer value / divider. 
+ *   optionaly multiply value by factor
+*/
+void float2int_with_divider(u16 low_val, u16 high_val, int factor, int* value, int* divider)
+{
+        int exponent;
+        //int i, mask;
+        int preshift = 0;
+        s64 tmp;
+        // exponent can be [-127 .. 128], exp=0 means value in (1 .. 1.999999)
+        // mantisa has 24 bit
+        
+        // calc log2(factor)
+        if (factor > 1) {
+            for (preshift = 30; preshift > 0; preshift--) {
+                if (factor & (1 << preshift)) {
+                    if (factor != (1 << preshift)) preshift++;
+                    break;
+                }
+            }
+        }
+        exponent = (int)((high_val >> 7) & 0xff) - 127 + preshift;
+        if (exponent > 23) { 
+            // value > 16M
+            *value = 1 << 24;
+            *divider = 1;
+        } else if (exponent < -23) {
+            // value is almost zero, set value to 0
+            *value = 0;
+            *divider = 1;
+        } else {
+            *value = (1 << 23) | ((high_val & 0x7f) << 16) | low_val;
+            if ((23 - exponent) < 30) {
+                // shift divider into right position
+                *divider = 1 << (23 - exponent);
+            } else {
+                // set max divider and shift value
+                *divider = 1 << 30;
+                *value = *value >> ((23 - exponent) - 30);
+            }
+            if (preshift) {
+                tmp = *value;
+                *value = (tmp * factor) >> preshift;
+            }
+        }
+        // check and set sign of value
+        if (high_val & 0x8000) *value = -(*value);
+}
+
+void neuronspi_spi_iio_sec_ai_read_voltage(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 float_l;
+	u32 float_h;
+
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_val_reg + (2 * ai_data->index), &float_l);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_val_reg + (2 * ai_data->index) + 1, &float_h);
+        float2int_with_divider(float_l, float_h, 1000, val, val2);
+}
+
+void neuronspi_spi_iio_sec_ai_read_current(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 float_l;
+	u32 float_h;
+
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_val_reg + (2 * ai_data->index), &float_l);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_val_reg + (2 * ai_data->index) + 1, &float_h);
+        float2int_with_divider(float_l, float_h, 1, val, val2);
+}
+
+void neuronspi_spi_iio_sec_ai_read_resistance(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 float_l;
+	u32 float_h;
+
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_val_reg + (2 * ai_data->index), &float_l);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_val_reg + (2 * ai_data->index) + 1, &float_h);
+        float2int_with_divider(float_l, float_h, 1, val, val2);
+}
+
+void neuronspi_spi_iio_sec_ao_set_voltage(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 sec_true_val;
+	if (val > 10000) val = 10000;
+	sec_true_val = (val * 2) / 5;
+	regmap_write(n_spi->reg_map, n_spi->regstart_table->sec_ao_val_reg + ao_data->index, sec_true_val);
+}
+
+/*
+ * NOTE: This function uses 64-bit fixed-point arithmetic,
+ * which necessitates using the do_div macro to avoid unnecessary long/long division.
+ */
+void neuronspi_spi_iio_stm_ai_read_voltage(struct iio_dev *iio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ai_data = iio_priv(iio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 stm_ai_val = 0;
+	u32 stm_v_int_ref = 0;
+	u32 stm_v_inp_ref = 0;
+	u32 stm_v_err = 0;
+	u32 stm_v_off = 0;
+	u64 stm_true_val = 0;
+	u64 stm_true_ref = 0;
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_val_reg, &stm_ai_val);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_int, &stm_v_int_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_inp, &stm_v_inp_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_vol_err, &stm_v_err);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_vol_off, &stm_v_off);
+	stm_true_ref = ((u64)stm_v_int_ref) * 99000;
+	stm_v_inp_ref = stm_v_inp_ref * 10000;
+	stm_true_val = stm_true_ref * ((u64)(stm_ai_val * 1000));
+	do_div(stm_true_val, stm_v_inp_ref);
+	do_div(stm_true_val, 4096);
+	stm_true_val *= (10000 + stm_v_err);
+	stm_true_val += stm_v_off;
+	do_div(stm_true_val, 10000);
+	*val = stm_true_val;
+}
+
+void neuronspi_spi_iio_stm_ai_read_current(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 stm_ai_val = 0;
+	u32 stm_v_int_ref = 0;
+	u32 stm_v_inp_ref = 0;
+	u32 stm_i_err = 0;
+	u32 stm_i_off = 0;
+	u64 stm_true_val = 0;
+	u64 stm_true_ref = 0;
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_val_reg, &stm_ai_val);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_int, &stm_v_int_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_inp, &stm_v_inp_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_curr_err, &stm_i_err);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_curr_off, &stm_i_off);
+	stm_true_ref = ((u64)stm_v_int_ref) * 330000;
+	stm_v_inp_ref = stm_v_inp_ref * 10000;
+	stm_true_val = stm_true_ref * ((u64)(stm_ai_val * 1000));
+	do_div(stm_true_val, stm_v_inp_ref);
+	do_div(stm_true_val, 4096);
+	stm_true_val *= (10000 + stm_i_err);
+	stm_true_val += stm_i_off;
+	do_div(stm_true_val, 10000);
+	*val = stm_true_val;
+	*val2 = 1000;
+}
+
+void neuronspi_spi_iio_stm_ao_read_resistance(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 stm_aio_val = 0;
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_aio_val_reg, &stm_aio_val);
+	*val = stm_aio_val;
+	*val2 = 10;
+}
+
+
+void neuronspi_spi_iio_stm_ao_set_voltage(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 stm_v_int_ref = 0;
+	u32 stm_v_inp_ref = 0;
+	u32 stm_v_err = 0;
+	u32 stm_v_off = 0;
+	u64 stm_true_val = val;
+	u64 stm_true_val_fraction = val2 / 100;
+	u64 stm_true_ref = 0;
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_int, &stm_v_int_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_inp, &stm_v_inp_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ao_vol_err, &stm_v_err);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ao_vol_off, &stm_v_off);
+	stm_true_ref = ((u64)stm_v_int_ref) * (99000 + stm_v_err) * 1000;
+	stm_v_inp_ref = stm_v_inp_ref * 10000;
+	stm_true_val = ((stm_true_val * 10000) + (stm_true_val_fraction) - stm_v_off) * 4095;
+	do_div(stm_true_ref, stm_v_inp_ref);
+	stm_v_inp_ref = stm_true_ref;
+	do_div(stm_true_val, stm_v_inp_ref);
+	do_div(stm_true_val, 10000);
+	if (stm_true_val > 4095) stm_true_val = 4095;
+	regmap_write(n_spi->reg_map, n_spi->regstart_table->stm_ao_val_reg, (unsigned int) stm_true_val);
+}
+
+void neuronspi_spi_iio_stm_ao_set_current(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u32 stm_v_int_ref = 0;
+	u32 stm_v_inp_ref = 0;
+	u32 stm_i_err = 0;
+	u32 stm_i_off = 0;
+	u64 stm_true_val = val;
+	u64 stm_true_val_fraction = val2 / 100;
+	u64 stm_true_ref = 0;
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_int, &stm_v_int_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->vref_inp, &stm_v_inp_ref);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ao_curr_err, &stm_i_err);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ao_curr_off, &stm_i_off);
+	stm_true_ref = ((u64)stm_v_int_ref) * (330000 + stm_i_err) * 100;
+	stm_v_inp_ref = stm_v_inp_ref * 1000;
+	stm_true_val = (((stm_true_val * 10000) + (stm_true_val_fraction)) - stm_i_off) * 4095;
+	do_div(stm_true_ref, stm_v_inp_ref);
+	stm_v_inp_ref = stm_true_ref;
+	do_div(stm_true_val, stm_v_inp_ref);
+	do_div(stm_true_val, 10);
+	if (stm_true_val > 4095) stm_true_val = 4095;
+	regmap_write(n_spi->reg_map, n_spi->regstart_table->stm_ao_val_reg, (unsigned int)stm_true_val);
+}
+
+int neuronspi_iio_stm_ai_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask) {
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_mode_reg + ai_data->index, &ai_data->mode);
+	switch(ai_data->mode) {
+	case 0: {
+		if (ch->type == IIO_VOLTAGE) {
+			neuronspi_spi_iio_stm_ai_read_voltage(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_INT;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	case 1: {
+		if (ch->type == IIO_CURRENT) {
+			neuronspi_spi_iio_stm_ai_read_current(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_FRACTIONAL;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	default: {
+		return -EINVAL;
+		break;
+	}
+	}
+}
+
+int neuronspi_iio_stm_ao_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ao_mode_reg + ao_data->index, &ao_data->mode);
+	switch(ao_data->mode) {
+	case 3: {
+		if (ch->type == IIO_RESISTANCE) {
+			neuronspi_spi_iio_stm_ao_read_resistance(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_FRACTIONAL;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	default: {
+		return -EINVAL;
+		break;
+	}
+	}
+}
+
+int neuronspi_iio_stm_ao_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int val, int val2, long mask)
+{
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ao_mode_reg + ao_data->index, &ao_data->mode);
+	switch(ao_data->mode) {
+	case 0: {
+		if (ch->type == IIO_VOLTAGE) {
+			neuronspi_spi_iio_stm_ao_set_voltage(indio_dev, ch, val, val2, mask);
+			return 0;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	case 1: {
+		if (ch->type == IIO_CURRENT) {
+			neuronspi_spi_iio_stm_ao_set_current(indio_dev, ch, val, val2, mask);
+			return 0;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	default: {
+		return -EINVAL;
+		break;
+	}
+	}
+}
+
+int neuronspi_iio_sec_ai_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_mode_reg + ai_data->index, &ai_data->mode);
+	switch(ai_data->mode) {
+	case 0: {
+		return -EINVAL;
+		break;
+	}
+	case 1: {
+		if (ch->type == IIO_VOLTAGE) {
+			neuronspi_spi_iio_sec_ai_read_voltage(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_FRACTIONAL;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	case 2: {
+		if (ch->type == IIO_VOLTAGE) {
+			neuronspi_spi_iio_sec_ai_read_voltage(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_FRACTIONAL;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	case 3: {
+		if (ch->type == IIO_CURRENT) {
+			neuronspi_spi_iio_sec_ai_read_current(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_FRACTIONAL;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	case 4: {
+		if (ch->type == IIO_RESISTANCE) {
+			neuronspi_spi_iio_sec_ai_read_resistance(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_FRACTIONAL;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	case 5: {
+		if (ch->type == IIO_RESISTANCE) {
+			neuronspi_spi_iio_sec_ai_read_resistance(indio_dev, ch, val, val2, mask);
+			return IIO_VAL_FRACTIONAL;
+		} else {
+			return -EINVAL;
+		}
+		break;
+	}
+	default: {
+		return -EINVAL;
+		break;
+	}
+	}
+}
+
+int neuronspi_iio_sec_ao_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int *val, int *val2, long mask)
+{
+	return -EINVAL;
+}
+
+int neuronspi_iio_sec_ao_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *ch, int val, int val2, long mask)
+{
+	if (ch->type == IIO_VOLTAGE) {
+		neuronspi_spi_iio_sec_ao_set_voltage(indio_dev, ch, val, val2, mask);
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+
+/*****************************************************************
+ * Probe data and functions 
+ * 
+ *****************************************************************/ 
+static const struct iio_info neuronspi_stm_ai_info = {
+	.read_raw = neuronspi_iio_stm_ai_read_raw,
+#ifdef UNIPI_USE_DRIVER_MODULE
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &neuron_stm_ai_group,
+};
+
+static const struct iio_info neuronspi_stm_ao_info = {
+	.read_raw = neuronspi_iio_stm_ao_read_raw,
+	.write_raw = neuronspi_iio_stm_ao_write_raw,
+#ifdef UNIPI_USE_DRIVER_MODULE
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &neuron_stm_ao_group,
+};
+
+static const struct iio_info neuronspi_sec_ai_info = {
+	.read_raw = neuronspi_iio_sec_ai_read_raw,
+#ifdef UNIPI_USE_DRIVER_MODULE
+	.driver_module = THIS_MODULE,
+#endif
+	.attrs = &neuron_sec_ai_group,
+};
+
+static const struct iio_info neuronspi_sec_ao_info = {
+	.write_raw = neuronspi_iio_sec_ao_write_raw,
+#ifdef UNIPI_USE_DRIVER_MODULE
+	.driver_module = THIS_MODULE,
+#endif
+	.read_raw = neuronspi_iio_sec_ao_read_raw,
+	//.attrs = &neuron_sec_ao_group,
+};
+
+
+struct iio_dev* neuronspi_stm_ai_probe(int io_count, int neuron_index, struct platform_device *board_device)
+{
+    struct spi_device *spi = neuronspi_s_dev[neuron_index];
+    struct iio_dev *iio_driver = devm_iio_device_alloc(&(spi->dev), sizeof(struct neuronspi_analog_data));
+
+	((struct neuronspi_analog_data*)iio_priv(iio_driver))->parent = spi;
+	((struct neuronspi_analog_data*)iio_priv(iio_driver))->index = 0;
+	iio_driver->modes = INDIO_DIRECT_MODE;
+	iio_driver->currentmode = INDIO_DIRECT_MODE;
+	iio_driver->name = "ai_type_a";
+	iio_driver->dev.parent = &(board_device->dev);
+	dev_set_name(&iio_driver->dev, "ai_%d_1", neuron_index + 1);
+	iio_driver->num_channels = 2;
+	iio_driver->channels = neuronspi_stm_ai_chan_spec;
+	iio_driver->info = &neuronspi_stm_ai_info;
+	iio_device_register(iio_driver);
+
+    return iio_driver;
+}
+
+struct iio_dev* neuronspi_stm_ao_probe(int io_count, int neuron_index, struct platform_device *board_device)
+{
+    struct spi_device *spi = neuronspi_s_dev[neuron_index];
+    struct iio_dev *iio_driver = devm_iio_device_alloc(&(spi->dev), sizeof(struct neuronspi_analog_data));
+
+	((struct neuronspi_analog_data*)iio_priv(iio_driver))->parent = spi;
+	((struct neuronspi_analog_data*)iio_priv(iio_driver))->index = 0;
+	iio_driver->modes = INDIO_DIRECT_MODE;
+	iio_driver->currentmode = INDIO_DIRECT_MODE;
+	iio_driver->name = "ao_type_a";
+	iio_driver->dev.parent = &(board_device->dev);
+	dev_set_name(&iio_driver->dev, "ao_%d_1", neuron_index + 1);
+	iio_driver->num_channels = 3;
+	iio_driver->channels = neuronspi_stm_ao_chan_spec;
+	iio_driver->info = &neuronspi_stm_ao_info;
+	iio_device_register(iio_driver);
+
+    return iio_driver;
+}
+
+struct iio_dev** neuronspi_sec_ai_probe(int io_count, int neuron_index, struct platform_device *board_device)
+{
+    struct iio_dev **iio_driver_arr = kzalloc(sizeof(struct neuronspi_analog_data*) * io_count, GFP_ATOMIC);
+    struct spi_device *spi = neuronspi_s_dev[neuron_index];
+    int i;
+
+	for (i = 0; i < io_count; i++) {
+        iio_driver_arr[i] = devm_iio_device_alloc(&(spi->dev), sizeof(struct neuronspi_analog_data));
+        ((struct neuronspi_analog_data*)iio_priv(iio_driver_arr[i]))->parent = spi;
+		((struct neuronspi_analog_data*)iio_priv(iio_driver_arr[i]))->index = i;
+		iio_driver_arr[i]->modes = INDIO_DIRECT_MODE;
+        iio_driver_arr[i]->currentmode = INDIO_DIRECT_MODE;
+		iio_driver_arr[i]->name = "ai_type_b";
+		iio_driver_arr[i]->dev.parent = &(board_device->dev);
+		dev_set_name(&iio_driver_arr[i]->dev, "ai_%d_%d", neuron_index + 1,  i + 1);
+		iio_driver_arr[i]->num_channels = 3;
+		iio_driver_arr[i]->channels = neuronspi_sec_ai_chan_spec;
+		iio_driver_arr[i]->info = &neuronspi_sec_ai_info;
+		iio_device_register(iio_driver_arr[i]);
+    }
+    return iio_driver_arr;
+}
+
+struct iio_dev** neuronspi_sec_ao_probe(int io_count, int neuron_index, struct platform_device *board_device)
+{
+    struct iio_dev **iio_driver_arr = kzalloc(sizeof(struct neuronspi_analog_data*) * io_count, GFP_ATOMIC);
+    struct spi_device *spi = neuronspi_s_dev[neuron_index];
+    int i;
+
+	for (i = 0; i < io_count; i++) {
+        iio_driver_arr[i] = devm_iio_device_alloc(&(spi->dev), sizeof(struct neuronspi_analog_data));
+        ((struct neuronspi_analog_data*)iio_priv(iio_driver_arr[i]))->parent = spi;
+		((struct neuronspi_analog_data*)iio_priv(iio_driver_arr[i]))->index = i;
+		iio_driver_arr[i]->modes = INDIO_DIRECT_MODE;
+        iio_driver_arr[i]->currentmode = INDIO_DIRECT_MODE;
+		iio_driver_arr[i]->name = "ao_type_b";
+		iio_driver_arr[i]->dev.parent = &(board_device->dev);
+		dev_set_name(&iio_driver_arr[i]->dev, "ao_%d_%d", neuron_index + 1,  i + 1);
+		iio_driver_arr[i]->num_channels = 1;
+		iio_driver_arr[i]->channels = neuronspi_sec_ao_chan_spec;
+		iio_driver_arr[i]->info = &neuronspi_sec_ao_info;
+		iio_device_register(iio_driver_arr[i]);
+    }
+    return iio_driver_arr;
+}
diff --git a/drivers/unipi/unipi_iio.h b/drivers/unipi/unipi_iio.h
new file mode 100644
index 000000000000..e7d0d2cf1b9f
--- /dev/null
+++ b/drivers/unipi/unipi_iio.h
@@ -0,0 +1,135 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_IIO_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_IIO_H_
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_common.h"
+
+
+/********************
+ * Data Definitions *
+ ********************/
+ 
+static const struct iio_chan_spec neuronspi_stm_ai_chan_spec[] = {
+	{
+			.type = IIO_VOLTAGE,
+			.indexed = 1,
+			.channel = 0,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 0
+	},
+	{
+			.type = IIO_CURRENT,
+			.indexed = 1,
+			.channel = 1,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 0
+	}
+};
+
+static const struct iio_chan_spec neuronspi_stm_ao_chan_spec[] = {
+	{
+			.type = IIO_VOLTAGE,
+			.indexed = 1,
+			.channel = 0,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 1
+	},
+	{
+			.type = IIO_CURRENT,
+			.indexed = 1,
+			.channel = 1,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 1
+	},
+	{
+			.type = IIO_RESISTANCE,
+			.indexed = 1,
+			.channel = 2,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 0
+	}
+};
+
+static const struct iio_chan_spec neuronspi_sec_ai_chan_spec[] = {
+	{
+			.type = IIO_VOLTAGE,
+			.indexed = 1,
+			.channel = 0,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 0
+	},
+	{
+			.type = IIO_CURRENT,
+			.indexed = 1,
+			.channel = 1,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 0
+	},
+	{
+			.type = IIO_RESISTANCE,
+			.indexed = 1,
+			.channel = 2,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 0
+	}
+};
+
+static const struct iio_chan_spec neuronspi_sec_ao_chan_spec[] = {
+	{
+			.type = IIO_VOLTAGE,
+			.indexed = 1,
+			.channel = 0,
+			.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+			.output = 1
+	}
+};
+
+
+struct neuronspi_sec_ai_driver
+{
+	struct iio *devices;
+	u16 dev_count;
+};
+
+struct neuronspi_sec_ao_driver
+{
+	struct iio *devices;
+	u16 dev_count;
+};
+
+struct neuronspi_analog_data
+{
+	u32 index;
+	u32 mode;
+	struct spi_device *parent;
+};
+
+
+/*************************
+ * Function Declarations *
+ *************************/
+
+struct iio_dev* neuronspi_stm_ai_probe(int io_count, int neuron_index, struct platform_device *board_device);
+struct iio_dev* neuronspi_stm_ao_probe(int io_count, int neuron_index, struct platform_device *board_device);
+struct iio_dev** neuronspi_sec_ai_probe(int io_count, int neuron_index, struct platform_device *board_device);
+struct iio_dev** neuronspi_sec_ao_probe(int io_count, int neuron_index, struct platform_device *board_device);
+
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_IIO_H_ */
diff --git a/drivers/unipi/unipi_misc.c b/drivers/unipi/unipi_misc.c
new file mode 100644
index 000000000000..1ceb1b387c13
--- /dev/null
+++ b/drivers/unipi/unipi_misc.c
@@ -0,0 +1,88 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_misc.h"
+#include "unipi_spi.h"
+
+/************************
+ * Non-static Functions *
+ ************************/
+
+void neuronspi_spi_led_set_brightness(struct spi_device* spi_dev, int brightness, u16 coil)
+{
+    unipispi_modbus_write_coil(spi_dev, coil, brightness);
+}
+
+
+void neuronspi_led_proc(struct kthread_work *ws)
+{
+	struct neuronspi_led_driver *led = to_led_driver(ws, led_work);
+	neuronspi_spi_led_set_brightness(led->spi, led->brightness > 0, led->coil);
+#if NEURONSPI_DETAILED_DEBUG > 0
+	printk(KERN_INFO "UNIPISPI: SPI LED Set, Dev-CS:%d, led id:%d\n", led->spi->chip_select, led->id);
+#endif
+}
+
+void neuronspi_led_set_brightness(struct led_classdev *ldev, enum led_brightness brightness)
+{
+	struct neuronspi_led_driver *led = container_of(ldev, struct neuronspi_led_driver, ldev);
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(led->spi);
+	unsigned long flags;
+	spin_lock_irqsave(&led->lock, flags);
+	led->brightness = brightness;
+	kthread_queue_work(n_spi->primary_worker, &led->led_work);
+	spin_unlock_irqrestore(&led->lock, flags);
+}
+
+
+
+struct neuronspi_led_driver * neuronspi_led_probe(int uled_count, int sysled_count, int neuron_index, struct platform_device *board_device)
+{
+    struct spi_device* spi = neuronspi_s_dev[neuron_index];
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+    int led_count = uled_count + sysled_count;
+	struct neuronspi_led_driver * led_driver = kzalloc(sizeof(struct neuronspi_led_driver) * led_count, GFP_ATOMIC);
+	int i, coil;
+
+	if (n_spi->features != NULL) {
+		coil = n_spi->features->di_count + n_spi->features->do_count + n_spi->features->ro_count;
+	} else {
+		coil = 8;
+	}
+	
+	for (i = 0; i < led_count; i++) {
+        if (i < uled_count) {
+			scnprintf(led_driver[i].name, sizeof(led_driver[i].name), "unipi:green:uled-x%x", i);
+		} else {
+			scnprintf(led_driver[i].name, sizeof(led_driver[i].name), "unipi:green:sysled-x%x", i-uled_count);
+		}
+		// Initialise the rest of the structure
+		led_driver[i].id = i;
+		led_driver[i].coil = coil+i;
+		led_driver[i].brightness = LED_OFF;
+		led_driver[i].spi = spi;
+
+		spin_lock_init(&led_driver[i].lock);
+		led_driver[i].ldev.name = led_driver[i].name;
+		led_driver[i].ldev.brightness = led_driver[i].brightness;
+		led_driver[i].ldev.brightness_set = neuronspi_led_set_brightness;
+		led_classdev_register(&(board_device->dev), &(led_driver[i].ldev));
+		kthread_init_work(&(led_driver[i].led_work), neuronspi_led_proc);
+	}
+	return led_driver;
+}
\ No newline at end of file
diff --git a/drivers/unipi/unipi_misc.h b/drivers/unipi/unipi_misc.h
new file mode 100644
index 000000000000..4e4f3705fc33
--- /dev/null
+++ b/drivers/unipi/unipi_misc.h
@@ -0,0 +1,46 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_MISC_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_MISC_H_
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_common.h"
+
+// Instantiated once per LED
+struct neuronspi_led_driver
+{
+	struct led_classdev	ldev;
+	struct spi_device	*spi;
+	struct kthread_work	led_work;
+    int                 id;
+    u16                 coil;
+	int					brightness;
+	char				name[sizeof("unipi:green:sysled-x1")];
+	spinlock_t			lock;
+};
+
+
+/*************************
+ * Function Declarations *
+ *************************/
+
+void neuronspi_led_proc(struct kthread_work *ws);
+void neuronspi_led_set_brightness(struct led_classdev *ldev, enum led_brightness brightness);
+struct neuronspi_led_driver * neuronspi_led_probe(int uled_count, int sysled_count, int neuron_index, struct platform_device *board_device);
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_MISC_H_ */
diff --git a/drivers/unipi/unipi_platform.c b/drivers/unipi/unipi_platform.c
new file mode 100644
index 000000000000..d482af7a88ff
--- /dev/null
+++ b/drivers/unipi/unipi_platform.c
@@ -0,0 +1,2404 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+/************
+ * Includes *
+ ************/
+
+#include "unipi_platform.h"
+#include "unipi_spi.h"
+#include "unipi_common.h"
+#include "unipi_sysfs.h"
+#include "unipi_misc.h"
+#include "unipi_gpio.h"
+#include "unipi_iio.h"
+
+/***************************
+ * Static Data Definitions *
+ ***************************/
+
+// B_1000 (S103)
+#define NEURONSPI_BOARD_B1000_HW_DEFINITION_BLOCK_SIZE 57
+static u32 NEURONSPI_BOARD_B1000_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_B1000_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 21,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_AO_BRAIN | NEURONSPI_REGFLAG_ACC_AFAP,											// 2
+		NEURONSPI_REGFUN_AI_BRAIN | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,   	// 3
+		NEURONSPI_REGFUN_AIO_BRAIN | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 4
+		NEURONSPI_REGFUN_V_REF_INP | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 5
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 6
+		NEURONSPI_REGFUN_TX_QUEUE_LEN | NEURONSPI_REGFLAG_ACC_10HZ,										// 7
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 8
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 9
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 10
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 11
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 12
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 13
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 14
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 15
+		NEURONSPI_REGFUN_PWM_DUTY | NEURONSPI_REGFLAG_ACC_6SEC, 										// 16
+		NEURONSPI_REGFUN_PWM_DUTY | NEURONSPI_REGFLAG_ACC_6SEC,											// 17
+		NEURONSPI_REGFUN_PWM_DUTY | NEURONSPI_REGFLAG_ACC_6SEC,											// 18
+		NEURONSPI_REGFUN_PWM_DUTY | NEURONSPI_REGFLAG_ACC_6SEC,											// 19
+		NEURONSPI_REGFUN_LED_RW | NEURONSPI_REGFLAG_ACC_AFAP, 											// 20
+		1000, 32, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE  | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE,										// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DS_ENABLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1014
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1015
+		NEURONSPI_REGFUN_DS_TOGGLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1016
+		NEURONSPI_REGFUN_PWM_PRESCALE | NEURONSPI_REGFLAG_ACC_1HZ,							    		// 1017
+		NEURONSPI_REGFUN_PWM_CYCLE | NEURONSPI_REGFLAG_ACC_1HZ,							    			// 1018
+		NEURONSPI_REGFUN_AO_BRAIN_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1019
+		NEURONSPI_REGFUN_AO_BRAIN_V_ERR | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1020
+		NEURONSPI_REGFUN_AO_BRAIN_V_OFF | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1021
+		NEURONSPI_REGFUN_AO_BRAIN_I_ERR | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1022
+		NEURONSPI_REGFUN_AO_BRAIN_I_OFF | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY, // 1023
+		NEURONSPI_REGFUN_AI_BRAIN_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1024
+		NEURONSPI_REGFUN_AI_BRAIN_V_ERR | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY, // 1025
+		NEURONSPI_REGFUN_AI_BRAIN_V_OFF | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1026
+		NEURONSPI_REGFUN_AI_BRAIN_I_ERR | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1027
+		NEURONSPI_REGFUN_AI_BRAIN_I_OFF | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1028
+		NEURONSPI_REGFUN_AIO_BRAIN_OFF | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1029
+		NEURONSPI_REGFUN_AIO_BRAIN_ERR | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,  // 1030
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC										// 1031
+};
+
+#define NEURONSPI_BOARD_B1000_HW_FEATURES {	\
+		.do_count =					  4,	\
+		.ro_count =					  0,	\
+		.ds_count =					  4,	\
+		.di_count =					  4,	\
+		.led_count =				  4,	\
+		.stm_ai_count =				  1,	\
+		.stm_ao_count =				  1,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  1,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  4,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  1,    \
+		.sysled_count =				 16,	\
+}
+
+#define NEURONSPI_BOARD_B1000_HW_DEFINITION { \
+		.combination_board_id = 	0, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_B1000_ID, \
+ 		.upper_board_id = 			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.block_count = 				NEURONSPI_BOARD_B1000_HW_DEFINITION_BLOCK_SIZE, \
+		.name_length =				6, \
+		.combination_name =			"B_1000", \
+		.features =					NEURONSPI_BOARD_B1000_HW_FEATURES, \
+		.blocks = 					NEURONSPI_BOARD_B1000_HW_DEFINITION_BLOCK \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_B1000_HW_COMBINATION[] = {NEURONSPI_BOARD_B1000_HW_DEFINITION};
+
+// E-8Di8Ro (M103)
+#define NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION_BLOCK_SIZE 44
+static u32 NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 19,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 2
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 3
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 4
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 5
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 6
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 7
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 8
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 9
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 10
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 11
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 12
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 13
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 18
+		1000, 21, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DS_ENABLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1018
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1019
+		NEURONSPI_REGFUN_DS_TOGGLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1020
+};
+
+#define NEURONSPI_BOARD_E8DI8RO_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  8,	\
+		.ds_count =					  8,	\
+		.di_count =					  8,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  6,	\
+}
+
+#define NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION { \
+		.combination_board_id = 	1, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E8DI8RO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.block_count = 				NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION_BLOCK_SIZE, \
+		.name_length =				8, \
+		.combination_name =			"E_8Di8Ro", \
+		.blocks = 					NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E8DI8RO_HW_FEATURES	\
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E8DI8RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION};
+
+// E-14Ro
+#define NEURONSPI_BOARD_E14RO_HW_DEFINITION_BLOCK_SIZE 17
+static u32 NEURONSPI_BOARD_E14RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E14RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 3,	// Register block beginning and size
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 0
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 1
+		NEURONSPI_REGFUN_LED_RW | NEURONSPI_REGFLAG_ACC_1HZ,		                					// 2
+		1000, 10, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE,											// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE, 										// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE, 										// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE, 											// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE, 									// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE,									// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE,									// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE,										// 1009
+};
+
+#define NEURONSPI_BOARD_E14RO_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  14,	\
+		.ds_count =					  0,	\
+		.di_count =					  0,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E14RO_HW_DEFINITION { \
+		.combination_board_id = 	2, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E14RO_ID, \
+		.upper_board_id =			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.block_count =				NEURONSPI_BOARD_E14RO_HW_DEFINITION_BLOCK_SIZE, \
+		.name_length =				6, \
+		.combination_name =			"E_14Ro", \
+		.blocks =					NEURONSPI_BOARD_E14RO_HW_DEFINITION_BLOCK, \
+		.features = 				NEURONSPI_BOARD_E14RO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E14RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E14RO_HW_DEFINITION};
+
+// E-16Di
+#define NEURONSPI_BOARD_E16DI_HW_DEFINITION_BLOCK_SIZE 64
+static u32 NEURONSPI_BOARD_E16DI_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E16DI_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 34,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC,									 	// 1
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 2
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 3
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 4
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 5
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 6
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 7
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 8
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 9
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 10
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 11
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 12
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 13
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 14
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 15
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 16
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 17
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 18
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 19
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 20
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 21
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 22
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 23
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 24
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 25
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 26
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 27
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 28
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 29
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 30
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 31
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 32
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 33
+		1000, 26, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1018
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1019
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1020
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1021
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1022
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1023
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1024
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1025
+};
+
+#define NEURONSPI_BOARD_E16DI_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  0,	\
+		.ds_count =					  0,	\
+		.di_count =					  16,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E16DI_HW_DEFINITION { \
+		.combination_board_id = 	3, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E16DI_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.block_count = 				NEURONSPI_BOARD_E16DI_HW_DEFINITION_BLOCK_SIZE, \
+		.name_length =				6, \
+		.combination_name =			"E_16Di", \
+		.blocks = 					NEURONSPI_BOARD_E16DI_HW_DEFINITION_BLOCK, \
+		.features = 				NEURONSPI_BOARD_E16DI_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E16DI_HW_COMBINATION[] = {NEURONSPI_BOARD_E16DI_HW_DEFINITION};
+
+// E-8Di8Ro_P-11DiR485 (xS10)
+#define NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_DEFINITION_BLOCK_SIZE 47
+static u32 NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 20,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 2
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 3
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 4
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 5
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 6
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 7
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 8
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 9
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 10
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 11
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 12
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 13
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 18
+		NEURONSPI_REGFUN_LED_RW | NEURONSPI_REGFLAG_ACC_1HZ,											// 19
+		1000, 23, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE,											// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE, 										// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE, 										// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE, 											// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE, 									// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE,									// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE,									// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE,										// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DS_ENABLE   | NEURONSPI_REGFLAG_ACC_1HZ,										// 1018
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1019
+		NEURONSPI_REGFUN_DS_TOGGLE   | NEURONSPI_REGFLAG_ACC_1HZ,										// 1020
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC,										// 1021
+		NEURONSPI_REGFUN_RS485_ADDRESS | NEURONSPI_REGFLAG_ACC_6SEC										// 1022
+};
+
+#define NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  8,	\
+		.ds_count =					  8,	\
+		.di_count =					  8,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  1,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  1,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_DEFINITION { \
+		.combination_board_id = 	4, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E8DI8RO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_P11DIR485_ID, \
+		.block_count = 				NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_DEFINITION_BLOCK_SIZE, \
+		.name_length =				19, \
+		.combination_name =			"E_8Di8Ro_P_11DiR485", \
+		.blocks = 					NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_COMBINATION[] = {NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_DEFINITION};
+
+// E-14Ro_P-11DiR485 (xS40)
+#define NEURONSPI_BOARD_E14ROP11DIR485_HW_DEFINITION_BLOCK_SIZE 71
+static u32 NEURONSPI_BOARD_E14ROP11DIR485_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E14ROP11DIR485_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 36,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 2
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 3
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 4
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 5
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 6
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 7
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 8
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 9
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 10
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 11
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 12
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 13
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 18
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 19
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 20
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 21
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 22
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 23
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 24
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 25
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 26
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 27
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 28
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 29
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 30
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 31
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 32
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 33
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 34
+		NEURONSPI_REGFUN_LED_RW | NEURONSPI_REGFLAG_ACC_1HZ,		                					// 35
+		1000, 31, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE,											// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE, 										// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE, 										// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE, 											// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE, 									// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE,									// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE,									// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE,										// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1018
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1019
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1020
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1021
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1022
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1023
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1024
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1025
+		NEURONSPI_REGFUN_DS_ENABLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1026
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1027
+		NEURONSPI_REGFUN_DS_TOGGLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1028
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC,										// 1029
+		NEURONSPI_REGFUN_RS485_ADDRESS | NEURONSPI_REGFLAG_ACC_6SEC										// 1030
+};
+
+#define NEURONSPI_BOARD_E14ROP11DIR485_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  14,	\
+		.ds_count =					  8,	\
+		.di_count =					  8,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  1,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  1,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E14ROP11DIR485_HW_DEFINITION { \
+		.combination_board_id = 	5, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E14RO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_P11DIR485_ID, \
+		.name_length =				17, \
+		.combination_name =			"E_14Ro_P_11DiR485", \
+		.block_count = 				NEURONSPI_BOARD_E14ROP11DIR485_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E14ROP11DIR485_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E14ROP11DIR485_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E14ROP11DIR485_HW_COMBINATION[] = {NEURONSPI_BOARD_E14ROP11DIR485_HW_DEFINITION};
+
+// E-16Di_P-11DiR485 (xS30)
+#define NEURONSPI_BOARD_E16DIP11DIR485_HW_DEFINITION_BLOCK_SIZE 92
+static u32 NEURONSPI_BOARD_E16DIP11DIR485_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E16DIP11DIR485_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 52,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC,									 	// 2
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 3
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 4
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 5
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 6
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 7
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 8
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 9
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 10
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 11
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 12
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 13
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 18
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 19
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 20
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 21
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 22
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 23
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 24
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 25
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 26
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 27
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 28
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 29
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 30
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 31
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 32
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 33
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 34
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 35
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 36
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 37
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 38
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 39
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 40
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 41
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 42
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 43
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 44
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 45
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 46
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 47
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 48
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 49
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 50
+		NEURONSPI_REGFUN_LED_RW | NEURONSPI_REGFLAG_ACC_1HZ,											// 51
+		1000, 36, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1018
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1019
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1020
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1021
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1022
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1023
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1024
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1025
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1026
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1027
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1028
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1029
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1030
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1031
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1032
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1033
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC,										// 1034
+		NEURONSPI_REGFUN_RS485_ADDRESS | NEURONSPI_REGFLAG_ACC_6SEC										// 1035
+};
+
+#define NEURONSPI_BOARD_E16DIP11DIR485_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  0,	\
+		.ds_count =					  0,	\
+		.di_count =					  23,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  1,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  1,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E16DIP11DIR485_HW_DEFINITION { \
+		.combination_board_id = 	6, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E16DI_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_P11DIR485_ID, \
+		.name_length =				17, \
+		.combination_name =			"E_16Di_P_11DiR485", \
+		.block_count = 				NEURONSPI_BOARD_E16DIP11DIR485_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E16DIP11DIR485_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E16DIP11DIR485_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E16DIP11DIR485_HW_COMBINATION[] = {NEURONSPI_BOARD_E16DIP11DIR485_HW_DEFINITION};
+
+// E-14Ro_U-14Ro (M403)
+#define NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION_BLOCK_SIZE 17
+static u32 NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 3,	// Register block beginning and size
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 2
+		1000, 10, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+};
+
+#define NEURONSPI_BOARD_E14ROU14RO_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  28,	\
+		.ds_count =					  0,	\
+		.di_count =					  0,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  1,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION { \
+		.combination_board_id = 	7, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E14RO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_U14RO_ID, \
+		.name_length =				13, \
+		.combination_name =			"E_14Ro_U_14Ro", \
+		.block_count = 				NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION_BLOCK, \
+		.features = 				NEURONSPI_BOARD_E14ROU14RO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E14ROU14RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION};
+
+// E-16Di_U-14Ro (M203)
+#define NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION_BLOCK_SIZE 68
+static u32 NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 35,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 2
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 3
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 4
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 5
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 6
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 7
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 8
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 9
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 10
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 11
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 12
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 13
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 18
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 19
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 20
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 21
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 22
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 23
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 24
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 25
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 26
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 27
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 28
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 29
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 30
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 31
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 32
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 33
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 34
+		1000, 29, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1018
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1019
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1020
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1021
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1022
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1023
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1024
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1025
+		NEURONSPI_REGFUN_DS_ENABLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1026
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1027
+		NEURONSPI_REGFUN_DS_TOGGLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1028
+};
+
+#define NEURONSPI_BOARD_E16DIU14RO_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  14,	\
+		.ds_count =					  14,	\
+		.di_count =					  16,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION { \
+		.combination_board_id = 	8, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E16DI_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_U14RO_ID, \
+		.name_length =				13, \
+		.combination_name =			"E_16Di_U_14Ro", \
+		.block_count = 				NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E16DIU14RO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E16DIU14RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION};
+
+// E-14Ro_U-14Di (L503)
+#define NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION_BLOCK_SIZE 62
+static u32 NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 31,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 2
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 3
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 4
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 5
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 6
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 7
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 8
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 9
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 10
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 11
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 12
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 13
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 18
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 19
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 20
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 21
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 22
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 23
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 24
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 25
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 26
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 27
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 28
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 29
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 30
+		1000, 27, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1018
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1019
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1020
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1021
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1022
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1023
+		NEURONSPI_REGFUN_DS_ENABLE | NEURONSPI_REGFLAG_ACC_1HZ,											// 1024
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1025
+		NEURONSPI_REGFUN_DS_TOGGLE | NEURONSPI_REGFLAG_ACC_1HZ											// 1026
+};
+
+#define NEURONSPI_BOARD_E14ROU14DI_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  14,	\
+		.ds_count =					  14,	\
+		.di_count =					  14,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION { \
+		.combination_board_id = 	9, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E14RO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_U14DI_ID, \
+		.name_length =				13, \
+		.combination_name =			"E_14Ro_U_14Di", \
+		.block_count = 				NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E14ROU14DI_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E14ROU14DI_HW_COMBINATION[] = {NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION};
+
+
+// E-16Di_U-14Di (M303)
+#define NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION_BLOCK_SIZE 107
+static u32 NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 63,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 											// 1
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 2
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 3
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 4
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 5
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 6
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 7
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 8
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 9
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 10
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 11
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 12
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 13
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 18
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 19
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 20
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 21
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 22
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 23
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 24
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 25
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 26
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 27
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 28
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 29
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 30
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 31
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 32
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 33
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 34
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 35
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 36
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 37
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 38
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 39
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 40
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 41
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 42
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 43
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 44
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 45
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 46
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 47
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 48
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 49
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 50
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 51
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 52
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 53
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 54
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 55
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 56
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 57
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 58
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 59
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 60
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 61
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 62
+		1000, 40, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1016
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1017
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1018
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1019
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1020
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1021
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1022
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1023
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1024
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1025
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1026
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1027
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1028
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1029
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1030
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1031
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1032
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1033
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1034
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1035
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1036
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1037
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1038
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1039
+};
+
+#define NEURONSPI_BOARD_E16DIU14DI_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  0,	\
+		.ds_count =					  0,	\
+		.di_count =					  30,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION { \
+		.combination_board_id = 	10, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E16DI_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_U14DI_ID, \
+		.name_length =				13, \
+		.combination_name =			"E_16Di_U_14Di", \
+		.block_count = 				NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E16DIU14DI_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E16DIU14DI_HW_COMBINATION[] = {NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION};
+
+// E-4Ai4Ao
+#define NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION_BLOCK_SIZE 31
+static u32 NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 13,	// Register block beginning and size
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 0
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 1
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 2
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 3
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 4
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 5
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 6
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 7
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 8
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 9
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 10
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 11
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC,										 	// 12
+		1000, 14, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1010
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1011
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1012
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1013
+};
+
+#define NEURONSPI_BOARD_E4AI4AO_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  0,	\
+		.ds_count =					  0,	\
+		.di_count =					  0,	\
+		.led_count =				  14,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  4,	\
+		.sec_ao_count =				  4,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  16,	\
+}
+
+
+#define NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION { \
+		.combination_board_id = 	11, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E4AI4AO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.name_length =				8, \
+		.combination_name =			"E_4Ai4Ao", \
+		.block_count = 				NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E4AI4AO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AO_HW_COMBINATION[] = {NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION};
+
+// E-4Ai4Ao_P-6Di5Ro (xS50)
+#define NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_DEFINITION_BLOCK_SIZE 56
+static u32 NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 27,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 												// 1
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 2
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 3
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 4
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 5
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 6
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 7
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 8
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 9
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 10
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 11
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 12
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 13
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC,										 	// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC,	 									// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 18
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 19
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 20
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 21
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 22
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 23
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 24
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 25
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 26
+		1000, 25, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1015
+		NEURONSPI_REGFUN_DS_ENABLE   | NEURONSPI_REGFLAG_ACC_1HZ,										// 1016
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1017
+		NEURONSPI_REGFUN_DS_TOGGLE   | NEURONSPI_REGFLAG_ACC_1HZ,										// 1018
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1019
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1020
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1021
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1022
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC,										// 1023
+		NEURONSPI_REGFUN_RS485_ADDRESS | NEURONSPI_REGFLAG_ACC_6SEC										// 1024
+};
+
+#define NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  5,	\
+		.ds_count =					  5,	\
+		.di_count =					  6,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  4,	\
+		.sec_ao_count =				  4,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  1,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  1,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_DEFINITION { \
+		.combination_board_id = 	12, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E4AI4AO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_P6DI5RO_ID, \
+		.name_length =				17, \
+		.combination_name =			"E_4Ai4Ao_P_6Di5Ro", \
+		.block_count = 				NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_DEFINITION};
+
+// B-485
+#define NEURONSPI_BOARD_B485_HW_DEFINITION_BLOCK_SIZE 15
+static u32 NEURONSPI_BOARD_B485_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_B485_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 1,	// Register block beginning and size
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 0
+		1000, 10,
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+};
+
+#define NEURONSPI_BOARD_B485_HW_FEATURES {	\
+	.do_count =					  0,	\
+	.ro_count =					  0,	\
+	.ds_count =					  0,	\
+	.di_count =					  0,	\
+	.led_count =				  0,	\
+	.stm_ai_count =				  0,	\
+	.stm_ao_count =				  0,	\
+	.sec_ai_count =				  4,	\
+	.sec_ao_count =				  4,	\
+	.uart_master_count =		  1,	\
+	.uart_slave_count = 		  0,	\
+	.pwm_channel_count = 		  0,	\
+	.wd_count = 				  1,	\
+	.extension_sys_count = 		  0,	\
+	.light_count = 				  0,	\
+	.owire_count =				  0,    \
+	.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_B485_HW_DEFINITION { \
+		.combination_board_id = 	13, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_B485_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.name_length =				5, \
+		.combination_name =			"B_485", \
+		.block_count = 				NEURONSPI_BOARD_B485_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_B485_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_B485_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_B485_HW_COMBINATION[] = {NEURONSPI_BOARD_B485_HW_DEFINITION};
+
+// E-4Light (M613)
+#define NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION_BLOCK_SIZE 35
+static u32 NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 21,	// Register block beginning and size
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 0
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 1
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 2
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 3
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 4
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 5
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 6
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 7
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 8
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 9
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 10
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 11
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 12
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 13
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 14
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 15
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 16
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 17
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 18
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 19
+		NEURONSPI_REGFUN_NONE_TEST | NEURONSPI_REGFLAG_ACC_ONCE,										// 20
+		1000, 10,
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+};
+
+#define NEURONSPI_BOARD_E4LIGHT_HW_FEATURES {	\
+	.do_count =					  0,	\
+	.ro_count =					  0,	\
+	.ds_count =					  0,	\
+	.di_count =					  0,	\
+	.led_count =				  0,	\
+	.stm_ai_count =				  0,	\
+	.stm_ao_count =				  0,	\
+	.sec_ai_count =				  0,	\
+	.sec_ao_count =				  0,	\
+	.uart_master_count =		  0,	\
+	.uart_slave_count = 		  0,	\
+	.pwm_channel_count = 		  0,	\
+	.wd_count = 				  1,	\
+	.extension_sys_count = 		  0,	\
+	.light_count = 				  4,	\
+	.owire_count =				  0,    \
+	.sysled_count =				 16,	\
+}
+
+#define NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION { \
+		.combination_board_id = 	14, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E4LIGHT_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.name_length =				8, \
+		.combination_name =			"E_4Light", \
+		.block_count = 				NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E4LIGHT_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E4LIGHT_HW_COMBINATION[] = {NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION};
+
+// E-4Ai4Ao_U-6Di5Ro (L503)
+#define NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION_BLOCK_SIZE 56
+static u32 NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 28,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 													// 1
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 2
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 3
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 4
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 5
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP, 	// 6
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP, 	// 7
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 8
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 9
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 10
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 11
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 12
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 13
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 			// 14
+		NEURONSPI_REGFUN_TX_QUEUE_LEN | NEURONSPI_REGFLAG_ACC_10HZ,												// 15
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 16
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 17
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 18
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 19
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 20
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 21
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 22
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 23
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 24
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 25
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 26
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 27
+		1000, 24, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,					// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,					// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,												// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 													// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 												// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1013
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1014
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1015
+		NEURONSPI_REGFUN_DS_ENABLE | NEURONSPI_REGFLAG_ACC_1HZ,													// 1016
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,												// 1017
+		NEURONSPI_REGFUN_DS_TOGGLE | NEURONSPI_REGFLAG_ACC_1HZ,													// 1018
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1019
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1020
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1021
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1022
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC												// 1023
+};
+
+#define NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_FEATURES {	\
+	.do_count =					  0,	\
+	.ro_count =					  5,	\
+	.ds_count =					  5,	\
+	.di_count =					  6,	\
+	.led_count =				  0,	\
+	.stm_ai_count =				  0,	\
+	.stm_ao_count =				  0,	\
+	.sec_ai_count =				  4,	\
+	.sec_ao_count =				  4,	\
+	.uart_master_count =		  0,	\
+	.uart_slave_count = 		  0,	\
+	.pwm_channel_count = 		  0,	\
+	.wd_count = 				  1,	\
+	.extension_sys_count = 		  0,	\
+	.light_count = 				  0,	\
+	.owire_count =				  0,    \
+	.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION { \
+		.combination_board_id = 	15, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E4AI4AO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_U6DI5RO_ID, \
+		.name_length =				17, \
+		.combination_name =			"E_4Ai4Ao_U_6Di5Ro", \
+		.block_count = 				NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION};
+
+// E-4Ai4Ao_P-4Di5Ro (xS5x)
+#define NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_DEFINITION_BLOCK_SIZE 52
+static u32 NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 23,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 												// 1
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 2
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 3
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 4
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_10HZ,											// 5
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 6
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 7
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 8
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 9
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 10
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 11
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 12
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 13
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC,										 	// 14
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC,	 									// 15
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 16
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 17
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 18
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 19
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 20
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 									// 21
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,										// 22
+		1000, 25, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+		NEURONSPI_REGFUN_DS_ENABLE   | NEURONSPI_REGFLAG_ACC_1HZ,										// 1014
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,										// 1015
+		NEURONSPI_REGFUN_DS_TOGGLE   | NEURONSPI_REGFLAG_ACC_1HZ,										// 1016
+		NEURONSPI_REGFUN_SPECIAL_NULL | NEURONSPI_REGFLAG_SYS_READ_ONLY,			                    // 1017
+		NEURONSPI_REGFUN_SPECIAL_NULL | NEURONSPI_REGFLAG_SYS_READ_ONLY,			                    // 1018
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1019
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1020
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1021
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,										// 1022
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC,										// 1023
+		NEURONSPI_REGFUN_RS485_ADDRESS | NEURONSPI_REGFLAG_ACC_6SEC										// 1024
+};
+
+#define NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  5,	\
+		.ds_count =					  4,	\
+		.di_count =					  4,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  4,	\
+		.sec_ao_count =				  4,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  1,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  1,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_DEFINITION { \
+		.combination_board_id = 	0x12, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E4AI4AO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_P4DI5RO_ID, \
+		.name_length =				17, \
+		.combination_name =			"E_4Ai4Ao_P_4Di5Ro", \
+		.block_count = 				NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_DEFINITION};
+
+// E-4Ai4Ao_U-4Di5Ro (L5x3)
+#define NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION_BLOCK_SIZE 52
+static u32 NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION_BLOCK[NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 24,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 0
+		NEURONSPI_REGFUN_DO_RW | NEURONSPI_REGFLAG_ACC_10HZ, 													// 1
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 2
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 3
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 4
+		NEURONSPI_REGFUN_AO_VER2_RW | NEURONSPI_REGFLAG_ACC_AFAP,												// 5
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP, 	// 6
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP, 	// 7
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 8
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 9
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 10
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 11
+		NEURONSPI_REGFUN_AI_VER2_READ_LOWER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 12
+		NEURONSPI_REGFUN_AI_VER2_READ_UPPER | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY, 	// 13
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC | NEURONSPI_REGFLAG_SYS_READ_ONLY, 			// 14
+		NEURONSPI_REGFUN_TX_QUEUE_LEN | NEURONSPI_REGFLAG_ACC_10HZ,												// 15
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 16
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 17
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 18
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 19
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 20
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 21
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 										// 22
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,											// 23
+		1000, 24, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,					// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,					// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,												// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 													// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,				// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 												// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,												// 1013
+		NEURONSPI_REGFUN_DS_ENABLE | NEURONSPI_REGFLAG_ACC_1HZ,													// 1014
+		NEURONSPI_REGFUN_DS_POLARITY | NEURONSPI_REGFLAG_ACC_1HZ,												// 1015
+		NEURONSPI_REGFUN_DS_TOGGLE | NEURONSPI_REGFLAG_ACC_1HZ,													// 1016
+		NEURONSPI_REGFUN_SPECIAL_NULL | NEURONSPI_REGFLAG_SYS_READ_ONLY,			                            // 1017
+		NEURONSPI_REGFUN_SPECIAL_NULL | NEURONSPI_REGFLAG_SYS_READ_ONLY,			                            // 1018
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1019
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1020
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1021
+		NEURONSPI_REGFUN_AI_VER2_MODE | NEURONSPI_REGFLAG_ACC_1HZ,												// 1022
+		NEURONSPI_REGFUN_RS485_CONFIG | NEURONSPI_REGFLAG_ACC_6SEC												// 1023
+};
+
+#define NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_FEATURES {	\
+	.do_count =					  0,	\
+	.ro_count =					  5,	\
+	.ds_count =					  5,	\
+	.di_count =					  4,	\
+	.led_count =				  0,	\
+	.stm_ai_count =				  0,	\
+	.stm_ao_count =				  0,	\
+	.sec_ai_count =				  4,	\
+	.sec_ao_count =				  4,	\
+	.uart_master_count =		  0,	\
+	.uart_slave_count = 		  0,	\
+	.pwm_channel_count = 		  0,	\
+	.wd_count = 				  1,	\
+	.extension_sys_count = 		  0,	\
+	.light_count = 				  0,	\
+	.owire_count =				  0,    \
+	.sysled_count =				  0,	\
+}
+
+#define NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION { \
+		.combination_board_id = 	0x13, \
+		.lower_board_id = 			NEURONSPI_BOARD_LOWER_E4AI4AO_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_U4DI5RO_ID, \
+		.name_length =				17, \
+		.combination_name =			"E_4Ai4Ao_U_4Di5Ro", \
+		.block_count = 				NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION_BLOCK, \
+		.features =					NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_FEATURES \
+}
+struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_COMBINATION[] = {NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION};
+
+
+// IRIS_BOARD_ICDIS4
+#define IRIS_BOARD_ICDIS4_HW_DEFINITION_BLOCK_SIZE 28 //Reg count + 4
+static u32 IRIS_BOARD_ICDIS4_HW_DEFINITION_BLOCK[IRIS_BOARD_ICDIS4_HW_DEFINITION_BLOCK_SIZE] = {
+		0, 10,	// Register block beginning and size
+		NEURONSPI_REGFUN_DI_READ | NEURONSPI_REGFLAG_ACC_AFAP | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 0
+		NEURONSPI_REGFUN_MWD_STATUS | NEURONSPI_REGFLAG_ACC_6SEC,									 	// 1
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 2
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 3
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 4
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 5
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 6
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 7
+		NEURONSPI_REGFUN_DI_COUNTER_LOWER | NEURONSPI_REGFLAG_ACC_6SEC, 								// 8
+		NEURONSPI_REGFUN_DI_COUNTER_UPPER | NEURONSPI_REGFLAG_ACC_6SEC,									// 9
+		1000, 14, // Register block beginning and size
+		NEURONSPI_REGFUN_SW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1000
+		NEURONSPI_REGFUN_DIDO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1001
+		NEURONSPI_REGFUN_UAIO_COUNT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1002
+		NEURONSPI_REGFUN_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,			// 1003
+		NEURONSPI_REGFUN_FLASH_HW_VER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,	// 1004
+		NEURONSPI_REGFUN_SERIAL_NR_LOWER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1005
+		NEURONSPI_REGFUN_SERIAL_NR_UPPER | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,// 1006
+		NEURONSPI_REGFUN_INTERRUPTS | NEURONSPI_REGFLAG_ACC_AFAP,										// 1007
+		NEURONSPI_REGFUN_MWD_TO | NEURONSPI_REGFLAG_ACC_6SEC, 											// 1008
+		NEURONSPI_REGFUN_V_REF_INT | NEURONSPI_REGFLAG_ACC_ONCE | NEURONSPI_REGFLAG_SYS_READ_ONLY,		// 1009
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1010
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC, 										// 1011
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1012
+		NEURONSPI_REGFUN_DI_DEBOUNCE | NEURONSPI_REGFLAG_ACC_6SEC,										// 1013
+};
+
+#define IRIS_BOARD_ICDIS4_HW_FEATURES {	\
+		.do_count =					  0,	\
+		.ro_count =					  0,	\
+		.ds_count =					  0,	\
+		.di_count =					  4,	\
+		.led_count =				  0,	\
+		.stm_ai_count =				  0,	\
+		.stm_ao_count =				  0,	\
+		.sec_ai_count =				  0,	\
+		.sec_ao_count =				  0,	\
+		.uart_master_count =		  0,	\
+		.uart_slave_count = 		  0,	\
+		.pwm_channel_count = 		  0,	\
+		.wd_count = 				  1,	\
+		.extension_sys_count = 		  0,	\
+		.light_count = 				  0,	\
+		.owire_count =				  0,    \
+		.sysled_count =				  0,	\
+}
+
+#define IRIS_BOARD_ICDIS4_HW_DEFINITION { \
+		.combination_board_id = 	25, \
+		.lower_board_id = 			IRIS_BOARD_ICDIS4_ID, \
+		.upper_board_id = 			NEURONSPI_BOARD_UPPER_NONE_ID, \
+		.name_length =				7, \
+		.combination_name =			"IC-DIS4", \
+		.block_count = 				IRIS_BOARD_ICDIS4_HW_DEFINITION_BLOCK_SIZE, \
+		.blocks = 					IRIS_BOARD_ICDIS4_HW_DEFINITION_BLOCK, \
+		.features =					IRIS_BOARD_ICDIS4_HW_FEATURES \
+}
+struct neuronspi_board_combination IRIS_BOARD_ICDIS4_HW_COMBINATION[] = {IRIS_BOARD_ICDIS4_HW_DEFINITION};
+
+
+
+/********************
+ * Data Definitions *
+ ********************/
+
+struct platform_device *neuron_plc_dev;
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S103_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S103G_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103G_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S103IQ_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103IQ_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S103EO_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103EO_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S105_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S105_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S115_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S115_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S155_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S155_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S205_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S205_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S215_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S215_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S505_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S505_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S515_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S515_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_E4AI4AO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_S605_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S605_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M103_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M103_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E8DI8RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M203_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M203_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M303_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M303_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M403_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M403_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M503_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M503_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M603_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M603_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E4LIGHT_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M205_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M205_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M505_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M505_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_M515_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M515_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L203_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L203_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L303_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L303_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14DI_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L403_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L403_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION, NEURONSPI_BOARD_E14ROU14RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L503_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L503_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION,  NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION, NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L513_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L513_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L205_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L205_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION, NEURONSPI_BOARD_E16DIU14RO_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L505_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L505_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_DEFINITION, NEURONSPI_BOARD_E14ROU14DI_HW_DEFINITION
+};
+
+struct neuronspi_board_combination NEURONSPI_MODEL_L533_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L533_HW_DEFINITION_BOARD_SIZE] = {
+		NEURONSPI_BOARD_B1000_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION, NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_DEFINITION
+};
+
+// Board table
+// Column 4 is the number of 0-indexed registers and column 5 is the number of 1000-indexed ones
+struct neuronspi_board_entry NEURONSPI_BOARDTABLE[NEURONSPI_BOARDTABLE_LEN] = {
+	{.index = 0, .lower_board_id = NEURONSPI_BOARD_LOWER_B1000_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 21,	.config_register_count = 32, .definition = NEURONSPI_BOARD_B1000_HW_COMBINATION}, 	// B_1000 (S103)
+	{.index = 1, .lower_board_id = NEURONSPI_BOARD_LOWER_E8DI8RO_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 19,	.config_register_count = 21, .definition = NEURONSPI_BOARD_E8DI8RO_HW_COMBINATION},	// E-8Di8Ro (M103)
+	{.index = 2, .lower_board_id = NEURONSPI_BOARD_LOWER_E14RO_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 1,	.config_register_count = 0,  .definition = NEURONSPI_BOARD_E14RO_HW_COMBINATION},		// E-14Ro
+	{.index = 3, .lower_board_id = NEURONSPI_BOARD_LOWER_E16DI_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 1,	.config_register_count = 0,	 .definition = NEURONSPI_BOARD_E16DI_HW_COMBINATION},		// E-16Di
+	{.index = 4, .lower_board_id = NEURONSPI_BOARD_LOWER_E8DI8RO_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_P11DIR485_ID,
+			.data_register_count = 36,	.config_register_count = 31,  .definition = NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_COMBINATION},	// E-8Di8Ro_P-11DiR485 (xS10)
+	{.index = 5, .lower_board_id = NEURONSPI_BOARD_LOWER_E14RO_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_P11DIR485_ID,
+			.data_register_count = 20,	.config_register_count = 23,  .definition = NEURONSPI_BOARD_E14ROP11DIR485_HW_COMBINATION},	// E-14Ro_P-11DiR485 (xS40)
+	{.index = 6, .lower_board_id = NEURONSPI_BOARD_LOWER_E16DI_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_P11DIR485_ID,
+			.data_register_count = 52,	.config_register_count = 36,  .definition = NEURONSPI_BOARD_E16DIP11DIR485_HW_COMBINATION},	// E-16Di_P-11DiR485 (xS30)
+	{.index = 7, .lower_board_id = NEURONSPI_BOARD_LOWER_E14RO_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_U14RO_ID,
+			.data_register_count = 3,	.config_register_count = 10,  .definition = NEURONSPI_BOARD_E14ROU14RO_HW_COMBINATION},	// E-14Ro_U-14Ro (M403)
+	{.index = 8, .lower_board_id = NEURONSPI_BOARD_LOWER_E16DI_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_U14RO_ID,
+			.data_register_count = 35,	.config_register_count = 29,  .definition = NEURONSPI_BOARD_E16DIU14RO_HW_COMBINATION},	// E-16Di_U-14Ro (M203)
+	{.index = 9, .lower_board_id = NEURONSPI_BOARD_LOWER_E14RO_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_U14DI_ID,
+			.data_register_count = 31,	.config_register_count = 27,  .definition = NEURONSPI_BOARD_E14ROU14DI_HW_COMBINATION},	// E-14Ro_U-14Di (L503)
+	{.index = 10, .lower_board_id = NEURONSPI_BOARD_LOWER_E16DI_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_U14DI_ID,
+			.data_register_count = 63, .config_register_count = 40,   .definition = NEURONSPI_BOARD_E16DIU14DI_HW_COMBINATION},	// E-16Di_U-14Di (M303)
+	{.index = 11, .lower_board_id = NEURONSPI_BOARD_LOWER_E4AI4AO_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 1,	.config_register_count = 0,   .definition = NEURONSPI_BOARD_E4AI4AO_HW_COMBINATION},		// E-4Ai4Ao
+	{.index = 12, .lower_board_id = NEURONSPI_BOARD_LOWER_E4AI4AO_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_P6DI5RO_ID,
+			.data_register_count = 27, .config_register_count = 25,	  .definition = NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_COMBINATION},	// E-4Ai4Ao_P-6Di5Ro (xS50)
+	{.index = 13, .lower_board_id = NEURONSPI_BOARD_LOWER_B485_ID,		.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 1,  .config_register_count = 0,	  .definition = NEURONSPI_BOARD_B485_HW_COMBINATION},		// B-485
+	{.index = 14, .lower_board_id = NEURONSPI_BOARD_LOWER_E4LIGHT_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 21, .config_register_count = 8,    .definition = NEURONSPI_BOARD_E4LIGHT_HW_COMBINATION},		// E-4Light (M603)
+	{.index = 15, .lower_board_id = NEURONSPI_BOARD_LOWER_E4AI4AO_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_U6DI5RO_ID,
+			.data_register_count = 28, .config_register_count = 24,   .definition = NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_COMBINATION},		// E-4Ai4Ao_U-6Di5Ro (M503)
+	{.index = 18, .lower_board_id = NEURONSPI_BOARD_LOWER_E4AI4AO_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_P4DI5RO_ID,
+			.data_register_count = 23, .config_register_count = 23,   .definition = NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_COMBINATION},		// E-4Ai4Ao_P-4Di5Ro (xS5x)
+	{.index = 19, .lower_board_id = NEURONSPI_BOARD_LOWER_E4AI4AO_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_U4DI5RO_ID,
+			.data_register_count = 24, .config_register_count = 22,   .definition = NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_COMBINATION},		// E-4Ai4Ao_U-4Di5Ro (M5x3)
+	{.index = 25, .lower_board_id = IRIS_BOARD_ICDIS4_ID,	.upper_board_id = NEURONSPI_BOARD_UPPER_NONE_ID,
+			.data_register_count = 10, .config_register_count = 14,   .definition = IRIS_BOARD_ICDIS4_HW_COMBINATION}		// E-4Ai4Ao_U-4Di5Ro (M5x3)
+
+
+};
+
+// Module table
+struct neuronspi_model_definition NEURONSPI_MODELTABLE[NEURONSPI_MODELTABLE_LEN] = {
+		{.eeprom_length = 4, .eeprom_name = "S103", .name_length = 11, .model_name = "Neuron S103", .first_cs = 1,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S103_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S103", .name_length = 13, .model_name = "Neuron S103-G", .first_cs = 1,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S103G_HW_DEFINITION_BOARD},
+		{.eeprom_length = 6, .eeprom_name = "S103IQ", .name_length = 16, .model_name = "Neuron S103-IQRF", .first_cs = 1,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S103IQ_HW_DEFINITION_BOARD},
+		{.eeprom_length = 6, .eeprom_name = "S103EO", .name_length = 7, .model_name = "Neuron HOUM Enocean S103", .first_cs = 1,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S103EO_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S105", .name_length = 9, .model_name = "Axon S105", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S105_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S115", .name_length = 9, .model_name = "Axon S115", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S115_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S155", .name_length = 9, .model_name = "Axon S155", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S155_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S205", .name_length = 9, .model_name = "Axon S205", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S205_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S215", .name_length = 9, .model_name = "Axon S215", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S215_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S505", .name_length = 9, .model_name = "Axon S505", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S505_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S515", .name_length = 9, .model_name = "Axon S515", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S515_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "S605", .name_length = 9, .model_name = "Axon S605", .first_cs = 0,
+				.combination_count = 1, .combinations = NEURONSPI_MODEL_S605_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M103", .name_length = 11, .model_name = "Neuron M103", .first_cs = 1,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M103_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M203", .name_length = 11, .model_name = "Neuron M203", .first_cs = 1,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M203_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M303", .name_length = 11, .model_name = "Neuron M303", .first_cs = 1,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M303_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M403", .name_length = 11, .model_name = "Neuron M403", .first_cs = 1,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M403_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M503", .name_length = 11, .model_name = "Neuron M503", .first_cs = 1,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M503_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M603", .name_length = 11, .model_name = "Neuron M603", .first_cs = 1,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M603_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M205", .name_length = 9, .model_name = "Axon M205", .first_cs = 0,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M205_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M505", .name_length = 9, .model_name = "Axon M505", .first_cs = 0,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M505_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "M515", .name_length = 11, .model_name = "Neuron M515", .first_cs = 1,
+				.combination_count = 2, .combinations = NEURONSPI_MODEL_M515_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L203", .name_length = 11, .model_name = "Neuron L203", .first_cs = 1,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L203_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L303", .name_length = 11, .model_name = "Neuron L303", .first_cs = 1,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L303_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L403", .name_length = 11, .model_name = "Neuron L403", .first_cs = 1,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L403_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L503", .name_length = 11, .model_name = "Neuron L503", .first_cs = 1,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L503_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L513", .name_length = 11, .model_name = "Neuron L513", .first_cs = 1,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L513_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L205", .name_length = 9, .model_name = "Axon L205", .first_cs = 0,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L205_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L505", .name_length = 9, .model_name = "Axon L503", .first_cs = 0,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L505_HW_DEFINITION_BOARD},
+		{.eeprom_length = 4, .eeprom_name = "L533", .name_length = 11, .model_name = "Neuron L533", .first_cs = 1,
+				.combination_count = 3, .combinations = NEURONSPI_MODEL_L533_HW_DEFINITION_BOARD}
+};
+
+/************************
+ * Non-static Functions *
+ ************************/
+
+s32 neuronspi_regmap_invalidate(void *data)
+{
+	int i;
+	u32 reading_freq;
+	int freq_cnt = 0;
+	while (!kthread_should_stop()) {
+		if (unipi_use_custom_speed) {
+			mutex_lock(&unipi_inv_speed_mutex);
+			reading_freq = unipi_custom_speed_value;
+			mutex_unlock(&unipi_inv_speed_mutex);
+			// TODO: This could be moved to sysfs.c so it does not have to be evaluated so often
+			usleep_range((1000000 / (reading_freq * 4)) * 3, (1000000 / (reading_freq * 4)) * 5);
+		} else {
+			usleep_range(15000,25000);
+		}
+		if (freq_cnt == 450001) freq_cnt = 0;
+		for (i = 0; i < NEURONSPI_MAX_DEVS; i++) {
+			if (neuronspi_s_dev[i] != NULL) {
+				struct neuronspi_driver_data *d_data = spi_get_drvdata(neuronspi_s_dev[i]);
+				if ((d_data->combination_id == 0xFF) || (d_data->reg_map == NULL)) {
+					continue;
+				}
+				neuronspi_regmap_invalidate_device(d_data->reg_map, NEURONSPI_BOARDTABLE[d_data->combination_id].definition, freq_cnt);
+			}
+		}
+		freq_cnt++;
+	}
+	return 0;
+}
+
+void neuronspi_regmap_invalidate_device(struct regmap *reg_map, struct neuronspi_board_combination *device_def, u32 period_counter)
+{
+	int block_start, block_len, block_counter, current_period, period_len;
+	int i;
+	block_start = -1;
+	block_len = -1;
+	block_counter = 0;
+	period_len = 1;
+
+	for (i = 0; i < device_def->block_count; i++) {
+		if (block_start == -1) {
+			block_start = device_def->blocks[i];
+			block_counter = 0;
+		} else if (block_len == -1) {
+			block_len = device_def->blocks[i];
+		} else if ((block_counter != block_len)) {
+			current_period = device_def->blocks[i] & 0x00FF0000;
+			if ((block_counter + 1 != block_len) && ((device_def->blocks[i + 1] & 0x00FF0000) == current_period)) {
+				period_len++;
+			} else {
+				switch (current_period) {
+				case NEURONSPI_REGFLAG_ACC_AFAP: {
+					if (regcache_drop_region(reg_map, block_start + block_counter - period_len + 1, block_start + block_counter)) {
+#if NEURONSPI_DETAILED_DEBUG > 0
+						printk(KERN_INFO "UNIPISPI: RegCache dropping failed");
+#endif
+					}
+					break;
+				}
+				case NEURONSPI_REGFLAG_ACC_10HZ: {
+					if ((period_counter) % 5) {
+						regcache_drop_region(reg_map, block_start + block_counter - period_len + 1, block_start + block_counter);
+					}
+					break;
+				}
+				case NEURONSPI_REGFLAG_ACC_1HZ: {
+					if ((period_counter % 50) == 0) {
+						regcache_drop_region(reg_map, block_start + block_counter - period_len + 1, block_start + block_counter);
+					}
+					break;
+				}
+				case NEURONSPI_REGFLAG_ACC_6SEC: {
+					if ((period_counter % 300) == 0) {
+						regcache_drop_region(reg_map, block_start + block_counter - period_len + 1, block_start + block_counter);
+					}
+					break;
+				}
+				case NEURONSPI_REGFLAG_ACC_1MIN: {
+					if ((period_counter % 3000) == 0) {
+						regcache_drop_region(reg_map, block_start + block_counter - period_len + 1, block_start + block_counter);
+					}
+					break;
+				}
+				case NEURONSPI_REGFLAG_ACC_15MIN: {
+					if ((period_counter % 45000) == 0) {
+						regcache_drop_region(reg_map, block_start + block_counter - period_len + 1, block_start + block_counter);
+					}
+					break;
+				}
+				default:
+					break;
+				}
+				period_len = 1;
+			}
+			block_counter++;
+		}
+		if (block_counter == block_len) {
+			block_counter = 0;
+			block_start = -1;
+			block_len = -1;
+		}
+	}
+}
+
+int neuronspi_regmap_hw_reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct spi_device *spi = context;
+
+    u16 value;
+    if (unipispi_modbus_read_register(spi, reg, &value) == 0) {
+        *val = value;
+    } else {
+        *val = 0;
+    }
+/*
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u8 *inp_buf;
+	u8 *outp_buf;
+	int write_length, i;
+	write_length = neuronspi_spi_compose_single_register_read(reg, &inp_buf, &outp_buf);
+	if (neuronspi___spi_send_message(spi, inp_buf, outp_buf, write_length, n_spi->ideal_frequency, 25, 1, 0)) {
+		for (i = 0; i < write_length; i++) {
+			outp_buf[i] = 0;
+		}
+	}
+	memcpy(val, &outp_buf[NEURONSPI_HEADER_LENGTH], sizeof(u16));
+	kfree(inp_buf);
+	kfree(outp_buf);
+*/
+	return 0;
+}
+
+int neuronspi_regmap_hw_write(void *context, const void *data, size_t count)
+{
+	BUG_ON(count < 2);
+	//return neuronspi_regmap_hw_gather_write(context, data, 1, data + 1, count - 1);
+	return neuronspi_regmap_hw_gather_write(context, data, sizeof(u16), data + sizeof(u16), count - sizeof(u16));
+}
+
+int neuronspi_regmap_hw_reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct spi_device *spi = context;
+
+    if (unipispi_modbus_write_register(spi, reg, val) == 0) {
+        return 0;
+    }
+    return 0; // ???
+/*
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u8 *inp_buf;
+	u8 *outp_buf;
+	int write_length, i;
+	write_length = neuronspi_spi_compose_single_register_write(reg, &inp_buf, &outp_buf, (val >> 8));
+	if (neuronspi___spi_send_message(spi, inp_buf, outp_buf, write_length, n_spi->ideal_frequency, 25, 1, 0)) {
+		memcpy(&val, &outp_buf[NEURONSPI_HEADER_LENGTH], sizeof(u16));
+		for (i = 0; i < write_length; i++) {
+			outp_buf[i] = 0;
+		}
+	}
+	kfree(inp_buf);
+	kfree(outp_buf);
+	return 0;
+*/
+}
+
+int neuronspi_regmap_hw_gather_write(void *context, const void *reg, size_t reg_size, const void *val, size_t val_size)
+{
+	u16 *mb_reg_buf = (u16*)reg;
+	//u16 *mb_val_buf = (u16*)val;
+	struct spi_device *spi = context;
+#if NEURONSPI_DETAILED_DEBUG > 0
+	printk(KERN_INFO "UNIPISPI: Regmap_hw_gather_write reg[%d](%zu) val(%zu):%8ph\n", *mb_reg_buf, reg_size, val_size, val);
+#endif
+	if (reg_size == sizeof(u16)) {
+		return unipispi_modbus_write_register(spi, mb_reg_buf[0], *((u16*)val));
+	}
+	if (reg_size == sizeof(u32)) {
+		return unipispi_modbus_write_u32(spi, mb_reg_buf[0], *((u32*)val));
+	}
+
+    if (val_size & 1) return 0; // val_size must be even (u16)
+    return unipispi_modbus_write_many(spi, mb_reg_buf[0], (u16*)val, val_size / sizeof(u16));
+
+/*
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	u8 *inp_buf;
+	u8 *outp_buf;
+	int i, write_length;
+	int block_counter = 0;
+ {
+		for (i = 0; i < reg_size; i++) {
+			// Swap endianness
+			//cpu_to_be16s((u16*)&(mb_val_buf[i]));
+			// Check for continuity and read the largest possible continuous block
+			if (block_counter == (reg_size - 1) || ((mb_reg_buf[i] + 1) != mb_reg_buf[i + 1]))  {
+				write_length = neuronspi_spi_compose_multiple_register_write(block_counter, mb_reg_buf[i - block_counter], &inp_buf, &outp_buf,
+						                                                     (u8*)(&mb_val_buf[i - block_counter]));
+				neuronspi___spi_send_message(spi, inp_buf, outp_buf, write_length, n_spi->ideal_frequency, 125, 1, 0);
+				block_counter = 0;
+				kfree(inp_buf);
+				kfree(outp_buf);
+			} else {
+				block_counter++;
+			}
+		}
+	}
+	return 0;*/
+}
+
+int neuronspi_create_reg_starts(struct neuronspi_board_regstart_table *out_table, struct neuronspi_board_combination *board) {
+	if (board->features.di_count > 0) {
+		out_table->di_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DI_READ);
+		out_table->di_counter_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DI_COUNTER_LOWER);
+		out_table->di_deboun_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DI_DEBOUNCE);
+		out_table->di_direct_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DS_ENABLE);
+		out_table->di_polar_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DS_POLARITY);
+		out_table->di_toggle_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DS_TOGGLE);
+	}
+	if (board->features.do_count > 0) {
+		out_table->do_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DO_RW);
+		out_table->do_pwm_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_PWM_DUTY);
+		out_table->do_pwm_c_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_PWM_CYCLE);
+		out_table->do_pwm_ps_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_PWM_PRESCALE);
+	}
+	if (board->features.led_count > 0) {
+		out_table->led_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_LED_RW);
+	}
+	if (board->features.sysled_count > 0) {
+		out_table->sysled_val_reg = NEURONSPI_SYSLED_REGISTER;
+	}
+	if (board->features.light_count > 0) {
+		// TODO: Fill in light bus registers
+	}
+	if (board->features.ro_count > 0) {
+		out_table->ro_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_DO_RW);
+	}
+	if (board->features.sec_ai_count > 0) {
+		out_table->sec_ai_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_VER2_READ_LOWER);
+		out_table->sec_ai_mode_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_VER2_MODE);
+	}
+	if (board->features.sec_ao_count > 0) {
+		out_table->sec_ao_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AO_VER2_RW);
+	}
+	if (board->features.stm_ao_count > 0) {
+		out_table->stm_ao_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AO_BRAIN);
+		out_table->stm_ao_mode_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AO_BRAIN_MODE);
+		out_table->stm_ao_vol_err = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AO_BRAIN_V_ERR);
+		out_table->stm_ao_vol_off = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AO_BRAIN_V_OFF);
+		out_table->stm_ao_curr_err = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AO_BRAIN_I_ERR);
+		out_table->stm_ao_curr_off = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AO_BRAIN_I_OFF);
+	}
+	if (board->features.stm_ai_count > 0) {
+		out_table->stm_ai_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_BRAIN);
+		out_table->stm_ai_mode_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_BRAIN_MODE);
+		out_table->stm_ai_vol_err = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_BRAIN_V_ERR);
+		out_table->stm_ai_vol_off = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_BRAIN_V_OFF);
+		out_table->stm_ai_curr_err = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_BRAIN_I_ERR);
+		out_table->stm_ai_curr_off = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AI_BRAIN_I_OFF);
+		out_table->stm_aio_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AIO_BRAIN);
+		out_table->stm_aio_vol_err = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AIO_BRAIN_ERR);
+		out_table->stm_aio_vol_off = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_AIO_BRAIN_OFF);
+		out_table->vref_inp = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_V_REF_INP);
+	}
+	out_table->uart_queue_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_TX_QUEUE_LEN);
+	out_table->uart_conf_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_RS485_CONFIG);
+	out_table->vref_int = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_V_REF_INT);
+	out_table->wd_timeout_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_MWD_TO);
+	out_table->wd_val_reg = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_MWD_STATUS);
+	out_table->sys_serial_num = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_SERIAL_NR_LOWER);
+	out_table->sys_sw_ver = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_SW_VER);
+	out_table->sys_hw_ver = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_HW_VER);
+	out_table->sys_hw_flash_ver = neuronspi_find_reg_start(board, NEURONSPI_REGFUN_FLASH_HW_VER);
+	return 0;
+}
+
+s32 neuronspi_find_reg_start(struct neuronspi_board_combination *board, u16 regfun) {
+	int i;
+	int block_start = -1;
+	int block_len = -1;
+	int block_counter = 0;
+	for (i = 0; i < board->block_count; i++) {
+		if (block_start == -1) {
+			block_start = board->blocks[i];
+		} else if (block_len == -1) {
+			block_len = board->blocks[i];
+		} else if ((board->blocks[i] & 0xFFFF) == regfun) {
+			return block_start + block_counter;
+		} else {
+			block_counter++;
+		}
+		if (block_counter == block_len) {
+			block_counter = 0;
+			block_start = -1;
+			block_len = -1;
+		}
+	}
+	return 0;
+}
+
+int neuronspi_regmap_hw_read(void *context, const void *reg_buf, size_t reg_size, void *val_buf, size_t val_size) {
+	const u16 *mb_reg_buf = reg_buf;
+	//u16 *mb_val_buf = val_buf;
+	struct spi_device *spi = context;
+	if (context == NULL) {
+		return 0;
+	}
+
+#if NEURONSPI_DETAILED_DEBUG > 0
+	printk(KERN_INFO "UNIPISPI: Regmap_hw_read reg[%d](%zuB) val(%zuB):%8ph\n", *mb_reg_buf, reg_size, val_size, val_buf);
+#endif
+
+    if (val_size == sizeof(u16)) {
+        return unipispi_modbus_read_register(spi, *mb_reg_buf, (u16*) val_buf);
+    }
+    if (val_size == sizeof(u32)) {
+        return unipispi_modbus_read_u32(spi, *mb_reg_buf, (u32*) val_buf);
+    }
+
+    if (val_size & 1) return 0; // val_size must be even (u16)
+
+    return unipispi_modbus_read_many(spi, *mb_reg_buf, (u16*) val_buf, val_size / (sizeof(u16)));
+
+/*
+	struct neuronspi_driver_data *n_spi;
+	u8 *inp_buf;
+	u8 *outp_buf;
+	int i, j, write_length;
+	int block_counter = 0;
+    n_spi = spi_get_drvdata(spi);
+	if (n_spi == NULL) {
+		return 0;
+	}
+	for (i = 0; i < (reg_size / 2); i++) {
+		// Check for continuity and read the largest possible continuous block
+		if (block_counter == ((reg_size / 2) - 1) || ((mb_reg_buf[i] + 1) != mb_reg_buf[i + 1])) {
+			write_length = neuronspi_spi_compose_multiple_register_read(block_counter + 1, mb_reg_buf[i - block_counter], &inp_buf, &outp_buf);
+			if (neuronspi___spi_send_message(spi, inp_buf, outp_buf, write_length, n_spi->ideal_frequency, 125, 1, 0)) {
+				for (j = 0; j < write_length; j++) {
+					outp_buf[j] = 0;
+				}
+			}
+			memcpy(&mb_val_buf[i - block_counter], &outp_buf[NEURONSPI_HEADER_LENGTH], (block_counter + 1) * 2);
+			kfree(inp_buf);
+			kfree(outp_buf);
+			block_counter = 0;
+		} else {
+			block_counter++;
+		}
+	}
+	return 0; */
+}
+
+s32 neuronspi_find_model_id(u32 probe_count)
+{
+	struct neuronspi_driver_data *n_spi;
+	int i,j, ret = -1;
+    int chip_select;
+	u8 *inv = kzalloc(sizeof(*inv) * NEURONSPI_MODELTABLE_LEN, GFP_ATOMIC);
+
+	if (neuronspi_s_dev[0]) {
+        chip_select = neuronspi_s_dev[0]->chip_select;
+        for (j = 0; j < NEURONSPI_MODELTABLE_LEN; j++) {
+            if (NEURONSPI_MODELTABLE[j].first_cs != chip_select) {
+				inv[j] = 1;
+            }
+        }
+    }
+
+	for (i = 0; i < probe_count; i++) {
+		if (neuronspi_s_dev[i]) {
+			n_spi = spi_get_drvdata(neuronspi_s_dev[i]);
+			for (j = 0; j < NEURONSPI_MODELTABLE_LEN; j++) {
+				if (i + 1 > NEURONSPI_MODELTABLE[j].combination_count) {
+					inv[j] = 1;
+				} else if (NEURONSPI_MODELTABLE[j].combinations[i].combination_board_id != n_spi->combination_id) {
+					inv[j] = 1;
+                }
+			}
+		} else {
+			for (j = 0; j < NEURONSPI_MODELTABLE_LEN; j++) {
+				if (i + 1 < NEURONSPI_MODELTABLE[j].combination_count) {
+					inv[j] = 1;
+				}
+			}
+		}
+	}
+	for (i = 0; i < NEURONSPI_MODELTABLE_LEN; i++) {
+		if (inv[i] != 1) {
+			ret = i;
+			break;
+		}
+	}
+	kfree(inv);
+	return ret;
+}
+
+
+
+void neuronspi_board_device_remove(struct platform_device * board_device)
+{
+    struct neuronspi_board_device_data *board_data = platform_get_drvdata(board_device);
+    struct neuronspi_driver_data *n_spi = board_data->n_spi;
+    int i;
+
+    if (board_data->led_driver) {
+        for (i = 0; i < n_spi->features->led_count; i++) {
+            led_classdev_unregister(&(board_data->led_driver[i].ldev));
+            kthread_flush_work(&(board_data->led_driver[i].led_work));
+        }
+        kfree(board_data->led_driver);
+        board_data->led_driver = NULL;
+        //unipi_spi_trace(KERN_INFO "UNIPISPI: LED Driver unregistered\n");
+    }
+    if (board_data->di_driver) { neuronspi_gpio_remove(board_data->di_driver); }
+    if (board_data->do_driver) { neuronspi_gpio_remove(board_data->do_driver); }
+    if (board_data->ro_driver) { neuronspi_gpio_remove(board_data->ro_driver); }
+    //unipi_spi_trace(KERN_INFO "UNIPISPI: GPIO Driver unregistered\n");
+
+    if (board_data->stm_ai_driver) { iio_device_unregister(board_data->stm_ai_driver); }
+    if (board_data->stm_ao_driver) {	iio_device_unregister(board_data->stm_ao_driver); }
+    if (board_data->sec_ai_driver) {
+        for (i = 0; i < n_spi->features->sec_ai_count; i++) {
+            iio_device_unregister(board_data->sec_ai_driver[i]);
+        }
+        kfree(board_data->sec_ai_driver);
+        board_data->sec_ai_driver = NULL;
+    }
+    if (board_data->sec_ao_driver) {
+        for (i = 0; i < n_spi->features->sec_ao_count; i++) {
+            iio_device_unregister(board_data->sec_ao_driver[i]);
+        }
+        kfree(board_data->sec_ao_driver);
+        board_data->sec_ao_driver = NULL;
+    }
+    //unipi_spi_trace(KERN_INFO "UNIPISPI: IIO Driver unregistered\n");
+
+
+    platform_set_drvdata(board_device, 0);
+    kfree(board_data);
+    platform_device_unregister(board_device);
+
+}
+
+
+struct platform_device * neuronspi_board_device_probe(struct neuronspi_driver_data *n_spi)
+{
+    char buf[20];
+    struct platform_device * board_device;
+    struct neuronspi_board_device_data *board_data;
+
+    scnprintf(buf, 20, "io_group%d", n_spi->neuron_index+1);
+    board_data = kzalloc(sizeof(struct neuronspi_board_device_data), GFP_ATOMIC);
+
+
+	board_device = platform_device_alloc(buf, -1);
+	board_device->dev.parent = &(neuron_plc_dev->dev);
+
+	if (n_spi->combination_id != 0xFF) {
+		board_device->dev.groups = neuron_board_attr_groups;
+	}
+
+	board_device->dev.driver = &neuronspi_spi_driver.driver;
+
+    board_data->n_spi = n_spi;
+	platform_device_add(board_device);
+	platform_set_drvdata(board_device, board_data);
+
+	if (n_spi->features) {
+		if ((n_spi->features->led_count>0) || (n_spi->features->sysled_count>0)) {
+			if (n_spi->features->led_count) printk(KERN_INFO "UNIPISPI: %d User LEDs detected at nspi%d\n", n_spi->features->led_count, n_spi->neuron_index);
+			if (n_spi->features->sysled_count) printk(KERN_INFO "UNIPISPI: %d System LEDs detected at nspi%d\n", n_spi->features->sysled_count, n_spi->neuron_index);
+			board_data->led_driver = neuronspi_led_probe(n_spi->features->led_count, n_spi->features->sysled_count, n_spi->neuron_index, board_device);
+		}
+#ifdef CONFIG_GPIOLIB
+		if (n_spi->features->di_count) {
+			board_data->di_driver = neuronspi_di_probe(n_spi->features->di_count, n_spi->neuron_index, board_device);
+		}
+		if (n_spi->features->do_count) {
+			board_data->do_driver = neuronspi_do_probe(n_spi->features->do_count, n_spi->neuron_index, board_device);
+		}
+
+		if (n_spi->features->ro_count) {
+			board_data->ro_driver = neuronspi_ro_probe(n_spi->features->ro_count, n_spi->neuron_index, board_device);
+		}
+#endif
+		if (n_spi->features->stm_ai_count) {
+			board_data->stm_ai_driver = neuronspi_stm_ai_probe(n_spi->features->stm_ai_count, n_spi->neuron_index, board_device);
+		}
+		if (n_spi->features->stm_ao_count) {
+			board_data->stm_ao_driver = neuronspi_stm_ao_probe(n_spi->features->stm_ao_count, n_spi->neuron_index, board_device);
+		}
+		if (n_spi->features->sec_ai_count) {
+			board_data->sec_ai_driver = neuronspi_sec_ai_probe(n_spi->features->sec_ai_count, n_spi->neuron_index, board_device);
+		}
+		if (n_spi->features->sec_ao_count) {
+			board_data->sec_ao_driver = neuronspi_sec_ao_probe(n_spi->features->sec_ao_count, n_spi->neuron_index, board_device);
+		}
+	}
+    return board_device;
+}
+
diff --git a/drivers/unipi/unipi_platform.h b/drivers/unipi/unipi_platform.h
new file mode 100644
index 000000000000..fe298fc85753
--- /dev/null
+++ b/drivers/unipi/unipi_platform.h
@@ -0,0 +1,394 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_PLATFORM_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_PLATFORM_H_
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_common.h"
+#include "unipi_gpio.h"
+#include "unipi_misc.h"
+#include "unipi_iio.h"
+
+/*******************
+ * Data Structures *
+ *******************/
+
+struct neuronspi_board_entry {
+	u16		index;
+	u16		lower_board_id;
+	u16		upper_board_id;
+	u16		data_register_count;
+	u16		config_register_count;
+	struct neuronspi_board_combination *definition;
+};
+
+struct neuronspi_register_block
+{
+	u32 	starting_register;
+	u32 	register_count;
+	u32		*register_flags;
+};
+
+struct neuronspi_board_features
+{
+	u32		do_count;
+	u32		ro_count;
+	u32		ds_count;
+	u32		di_count;
+	u32		led_count;
+	u32		stm_ai_count;
+	u32		stm_ao_count;
+	u32		sec_ai_count;
+	u32		sec_ao_count;
+	u32		uart_master_count;
+	u32		uart_slave_count;
+	u32		pwm_channel_count;
+	u32		wd_count;
+	u32		extension_sys_count;
+	u32		light_count;
+	u32		owire_count;
+	u32		sysled_count;
+};
+
+struct neuronspi_board_regstart_table
+{
+	u32		do_val_reg;
+	u32		do_val_coil;
+	u32		do_pwm_reg;
+	u32		do_pwm_ps_reg;
+	u32		do_pwm_c_reg;
+	u32		di_val_reg;
+	u32		di_counter_reg;
+	u32		di_direct_reg;
+	u32		di_deboun_reg;
+	u32		di_polar_reg;
+	u32		di_toggle_reg;
+	u32		uart_queue_reg;
+	u32		uart_conf_reg;
+	u32		uart_address_reg;
+	u32		led_val_coil;
+	u32		led_val_reg;
+	u32		wd_val_reg;
+	u32		wd_timeout_reg;
+	u32		wd_nv_sav_coil;
+	u32		wd_reset_coil;
+	u32		reg_start_reg;
+	u32		ro_val_reg;
+	u32		ro_val_coil;
+	u32		vref_inp;
+	u32		vref_int;
+	u32		stm_ao_val_reg;
+	u32		stm_ao_mode_reg;
+	u32		stm_ao_vol_err;
+	u32		stm_ao_vol_off;
+	u32		stm_ao_curr_err;
+	u32		stm_ao_curr_off;
+	u32		stm_ai_val_reg;
+	u32		stm_ai_mode_reg;
+	u32		stm_ai_curr_err;
+	u32		stm_ai_curr_off;
+	u32		stm_ai_vol_err;
+	u32		stm_ai_vol_off;
+	u32		stm_aio_val_reg;
+	u32		stm_aio_vol_err;
+	u32		stm_aio_vol_off;
+	u32		sec_ao_val_reg;
+	u32		sec_ao_mode_reg;
+	u32		sec_ai_val_reg;
+	u32		sec_ai_mode_reg;
+	u32		sys_serial_num;
+	u32		sys_hw_ver;
+	u32		sys_hw_flash_ver;
+	u32		sys_sw_ver;
+	u32		sysled_val_coil;
+	u32		sysled_val_reg;
+};
+
+struct neuronspi_board_combination
+{
+	u32									combination_board_id;
+	u16									lower_board_id;
+	u16									upper_board_id;
+	u32 								block_count;
+	size_t								name_length;
+	const char*							combination_name;
+	struct neuronspi_board_features		features;
+	u32					 			 	*blocks;
+};
+
+struct neuronspi_model_definition
+{
+	size_t								eeprom_length;
+	const char* 						eeprom_name;
+	size_t								name_length;
+	const char*							model_name;
+	u32									combination_count;
+	struct neuronspi_board_combination 	*combinations;
+    u32                                 first_cs;
+};
+
+struct neuronspi_board_device_data {
+    struct neuronspi_driver_data *n_spi;
+    struct neuronspi_led_driver *led_driver;
+	struct neuronspi_gpio_driver *di_driver;
+	struct neuronspi_gpio_driver *do_driver;
+	struct neuronspi_gpio_driver *ro_driver;
+	struct iio_dev *stm_ai_driver;
+	struct iio_dev *stm_ao_driver;
+	struct iio_dev **sec_ai_driver;
+	struct iio_dev **sec_ao_driver;
+};
+
+/***************
+ * Definitions *
+ ***************/
+
+// Lower Boards
+#define NEURONSPI_BOARD_LOWER_B1000_ID		0
+#define NEURONSPI_BOARD_LOWER_E8DI8RO_ID	1
+#define NEURONSPI_BOARD_LOWER_E14RO_ID		2
+#define NEURONSPI_BOARD_LOWER_E16DI_ID		3
+#define NEURONSPI_BOARD_LOWER_E4AI4AO_ID	11
+#define NEURONSPI_BOARD_LOWER_B485_ID		13
+#define NEURONSPI_BOARD_LOWER_E4LIGHT_ID	14
+#define IRIS_BOARD_ICDIS4_ID				25
+
+// Upper Boards
+#define NEURONSPI_BOARD_UPPER_NONE_ID		0
+#define NEURONSPI_BOARD_UPPER_P11DIR485_ID	1
+#define NEURONSPI_BOARD_UPPER_U14RO_ID		2
+#define NEURONSPI_BOARD_UPPER_U14DI_ID		3
+#define NEURONSPI_BOARD_UPPER_P6DI5RO_ID	4
+#define NEURONSPI_BOARD_UPPER_U6DI5RO_ID	5
+#define NEURONSPI_BOARD_UPPER_P4DI5RO_ID	6
+#define NEURONSPI_BOARD_UPPER_U4DI5RO_ID	7
+
+// Register function codes
+// Digital Input Functions
+#define NEURONSPI_FUNGROUP_DI			0
+#define NEURONSPI_REGFUN_DI_READ			0 | NEURONSPI_FUNGROUP_DI << 8
+#define NEURONSPI_REGFUN_DI_COUNTER_LOWER	1 | NEURONSPI_FUNGROUP_DI << 8
+#define NEURONSPI_REGFUN_DI_COUNTER_UPPER	2 | NEURONSPI_FUNGROUP_DI << 8
+#define NEURONSPI_REGFUN_DI_DEBOUNCE		3 | NEURONSPI_FUNGROUP_DI << 8
+#define NEURONSPI_REGFUN_DS_ENABLE			4 | NEURONSPI_FUNGROUP_DI << 8
+#define NEURONSPI_REGFUN_DS_POLARITY		5 | NEURONSPI_FUNGROUP_DI << 8
+#define NEURONSPI_REGFUN_DS_TOGGLE			6 | NEURONSPI_FUNGROUP_DI << 8
+
+// Digital Output Functions
+#define NEURONSPI_FUNGROUP_DO			1
+#define NEURONSPI_REGFUN_DO_RW				0 | NEURONSPI_FUNGROUP_DO << 8
+
+// B1000 Analog Output Functions
+#define NEURONSPI_FUNGROUP_AO_BRAIN		2
+#define NEURONSPI_REGFUN_AO_BRAIN			0 | NEURONSPI_FUNGROUP_AO_BRAIN << 8
+#define NEURONSPI_REGFUN_AO_BRAIN_MODE		1 | NEURONSPI_FUNGROUP_AO_BRAIN << 8
+#define NEURONSPI_REGFUN_AO_BRAIN_V_ERR		2 | NEURONSPI_FUNGROUP_AO_BRAIN << 8
+#define NEURONSPI_REGFUN_AO_BRAIN_V_OFF		3 | NEURONSPI_FUNGROUP_AO_BRAIN << 8
+#define NEURONSPI_REGFUN_AO_BRAIN_I_ERR 	4 | NEURONSPI_FUNGROUP_AO_BRAIN << 8
+#define NEURONSPI_REGFUN_AO_BRAIN_I_OFF 	5 | NEURONSPI_FUNGROUP_AO_BRAIN << 8
+
+// B1000 Analog Input Functions
+#define NEURONSPI_FUNGROUP_AI_BRAIN		3
+#define NEURONSPI_REGFUN_AI_BRAIN			0 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AIO_BRAIN			1 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AI_BRAIN_MODE		2 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AI_BRAIN_V_ERR		3 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AI_BRAIN_V_OFF		4 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AI_BRAIN_I_ERR		5 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AI_BRAIN_I_OFF		6 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AIO_BRAIN_ERR		7 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+#define NEURONSPI_REGFUN_AIO_BRAIN_OFF		8 | NEURONSPI_FUNGROUP_AI_BRAIN << 8
+
+// System Functions
+#define NEURONSPI_FUNGROUP_SYSTEM		4
+#define NEURONSPI_REGFUN_V_REF_INT			0 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_V_REF_INP			1 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_LED_RW				2 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_SW_VER 			3 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_DIDO_COUNT			4 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_UAIO_COUNT			5 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_HW_VER				6 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_FLASH_HW_VER 		7 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_SERIAL_NR_LOWER	8 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_SERIAL_NR_UPPER	9 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_INTERRUPTS			10 | NEURONSPI_FUNGROUP_SYSTEM << 8
+#define NEURONSPI_REGFUN_NONE_TEST			11 | NEURONSPI_FUNGROUP_SYSTEM << 8
+
+// Watchdog Functions
+#define NEURONSPI_FUNGROUP_MWD			5
+#define NEURONSPI_REGFUN_MWD_TO				0 | NEURONSPI_FUNGROUP_MWD << 8
+#define NEURONSPI_REGFUN_MWD_STATUS			1 | NEURONSPI_FUNGROUP_MWD << 8
+
+// PWM Functions
+#define NEURONSPI_FUNGROUP_PWM			6
+#define NEURONSPI_REGFUN_PWM_DUTY			0 | NEURONSPI_FUNGROUP_PWM << 8
+#define NEURONSPI_REGFUN_PWM_PRESCALE		1 | NEURONSPI_FUNGROUP_PWM << 8
+#define NEURONSPI_REGFUN_PWM_CYCLE			2 | NEURONSPI_FUNGROUP_PWM << 8
+
+// UART Functions
+#define NEURONSPI_FUNGROUP_RS485		7
+#define NEURONSPI_REGFUN_TX_QUEUE_LEN		0 | NEURONSPI_FUNGROUP_RS485 << 8
+#define NEURONSPI_REGFUN_RS485_CONFIG		1 | NEURONSPI_FUNGROUP_RS485 << 8
+#define NEURONSPI_REGFUN_RS485_ADDRESS		2 | NEURONSPI_FUNGROUP_RS485 << 8
+
+// Secondary Analog Output Functions
+#define NEURONSPI_FUNGROUP_AO_VER2		8
+#define NEURONSPI_REGFUN_AO_VER2_RW			0 | NEURONSPI_FUNGROUP_AO_VER2 << 8
+
+// Secondary Analog Input Functions
+#define NEURONSPI_FUNGROUP_AI_VER2		9
+#define NEURONSPI_REGFUN_AI_VER2_READ_LOWER	0 | NEURONSPI_FUNGROUP_AI_VER2 << 8
+#define NEURONSPI_REGFUN_AI_VER2_READ_UPPER	1 | NEURONSPI_FUNGROUP_AI_VER2 << 8
+#define NEURONSPI_REGFUN_AI_VER2_MODE		2 | NEURONSPI_FUNGROUP_AI_VER2 << 8
+
+// Special Functions
+#define NEURONSPI_FUNGROUP_SPECIAL		127
+#define NEURONSPI_REGFUN_SPECIAL_NULL	0 | NEURONSPI_FUNGROUP_SPECIAL << 8
+
+// Register access flags
+#define NEURONSPI_REGFLAG_ACC_NEVER	0
+#define NEURONSPI_REGFLAG_ACC_AFAP	0x1 << 16
+#define NEURONSPI_REGFLAG_ACC_10HZ 	0x2 << 16
+#define NEURONSPI_REGFLAG_ACC_1HZ   0x3 << 16
+#define NEURONSPI_REGFLAG_ACC_6SEC  0x4 << 16
+#define NEURONSPI_REGFLAG_ACC_1MIN  0x5 << 16
+#define NEURONSPI_REGFLAG_ACC_15MIN 0x6 << 16
+#define NEURONSPI_REGFLAG_ACC_ONCE 	0x7 << 16
+
+// Register system flags
+#define NEURONSPI_REGFLAG_SYS_READ_ONLY	0x10 << 24
+
+// IIO Modes
+#define NEURONSPI_IIO_AI_STM_MODE_VOLTAGE 0x0
+#define NEURONSPI_IIO_AI_STM_MODE_CURRENT 0x1
+#define NEURONSPI_IIO_AI_STM_MODE_RESISTANCE 0x3
+
+/*********************
+ * Data Declarations *
+ *********************/
+
+extern struct platform_device *neuron_plc_dev;
+
+// Board Definitions
+extern struct neuronspi_board_combination NEURONSPI_BOARD_B1000_HW_COMBINATION[]; 				// B_1000 (S103)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E8DI8RO_HW_COMBINATION[]; 			// E-8Di8Ro (M103)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E14RO_HW_COMBINATION[]; 				// E-14Ro
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E16DI_HW_COMBINATION[]; 				// E-16Di
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E8DI8ROP11DIR485_HW_COMBINATION[]; 	// E-8Di8Ro_P-11DiR485 (xS10)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E14ROP11DIR485_HW_COMBINATION[]; 		// E-14Ro_P-11DiR485 (xS40)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E16DIP11DIR485_HW_COMBINATION[];		// E-16Di_P-11DiR485 (xS30)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E14ROU14RO_HW_COMBINATION[];			// E-14Ro_U-14Ro (M403)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E16DIU14RO_HW_COMBINATION[];			// E-16Di_U-14Ro (M203)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E14ROU14DI_HW_COMBINATION[];			// E-14Ro_U-14Di (L503)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E16DIU14DI_HW_COMBINATION[];			// E-16Di_U-14Di (M303)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AO_HW_COMBINATION[];				// E-4Ai4Ao
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOP6DI5RO_HW_COMBINATION[];		// E-4Ai4Ao_P-6Di5Ro (xS50)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_B485_HW_COMBINATION[];				// B-485
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E4LIGHT_HW_COMBINATION[];				// E-4Light (M613)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOU6DI5RO_HW_COMBINATION[];		// E-4Ai4Ao_U-6Di5Ro (L503)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOP4DI5RO_HW_COMBINATION[];		// E-4Ai4Ao_P-4Di5Ro (xS5?)
+extern struct neuronspi_board_combination NEURONSPI_BOARD_E4AI4AOU4DI5RO_HW_COMBINATION[];		// E-4Ai4Ao_U-4Di5Ro (L5?3)
+
+// Model Definitions
+#define NEURONSPI_MODEL_S103_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S103_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S103G_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S103G_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103G_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S103IQ_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S103IQ_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103IQ_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S103EO_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S103EO_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S103EO_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S105_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S105_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S105_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S115_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S115_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S115_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S155_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S155_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S155_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S205_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S205_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S205_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S215_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S215_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S215_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S505_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S505_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S505_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S515_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S515_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S515_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_S605_HW_DEFINITION_BOARD_SIZE 1
+extern struct neuronspi_board_combination NEURONSPI_MODEL_S605_HW_DEFINITION_BOARD[NEURONSPI_MODEL_S605_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M103_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M103_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M103_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M203_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M203_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M203_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M303_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M303_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M303_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M403_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M403_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M403_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M503_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M503_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M503_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M603_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M603_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M603_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M205_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M205_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M205_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M505_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M505_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M505_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_M515_HW_DEFINITION_BOARD_SIZE 2
+extern struct neuronspi_board_combination NEURONSPI_MODEL_M515_HW_DEFINITION_BOARD[NEURONSPI_MODEL_M515_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L203_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L203_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L203_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L303_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L303_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L303_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L403_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L403_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L403_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L503_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L503_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L503_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L513_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L513_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L513_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L205_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L205_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L205_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L505_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L505_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L505_HW_DEFINITION_BOARD_SIZE];
+#define NEURONSPI_MODEL_L533_HW_DEFINITION_BOARD_SIZE 3
+extern struct neuronspi_board_combination NEURONSPI_MODEL_L533_HW_DEFINITION_BOARD[NEURONSPI_MODEL_L533_HW_DEFINITION_BOARD_SIZE];
+
+
+// Board table
+#define NEURONSPI_BOARDTABLE_LEN		19
+extern struct neuronspi_board_entry NEURONSPI_BOARDTABLE[];
+
+// Module table
+#define NEURONSPI_MODELTABLE_LEN		29
+extern struct neuronspi_model_definition NEURONSPI_MODELTABLE[];
+
+/*************************
+ * Function Declarations *
+ *************************/
+
+int neuronspi_regmap_hw_gather_write(void *context, const void *reg, size_t reg_size, const void *val, size_t val_size);
+int neuronspi_regmap_hw_read(void *context, const void *reg_buf, size_t reg_size, void *val_buf, size_t val_size);
+int neuronspi_regmap_hw_reg_read(void *context, unsigned int reg, unsigned int *val);
+int neuronspi_regmap_hw_reg_write(void *context, unsigned int reg, unsigned int val);
+int neuronspi_regmap_hw_write(void *context, const void *data, size_t count);
+void neuronspi_regmap_invalidate_device(struct regmap *reg_map, struct neuronspi_board_combination *device_def, u32 period_counter);
+s32 neuronspi_regmap_invalidate(void *data);
+int neuronspi_create_reg_starts(struct neuronspi_board_regstart_table *out_table, struct neuronspi_board_combination *board);
+s32 neuronspi_find_reg_start(struct neuronspi_board_combination *board, u16 regfun);
+s32 neuronspi_find_model_id(u32 probe_count);
+
+struct platform_device * neuronspi_board_device_probe(struct neuronspi_driver_data *n_spi);
+void neuronspi_board_device_remove(struct platform_device * board_device);
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_PLATFORM_H_ */
diff --git a/drivers/unipi/unipi_spi.c b/drivers/unipi/unipi_spi.c
new file mode 100644
index 000000000000..a65ace3a33f3
--- /dev/null
+++ b/drivers/unipi/unipi_spi.c
@@ -0,0 +1,1639 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+/************
+ * Includes *
+ ************/
+#include <linux/completion.h>
+#include <linux/cpufreq.h>
+#include <linux/version.h>
+
+#include "unipi_common.h"
+#include "unipi_sysfs.h"
+#include "unipi_uart.h"
+#include "unipi_platform.h"
+#include "unipi_gpio.h"
+#include "unipi_iio.h"
+#include "unipi_misc.h"
+#include "unipi_spi.h"
+#include "unipi_uart.h"
+#include "unipi_tty.h"
+
+
+/* using trace_printk or printk ???*/
+
+#if NEURONSPI_DETAILED_DEBUG > 1
+# define unipi_spi_trace_1(f, args...)	printk(f, ##args)
+#else
+# define unipi_spi_trace_1(f, args...)
+#endif
+
+#if NEURONSPI_DETAILED_DEBUG > 0
+# define unipi_spi_trace(f, args...)	printk(f, ##args)
+#else
+# define unipi_spi_trace(f, args...)
+#endif
+
+#define unipi_spi_error(f, args...)	printk(f, ##args)
+
+
+/********************
+ * Data Definitions *
+ ********************/
+
+// Instantiated once
+struct neuronspi_char_driver
+{
+	int major_number;
+	u32 open_counter;
+	struct class* driver_class;
+	struct device* dev;
+};
+
+
+//struct mutex neuronspi_master_mutex;
+spinlock_t   unipi_spi_master_lock;
+struct mutex unipi_inv_speed_mutex;
+int neuronspi_model_id = -1;
+struct spi_device *neuronspi_s_dev[NEURONSPI_MAX_DEVS];  // global list of neuron spi devices
+struct task_struct *neuronspi_invalidate_thread;
+
+static u8 neuronspi_probe_count = 0;
+static struct spinlock *neuronspi_probe_spinlock;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+static struct sched_param neuronspi_sched_param = { .sched_priority = MAX_RT_PRIO / 2 };
+#endif
+
+struct neuronspi_char_driver neuronspi_cdrv =
+{
+	.major_number = -1,
+	.dev = NULL
+};
+
+struct neuronspi_file_data
+{
+	//struct spi_device** spi_device;
+	struct mutex 		lock;
+    struct neuronspi_op_buffer send_buf;
+    struct neuronspi_op_buffer recv_buf;
+	u32			        message_len;
+	u8					device_index;
+	u8					has_first_message;
+};
+
+
+#define UNIPISPI_PROBE_MESSAGE_LEN	16
+static u8 _probe_message_second[UNIPISPI_PROBE_MESSAGE_LEN] = 
+{   0x04, 0x00, 0xe8, 0x03, 
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+    0x12, 0x16
+};
+
+static struct neuronspi_op_buffer UNIPISPI_PROBE_MESSAGE = {
+    first_message: {0x04, 0x0e, 0xe8, 0x03, 0xa0, 0xdd},
+    second_message: _probe_message_second,
+};
+
+
+static struct neuronspi_op_buffer UNIPISPI_IDLE_MESSAGE = {
+    first_message: {0xfa, 0x00, 0x55, 0x0e, 0xb6, 0x0a},
+    second_message: NULL,
+};
+
+
+/************************************************************
+
+  patches to other modules
+		- chip select on spi - monitor elpapsed time between operations
+		- cpu frequency setting - try to suppress changing freq during spi op
+
+***********************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+    static unsigned long loop_per_us = 24; 
+    u16 unipi_spi_master_flag = 0;
+    void (*unipi_spi_master_set_cs)(struct spi_device *spi, bool enable) = NULL;
+    //cycles_t unipi_spi_cs_cycles;
+#ifdef USE_UNIPI_CPUFREQ_PATCH
+	static struct cpufreq_policy * current_policy = NULL;
+#endif
+
+static void unipi_spi_set_cs(struct spi_device *spi, bool enable)
+{
+    unsigned long udelta;
+    struct neuronspi_driver_data *d_data = spi_get_drvdata(spi);
+    //if ((d_data->neuron_index < NEURONSPI_MAX_DEVS) && (neuronspi_s_dev[d_data->neuron_index] == spi)) {
+    //  
+    //}
+    cycles_t cs_cycles = get_cycles();
+    if (!enable && d_data) {
+        udelta = ((cs_cycles - d_data->last_cs_cycles) / loop_per_us);
+        unipi_spi_trace(KERN_INFO "UNIPISPI: enable=%d csdelta:%ld us\n", !enable, udelta);
+        if (udelta < NEURONSPI_LAST_TRANSFER_DELAY) {
+            udelay(NEURONSPI_LAST_TRANSFER_DELAY - udelta);
+        }
+    }
+#ifdef USE_UNIPI_CPUFREQ_PATCH
+	//current_policy = cpufreq_cpu_get_raw(task_cpu(current));
+	current_policy = cpufreq_cpu_get_raw(0);
+	if (current_policy && !enable) {
+ wait:
+        wait_event(current_policy->transition_wait, !current_policy->transition_ongoing);
+        spin_lock(&current_policy->transition_lock);
+        if (unlikely(current_policy->transition_ongoing)) {
+            spin_unlock(&current_policy->transition_lock);
+            goto wait;
+        }
+
+        current_policy->transition_ongoing = true;
+        current_policy->transition_task = current;
+        spin_unlock(&current_policy->transition_lock);
+	}
+#endif
+	if (gpio_is_valid(-spi->cs_gpio)) {
+		gpio_set_value(-spi->cs_gpio, enable);
+        if ((unipi_spi_master_set_cs != NULL)  &&
+           (unipi_spi_master_flag & SPI_MASTER_GPIO_SS)) {
+            unipi_spi_master_set_cs(spi, enable);
+        }
+    } else {
+        if (unipi_spi_master_set_cs != NULL) 
+            unipi_spi_master_set_cs(spi, enable);
+    }
+    if (d_data) d_data->last_cs_cycles = cs_cycles;
+#ifdef USE_UNIPI_CPUFREQ_PATCH             
+	if (current_policy && enable) {
+        current_policy->transition_ongoing = false;
+        current_policy->transition_task = NULL;
+        wake_up(&current_policy->transition_wait);     
+	}
+#endif
+}
+
+#endif
+
+/************************
+ * Non-static Functions *
+ ************************/
+int neuronspi_spi_send_op(struct spi_device* spi_dev, struct neuronspi_op_buffer* send_buf,
+                            struct neuronspi_op_buffer* recv_buf, s32 len, 
+                            s32 freq, s32 delay, s32 send_header, u8 lock_val);
+
+int neuronspi_spi_send_const_op(struct spi_device* spi_dev, struct neuronspi_op_buffer* send_buf,
+                            struct neuronspi_op_buffer* recv_buf, s32 len, 
+                            s32 freq, s32 delay)
+{
+    return neuronspi_spi_send_op(spi_dev, send_buf, recv_buf, len, freq, delay, UNIPISPI_OP_MODE_SEND_HEADER, 0);
+}
+
+void unipi_spi_read_str(struct spi_device* spi, struct neuronspi_port* port);
+
+
+struct unipi_spi_context {
+    struct completion* unipi_spi_completion;
+    int len;
+    struct neuronspi_op_buffer* recv_buf;
+    struct neuronspi_port* string_op_port;
+    struct spi_message message;
+    //struct spi_transfer _transfer[]   
+};
+
+static struct neuronspi_port* unipi_spi_check_message(struct unipi_spi_context* context)
+{
+    struct neuronspi_op_buffer* recv_buf = context->recv_buf;
+    struct neuronspi_driver_data *d_data;// = context->d_data;
+    int len = context->len;
+    struct neuronspi_port* port = NULL;
+    u16 packet_crc, recv_crc;
+    u8 opcode;    
+    int portindex;
+    
+    d_data = spi_get_drvdata(context->message.spi);
+    
+    if (context->message.status != 0) {
+        // odeslani se nepovedlo z nejakeho duvodu
+        unipi_spi_trace(KERN_INFO "UNIPISPI: Error spi transaction: txopcode:%d\n", recv_buf->first_message[0]);
+        goto err;
+    }
+
+    unipi_spi_trace_1(KERN_INFO "UNIPISPI: SPI Master Read (op1) %8ph\n", recv_buf->first_message);
+    if (d_data && d_data->poll_enabled) {
+       // reschedule poll timer (pseudo interrupt)
+       hrtimer_start_range_ns(&d_data->poll_timer, 2000000, 4000000, HRTIMER_MODE_REL);
+    }
+    // check crc on header
+	recv_crc = neuronspi_spi_crc(recv_buf->first_message, 4, 0);
+	packet_crc = *((u16*)(recv_buf->first_message+4));
+
+	if (recv_crc != packet_crc) {
+		unipi_spi_error(KERN_INFO "UNIPISPI: SPI CRC1 Not Correct (Received: %04x Calculated: %04x)\n", packet_crc, recv_crc);
+		unipi_spi_error(KERN_INFO "UNIPISPI: part1 %4phC\n", recv_buf->first_message);
+        recv_buf->first_message[0] = 0;
+        goto err;
+    }
+    opcode = recv_buf->first_message[0];
+    if ((opcode >= 0x41)&&(opcode <= 0x44)) {
+        // Signal the UART to issue character reads
+        portindex = (opcode - 0x41);
+        if ((d_data != NULL) && d_data->uart_count && (portindex < d_data->uart_count)) {
+            unipi_spi_trace_1(KERN_INFO "UNIPISPI: Reading UART data for device %d, opcode=%02x\n", d_data->neuron_index, opcode);
+            port = neuronspi_uart_data_global->p + d_data->uart_pindex + portindex;
+            // put one incomming character from UART
+            neuronspi_uart_handle_rx(port, 1, recv_buf->first_message+3);
+            // read queue length
+            port->rx_remain = (recv_buf->first_message[2]==0  ? 256 : recv_buf->first_message[2]) - 1;
+                        
+            unipi_spi_trace(KERN_INFO "UNIPISPI: UART Buffer:%d, ttyNS%d(%d:%d)\n", port->rx_remain, port->port.line, port->dev_index, port->dev_port);
+        }
+    } else if (opcode != 0xfa) {
+        unipi_spi_trace(KERN_INFO "UNIPISPI: Err rx:%d\n",  opcode);
+        goto err;
+	}
+
+    if (len > 0) {
+        // Check second message crc
+		recv_crc = neuronspi_spi_crc(recv_buf->second_message, len, recv_crc);
+        packet_crc = recv_buf->second_message[len] | (recv_buf->second_message[len+1] << 8);
+		unipi_spi_trace_1(KERN_INFO "UNIPISPI: SPI Master Read - %d:\n\t%64ph\n\t%64ph\n\t%64ph\n\t%64ph\n", len, 
+                                        recv_buf->second_message, recv_buf->second_message + 64,
+                                        recv_buf->second_message+128, recv_buf->second_message+192);
+
+		if (recv_crc != packet_crc) {
+            unipi_spi_error(KERN_INFO "UNIPISPI: SPI CRC2 Not Correct: %04x COMPUTED: %04x\n", packet_crc, recv_crc);
+		    unipi_spi_error(KERN_INFO "UNIPISPI: len=%d, part1=%4phC part2=%16phC\n", len, recv_buf->first_message,recv_buf->second_message);
+            goto err;
+        }
+#ifdef UNIPISPI_USE_RX_THREAD
+        if (recv_buf->second_message[0] == 0x65) {
+            // this op can be invoked only from kernel_work rx_proc
+            portindex = 0; // second_message[2]; Overit ve firmware
+            if (d_data->uart_count && (portindex < d_data->uart_count)) {
+                port = neuronspi_uart_data_global->p + d_data->uart_pindex + portindex;
+                port->rx_remain = recv_buf->second_message[3];
+                neuronspi_rx_queue_swap(port);
+            }
+        }
+#endif
+    }
+
+    return(port);
+
+err:
+    if (len>0) recv_buf->second_message[0] = 0;
+    recv_buf->first_message[0] = 0;
+
+    return(port);
+}
+
+
+
+
+#define clear_op_buffer(buffer, len)    { buffer->first_message[0] = 0;\
+                                if ((len > 0) && (buffer->second_message)) buffer->second_message[0] = 0; }
+
+
+struct unipi_spi_context* unipi_spi_setup_context(struct spi_device* spi_dev, struct neuronspi_op_buffer* send_buf,
+                            struct neuronspi_op_buffer* recv_buf, int len, 
+                            int freq, int delay, s32 send_header)
+{
+    //struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	int trans_count, remain, i;
+	struct unipi_spi_context *context;
+    struct spi_transfer * s_trans;
+	u16 packet_crc = 0;
+
+    if (len == 0) {
+        trans_count = 2;
+    } else {
+        if (send_header & UNIPISPI_OP_MODE_DO_CRC) len += 2;
+        trans_count = ((len-1) / NEURONSPI_MAX_TX) + 3; // number of transmissions
+    }
+
+	context = kzalloc(sizeof(struct unipi_spi_context)	+ trans_count * sizeof(struct spi_transfer), GFP_ATOMIC);
+	if (! context) {
+        return NULL;
+	}
+    s_trans = (struct spi_transfer *)(context + 1);
+    spi_message_init_with_transfers(&context->message, s_trans, trans_count);
+
+	s_trans[0].delay_usecs = NEURONSPI_EDGE_DELAY;
+	s_trans[0].bits_per_word = 8;
+	s_trans[0].speed_hz = freq;
+
+	s_trans[1].bits_per_word = 8;
+	s_trans[1].speed_hz = freq;
+    if (send_header  & UNIPISPI_OP_MODE_SEND_HEADER) {
+		unipi_spi_trace_1(KERN_INFO "UNIPISPI: SPI Master Write(op1) %8ph\n", send_buf->first_message);
+        if (send_header & UNIPISPI_OP_MODE_DO_CRC) {
+            packet_crc = neuronspi_spi_crc(send_buf->first_message, 4, 0);
+            *((u16*)(send_buf->first_message+4)) = packet_crc;
+        }
+        s_trans[1].delay_usecs = delay;
+        s_trans[1].len = NEURONSPI_FIRST_MESSAGE_LENGTH;
+        s_trans[1].tx_buf = send_buf->first_message;
+        s_trans[1].rx_buf = recv_buf->first_message;
+    }
+    if (len > 0) {
+        if (send_header & UNIPISPI_OP_MODE_DO_CRC) {
+            packet_crc = neuronspi_spi_crc(send_buf->second_message, len-2, packet_crc);
+            send_buf->second_message[len-2] = packet_crc & 0xff;
+            send_buf->second_message[len-1] = packet_crc >> 8;
+        }
+		unipi_spi_trace_1(KERN_INFO "UNIPISPI: SPI Master Write(%3d) %32ph\n", len, send_buf->second_message);
+		remain = len;
+		for (i = 2; i < trans_count; i++) {
+			s_trans[i].delay_usecs = 0;
+			s_trans[i].bits_per_word = 8;
+			s_trans[i].speed_hz = freq;
+			s_trans[i].tx_buf = send_buf->second_message + (NEURONSPI_MAX_TX * (i - 2));
+			s_trans[i].rx_buf = recv_buf->second_message + (NEURONSPI_MAX_TX * (i - 2));
+			s_trans[i].len = (remain > NEURONSPI_MAX_TX) ? NEURONSPI_MAX_TX : remain;
+			remain -= NEURONSPI_MAX_TX;
+		}
+        // len is size of second message WITHOUT crc
+        len -= 2;
+	}
+    
+    context->message.context = context;
+    context->message.spi = spi_dev;
+    context->len = len;
+    context->recv_buf = recv_buf;
+    return context;
+}
+
+/*
+static void unipi_spi_idle_op_complete(void *arg)
+{
+    struct unipi_spi_context* context = (struct unipi_spi_context*) arg;
+    struct neuronspi_port *port;
+
+    port = unipi_spi_check_message(context);
+    if (port && (port->rx_remain))  unipi_spi_read_str(context->message.spi, port);    
+    kfree(context->recv_buf);
+    kfree(context);
+}
+
+void unipi_spi_idle_op(struct spi_device* spi)
+{
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi);
+    struct neuronspi_op_buffer* recv_op;// = &d_data->idle_recv_buf;
+	struct unipi_spi_context *context;
+    unsigned long flags;
+
+    unipi_spi_trace(KERN_INFO "UNIPISPI: Idle op\n");
+    recv_op = kzalloc(sizeof(struct neuronspi_op_buffer), GFP_ATOMIC);
+    clear_op_buffer(recv_op, 0);
+    
+    context = unipi_spi_setup_context(spi, &UNIPISPI_IDLE_MESSAGE, recv_op, 0, d_data->ideal_frequency, 0, UNIPISPI_OP_MODE_SEND_HEADER);
+    if (context == NULL) goto err; // no mem for kzalloc
+    
+    context->message.complete = unipi_spi_idle_op_complete;
+     
+    spin_lock_irqsave(&unipi_spi_master_lock, flags);
+    if  ((d_data->reserved_device)       // Running reserved operations
+         ||(spi_async(spi, &context->message) != 0)) {
+        spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+        kfree(context);
+        unipi_spi_trace(KERN_INFO "UNIPISPI: Err=3 Idle op\n");
+        goto err;
+    }
+    spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+    return;
+    
+err:
+    kfree(recv_op);
+    if (d_data->poll_enabled) {
+        // reschedule poll timer
+        hrtimer_start_range_ns(&d_data->poll_timer, 2000000, 4000000, HRTIMER_MODE_REL);
+    }
+}
+*/
+
+/************************************************************************************
+ * 
+ *    unipi_spi_read_str()
+ *      can be called only from spi thread
+ *      for particular port can be only one read_str operation in progress
+ */
+ 
+static void unipi_spi_read_str_complete(void *arg)
+{
+    struct unipi_spi_context* context = (struct unipi_spi_context*) arg;
+    struct neuronspi_op_buffer* recv_buf = context->recv_buf;
+    struct neuronspi_driver_data *d_data = spi_get_drvdata(context->message.spi);
+    struct neuronspi_port *port, *port2;
+    int portindex2;
+
+    port = unipi_spi_check_message(context);
+    context->string_op_port->rx_in_progress = 0;
+
+    if (recv_buf->second_message[0] == 0x65) {
+        // this op can be invoked only from kernel_work rx_proc
+        portindex2 = 0; // second_message[2]; Overit ve firmware
+        if (d_data->uart_count && (portindex2 < d_data->uart_count)) {
+            port2 = neuronspi_uart_data_global->p + d_data->uart_pindex + portindex2;
+            if (port && (port == port2)) {
+                port = NULL;
+            }
+            neuronspi_uart_handle_rx(port2, recv_buf->second_message[1], recv_buf->second_message+4);
+            port2->rx_remain = recv_buf->second_message[3];
+            if (port2->rx_remain) unipi_spi_read_str(context->message.spi, port2);
+        }
+    }
+
+    if (port && (port->rx_remain))  unipi_spi_read_str(context->message.spi, port);
+
+    kfree(context);
+}
+
+void unipi_spi_read_str(struct spi_device* spi, struct neuronspi_port* port)
+{
+	struct neuronspi_op_buffer* send_op = &port->rx_send_buf;
+	struct neuronspi_op_buffer* recv_op = &port->rx_recv_buf;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi);
+	struct unipi_spi_context *context;
+	int transmit_len, len, locked;
+    unsigned long flags;
+
+    spin_lock_irqsave(&port->rx_in_progress_lock, flags);
+    locked = port->rx_in_progress;
+    if (!locked) port->rx_in_progress = 1;
+    spin_unlock_irqrestore(&port->rx_in_progress_lock, flags);
+    if (locked) return;
+
+    len = port->rx_remain;
+	if (len < 246) {
+		len = (len+4);
+	} else {
+		len = 250;
+	}
+	transmit_len = (len & 1 ? len+1 : len) + 4;  // transmit_length must be even
+
+	send_op->first_message[1] = transmit_len;     //
+	send_op->first_message[2] = 0;
+	send_op->first_message[3] = port->dev_port;
+	send_op->first_message[0] = 0x65;
+	send_op->second_message[0] = 0x65;
+
+    unipi_spi_trace(KERN_INFO "UNIPISPI: Read string ttyNS%d, len=%d\n", port->port.line, transmit_len-4);
+
+    clear_op_buffer(recv_op, len);
+    
+    context = unipi_spi_setup_context(spi, send_op, recv_op, transmit_len, d_data->ideal_frequency, 20, UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC);
+    if (context == NULL) goto err; // no mem for kzalloc
+    
+    context->message.complete = unipi_spi_read_str_complete;
+    context->string_op_port = port;
+     
+    spin_lock_irqsave(&unipi_spi_master_lock, flags);
+    if  ((d_data->reserved_device) ||        // Running reserved operations
+         (spi_async(spi, &context->message) != 0)) {
+        spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+        kfree(context);
+        unipi_spi_trace(KERN_INFO "UNIPISPI: Err=3 on Read string\n");
+        goto err;
+    }
+    spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+    return;
+    
+err:
+    port->rx_in_progress = 0;
+}
+
+/************************************************************************************
+ * 
+ *    unipi_spi_write_str()
+ *      
+ *      for particular port can be only one write_str operation in progress
+ */
+ 
+static void unipi_spi_write_str_complete(void *arg)
+{
+    struct unipi_spi_context* context = (struct unipi_spi_context*) arg;
+    //struct neuronspi_op_buffer* recv_buf = context->recv_buf;
+    //struct neuronspi_driver_data *d_data = spi_get_drvdata(context->message.spi);
+    unsigned long flags;
+    struct neuronspi_port *port;
+
+    port = unipi_spi_check_message(context);
+    if (port && (port->rx_remain))  unipi_spi_read_str(context->message.spi, port);
+	context->string_op_port->tx_fifo_len += context->len;
+
+   	spin_lock_irqsave(&context->string_op_port->port.lock, flags);
+    unipi_uart_handle_tx(context->string_op_port, CB_WRITESTRING);
+   	spin_unlock_irqrestore(&context->string_op_port->port.lock, flags);
+    
+    kfree(context);
+}
+
+int unipi_spi_write_str(struct spi_device* spi, struct neuronspi_port* port, int length)
+{
+	struct neuronspi_op_buffer* send_op = &port->tx_send_buf;
+	struct neuronspi_op_buffer* recv_op = &port->tx_recv_buf;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi);
+	struct unipi_spi_context *context;
+	int transmit_len;
+    unsigned long flags;
+
+	unipi_spi_trace(KERN_INFO "UNIPISPI: SPI Write string ttyNS%d, len:%d\n", port->port.line, length);
+	if ((length <= 0) || (length > 256)) return 1;
+
+    send_op->first_message[2] = 0;
+    send_op->first_message[3] = port->dev_port;
+	if (length == 1) {
+		send_op->first_message[0] = 0x41;
+		send_op->first_message[1] = port->tx_send_msg[0];
+        transmit_len = 0;
+	} else {
+		send_op->first_message[0] = 0x64;                           //NEURONSPI_SPI_UART_LONG_MESSAGE[0];
+		send_op->first_message[1] = length == 256 ? 0 : length;     // special case length==256
+		transmit_len = length & 1 ? length+1 : length;              // transmit_length must be even
+    }
+    clear_op_buffer(recv_op, transmit_len);
+
+    context = unipi_spi_setup_context(spi, send_op, recv_op, transmit_len, d_data->ideal_frequency, 20, UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC);
+    if (context == NULL) goto err; // no mem for kzalloc
+    
+    context->message.complete = unipi_spi_write_str_complete;
+    context->string_op_port = port;
+
+    spin_lock_irqsave(&unipi_spi_master_lock, flags);
+    if  ((d_data->reserved_device) ||        // Running reserved operations
+         (spi_async(spi, &context->message) != 0)) {
+        spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+        kfree(context);
+        unipi_spi_trace(KERN_INFO "UNIPISPI: Err=3 in Write string\n");
+        goto err;
+    }
+    spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+    return 0;
+    
+err:
+    return 1;
+}
+
+/************************************************************************************
+ * 
+ *    unipi_spi_get_tx_fifo()
+ *      
+ *      for particular port can be only one get_tx_fifo or write_str operation in progress
+ */
+ 
+static void unipi_spi_get_tx_fifo_complete(void *arg)
+{
+    struct unipi_spi_context* context = (struct unipi_spi_context*) arg;
+    u8 * recv_msg = context->string_op_port->tx_recv_msg;
+    //struct neuronspi_driver_data *d_data = spi_get_drvdata(context->message.spi);
+    struct neuronspi_port *port;
+    unsigned long flags;
+
+    port = unipi_spi_check_message(context);
+    if (port && (port->rx_remain))  unipi_spi_read_str(context->message.spi, port);
+
+    unipi_spi_trace("UNIPISPI: get_tx_fifo_complete recv_msg: %16ph\n", recv_msg);
+	if (recv_msg[0] == 0x03) {
+		context->string_op_port->tx_fifo_len = recv_msg[4] + ((recv_msg[5]) << 8);
+	}
+   	spin_lock_irqsave(&context->string_op_port->port.lock, flags);
+    unipi_uart_handle_tx(context->string_op_port, CB_GETTXFIFO);
+    spin_unlock_irqrestore(&context->string_op_port->port.lock, flags);
+    
+    kfree(context);
+}
+
+int unipi_spi_get_tx_fifo(struct spi_device* spi, struct neuronspi_port* port)
+{
+	struct neuronspi_op_buffer* send_op = &port->tx_send_buf;
+	struct neuronspi_op_buffer* recv_op = &port->tx_recv_buf;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi);
+	struct unipi_spi_context *context;
+    unsigned long flags;
+
+	unipi_spi_trace(KERN_INFO "UNIPISPI: SPI Get TX fifo length ttyNS%d\n", port->port.line);
+
+    send_op->first_message[0] = 0x03;
+    send_op->first_message[1] = 4+2;
+    *((u16*)(send_op->first_message + 2)) = port->tx_fifo_reg;
+	memcpy(send_op->second_message, send_op->first_message, 4);
+    clear_op_buffer(recv_op, (4+2));
+
+    context = unipi_spi_setup_context(spi, send_op, recv_op, 4+2, d_data->ideal_frequency, 35, UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC);
+    if (context == NULL) goto err; // no mem for kzalloc
+    
+    context->message.complete = unipi_spi_get_tx_fifo_complete;
+    context->string_op_port = port;
+
+    spin_lock_irqsave(&unipi_spi_master_lock, flags);
+    if  ((d_data->reserved_device) ||        // Running reserved operations
+         (spi_async(spi, &context->message) != 0)) {
+        spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+        kfree(context);
+        unipi_spi_trace(KERN_INFO "UNIPISPI: Err=3 in Get Tx fifo\n");
+        goto err;
+    }
+    spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+    return 0;
+    
+err:
+    return 1;
+}
+
+/* 
+ * Callback from spi thread
+ * invoked after transaction inserted by async_spi_send() is finished
+ */
+ 
+static void unipi_spi_firmware_op_complete(void *arg)
+{
+    struct unipi_spi_context* context = (struct unipi_spi_context*) arg;
+    //struct neuronspi_op_buffer* recv_buf = context->recv_buf;
+
+    // Don't check crc on firmware operation
+	unipi_spi_trace_1(KERN_INFO "UNIPISPI: SPI Firmware op len=%d:\n\t%64ph\n", context->len, context->recv_buf->second_message);
+    complete(context->unipi_spi_completion);
+    kfree(context);
+}
+
+
+static void unipi_spi_send_op_complete(void *arg)
+{
+    struct unipi_spi_context* context = (struct unipi_spi_context*) arg;
+    struct neuronspi_port* port;
+
+    port = unipi_spi_check_message(context);
+    if (port && (port->rx_remain)) unipi_spi_read_str(context->message.spi, port);
+
+    if (context->unipi_spi_completion) 
+        complete(context->unipi_spi_completion);
+    kfree(context);
+}
+
+/*
+ *  send_header: bits of UNIPISPI_OP_MODE_SEND_HEADER | UNIPISPI_OP_MODE_DO_CRC
+ *  len:         length of second message. If DO_CRC is not set, len includes crc
+ *  buffers:     must be long enough to calc crc  
+ *  returns:     0 if success
+ */
+int neuronspi_spi_send_op(struct spi_device* spi_dev, struct neuronspi_op_buffer* send_buf,
+                            struct neuronspi_op_buffer* recv_buf, s32 len, 
+                            s32 freq, s32 delay, s32 send_header, u8 lock_val)
+{
+	int ret_code = 0;
+	struct neuronspi_driver_data *d_data;
+	struct unipi_spi_context *context;
+    unsigned long flags;
+    DECLARE_COMPLETION_ONSTACK(done); //struct completion done;
+
+    unipi_spi_trace(KERN_INFO "UNIPISPI: SPI Send op=%d len=%d\n", send_buf->first_message[0], len);
+    clear_op_buffer(recv_buf, len);
+    d_data = spi_get_drvdata(spi_dev);
+
+    context = unipi_spi_setup_context(spi_dev, send_buf, recv_buf, len, freq, delay, send_header);
+    if (context == NULL) {
+        ret_code = -3; // no mem for kzalloc
+        goto err;
+    }
+
+    init_completion(&done);
+    context->unipi_spi_completion = &done;
+    if (send_header & UNIPISPI_OP_MODE_SEND_HEADER) {
+        context->message.complete = unipi_spi_send_op_complete;
+    } else {
+        context->message.complete = unipi_spi_firmware_op_complete;
+    }
+
+    spin_lock_irqsave(&unipi_spi_master_lock, flags);
+    // Check if there are running reserved operations
+	if (d_data != NULL && d_data->reserved_device && lock_val != d_data->reserved_device) {
+        ret_code = -1; // blocked by reservation
+        goto errcontext;
+	}
+
+    ret_code = spi_async(spi_dev, &context->message);
+    if (ret_code != 0) {
+        unipi_spi_trace(KERN_INFO "UNIPISPI: Err=3 txopcode:%d\n", send_buf->first_message[0]);
+        goto errcontext;
+    }
+    spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+
+    wait_for_completion(&done);
+    //cycles_t ct2 = get_cycles(); ktime_t t2 = ktime_get();
+    //unipi_spi_trace(KERN_INFO "UNIPISPI: deltatime:%lldus cycles:%ld\n", ((long long) ktime_to_ns(ktime_sub(t2,t1)))/1000, ct2-ct1);
+    return ret_code;
+
+errcontext:
+    spin_unlock_irqrestore(&unipi_spi_master_lock, flags);
+    kfree(context);
+
+err:
+    return ret_code;
+}
+
+/*****************************************************************
+ *  Modbus like Interface via /dev/unipispi 
+ */
+int neuronspi_open (struct inode *inode_p, struct file *file_p)
+{
+	struct neuronspi_file_data *f_internal_data;
+	if (file_p == NULL || inode_p == NULL) {
+		return -1;
+	}
+	neuronspi_cdrv.open_counter += 1;
+	f_internal_data = kzalloc(sizeof(*f_internal_data), GFP_ATOMIC);
+	f_internal_data->recv_buf.second_message = kzalloc(NEURONSPI_BUFFER_MAX, GFP_ATOMIC);
+	f_internal_data->send_buf.second_message = kzalloc(NEURONSPI_BUFFER_MAX, GFP_ATOMIC);
+	mutex_init(&f_internal_data->lock);
+	file_p->private_data = f_internal_data;
+	return 0;
+}
+
+int neuronspi_release (struct inode *inode_p, struct file *file_p)
+{
+	struct neuronspi_file_data *f_internal_data;
+	if (file_p == NULL) {
+		return -1;
+	}
+	f_internal_data = (struct neuronspi_file_data*)file_p->private_data;
+	kfree(f_internal_data->recv_buf.second_message);
+	kfree(f_internal_data->send_buf.second_message);
+	kfree(f_internal_data);
+	file_p->private_data = NULL;
+	neuronspi_cdrv.open_counter -= 1;
+	return 0;
+}
+
+ssize_t neuronspi_read (struct file *file_p, char *buffer, size_t len, loff_t *offset)
+{
+
+	s32 result = 0;
+    loff_t dummy_offset = 0;
+	struct neuronspi_file_data* private_data;
+	struct spi_device* spi;
+	struct neuronspi_driver_data* driver_data;
+	// Sanity checking
+	if (neuronspi_cdrv.open_counter == 0) {
+		neuronspi_cdrv.open_counter = 1;
+	}
+	if (buffer == NULL) return -7; // Invalid read buffer
+    if (len == 0) return result; // Empty read
+    if (len > 4095) return -EMSGSIZE;
+    if (file_p == NULL) {
+    	printk(KERN_DEBUG "UNIPISPI: CDEV File Pointer is NULL\n");
+    	return -8;
+    }
+    if (file_p->private_data == NULL) {
+    	printk(KERN_DEBUG "UNIPISPI: CDEV No Private Data\n");
+    	return -1;	// No private data
+    }
+    private_data = (struct neuronspi_file_data*) file_p->private_data;
+    if (private_data == NULL) return -4;
+    spi = neuronspi_s_dev[private_data->device_index];
+    if (spi == NULL) return -2;
+
+    driver_data = spi_get_drvdata(spi);
+    if (driver_data == NULL) return -2;
+    //if (driver_data->spi_driver == NULL) return -2;	// Invalid private data
+    //if ((driver_data->first_probe_reply[0] == 0) && !(driver_data->probe_always_succeeds) ) return -3; // couldnt happen
+
+    mutex_lock(&(private_data->lock));
+    if (private_data->recv_buf.second_message == NULL) {
+    	mutex_unlock(&(private_data->lock));
+    	return -10;
+    }
+    unipi_spi_trace(KERN_INFO "UNIPISPI: CDEV Read %zu, nspi:%d msglen=%d offset=%d\n", len,
+                    (private_data->device_index), private_data->message_len, (int)*offset);
+            
+	if (private_data->has_first_message & UNIPISPI_OP_MODE_SEND_HEADER) {
+   		result = simple_read_from_buffer(buffer, len, &dummy_offset, private_data->recv_buf.first_message, NEURONSPI_FIRST_MESSAGE_LENGTH);
+		if (result >=0) {
+            dummy_offset = 0;
+			result = simple_read_from_buffer(buffer+result, len - result, &dummy_offset,
+									private_data->recv_buf.second_message, private_data->message_len);
+        }
+	} else {
+   		result = simple_read_from_buffer(buffer, len, &dummy_offset, private_data->recv_buf.second_message, private_data->message_len);
+	}
+	if (result >= 0) {
+    	if (result + NEURONSPI_HEADER_LENGTH <= len) result = len;
+	}
+/*
+    } else if (private_data->message_len == 0) {
+    	mutex_unlock(&(private_data->lock));
+    	return -9;
+    }
+*/
+	mutex_unlock(&(private_data->lock));
+	return result;
+}
+
+
+ssize_t neuronspi_write (struct file *file_p, const char *buffer, size_t len, loff_t *w_offset)
+{
+	u8 device_index = 0;
+	u32 frequency;
+	u8  reservation, send_header;
+	s32 delay = 25;
+    loff_t dummy_offset = 0;
+    size_t datalen;
+	//unsigned long flags;
+	struct neuronspi_file_data* private_data;
+	struct spi_device* spi;
+	struct neuronspi_driver_data* driver_data;
+	// Sanity checking
+	if (neuronspi_cdrv.open_counter == 0) {
+		neuronspi_cdrv.open_counter = 1;
+	}
+
+	unipi_spi_trace(KERN_INFO "UNIPISPI: CDEV Write len:%zu\n", len);
+	if ((buffer == NULL) || (len == 0)) {
+		return 0; // Void write
+	}
+
+    if ((len > 4095) || (len < NEURONSPI_HEADER_LENGTH + NEURONSPI_FIRST_MESSAGE_LENGTH)) return -EMSGSIZE;
+    if (file_p == NULL) {
+    	return -12;
+    }
+    if (file_p->private_data == NULL) {
+    	printk(KERN_DEBUG "UNIPISPI: CDEV No Private Data\n");
+    	return -1;	// No private data
+    }
+    // Read packet header and initialise private data (dependent on each other)
+    device_index = buffer[0];
+    send_header = buffer[3];
+    frequency = (buffer[4] << 8 | buffer[5]) * 1000;
+   	delay = buffer[6];
+    reservation = buffer[7]; // Device reservation
+
+    buffer += NEURONSPI_HEADER_LENGTH;
+    datalen = len - NEURONSPI_HEADER_LENGTH;
+    
+    if (device_index > NEURONSPI_MAX_DEVS - 1) return -2;
+    private_data = (struct neuronspi_file_data*) file_p->private_data;
+    spi = neuronspi_s_dev[device_index];	
+    if (spi == NULL) return -2;
+
+    driver_data = spi_get_drvdata(spi);
+    if (driver_data == NULL) return -2;
+    //if (driver_data->spi_driver == NULL) return -2;	// Invalid private data
+    //if ((driver_data->first_probe_reply[0] == 0) && !(driver_data->probe_always_succeeds) ) 
+          // this couldnt happen, former condition is enough
+    //    return -3; // Device not present
+
+    if (delay == 0) { delay = 25; }	// Delay setting
+
+    if (reservation == 255) { 
+        // Unlock device
+   		driver_data->reserved_device = 0;
+   	
+    } else if (driver_data->reserved_device == 0) {
+        // Reserve the device
+   		driver_data->reserved_device = reservation;
+
+    } else if (reservation != driver_data->reserved_device) {
+        // Another device reserved
+   		return -4;				
+   	}
+
+    if (!frequency || (frequency > driver_data->ideal_frequency)) 
+        frequency = driver_data->ideal_frequency;
+
+    mutex_lock(&(private_data->lock));
+	private_data->device_index = device_index;
+    private_data->has_first_message = send_header;
+	if (send_header & UNIPISPI_OP_MODE_SEND_HEADER) {
+    	private_data->message_len = datalen - NEURONSPI_FIRST_MESSAGE_LENGTH;
+		simple_write_to_buffer(private_data->send_buf.first_message, NEURONSPI_FIRST_MESSAGE_LENGTH, &dummy_offset, buffer, datalen);
+        dummy_offset = 0;
+		simple_write_to_buffer(private_data->send_buf.second_message, NEURONSPI_BUFFER_MAX, &dummy_offset, buffer+NEURONSPI_FIRST_MESSAGE_LENGTH, private_data->message_len);
+	} else {
+    	private_data->message_len = datalen;
+		simple_write_to_buffer(private_data->send_buf.second_message, NEURONSPI_BUFFER_MAX, &dummy_offset, buffer, datalen);
+	}
+    // clear receive buffer content
+#if NEURONSPI_DETAILED_DEBUG > 1
+    memset(private_data->recv_buf.first_message, 0, sizeof(private_data->recv_buf.first_message));
+    memset(private_data->recv_buf.second_message, 0, NEURONSPI_BUFFER_MAX );
+#else
+    private_data->recv_buf.first_message[0] = 0;
+    private_data->recv_buf.second_message[0] = 0;
+#endif
+
+    if (private_data->message_len) {
+        if (private_data->send_buf.second_message[0] == 0x65) {
+            // op read string is not allowed here
+            mutex_unlock(&private_data->lock);
+            return len;
+        }
+    }
+    neuronspi_spi_send_op(spi, &private_data->send_buf, &private_data->recv_buf, private_data->message_len,
+								frequency, delay, send_header, reservation);
+    mutex_unlock(&private_data->lock);
+    return len;
+}
+
+/********************************************************
+ *  Interface used by kernel - UnipiSpi operations 
+ */
+
+int unipispi_modbus_read_register(struct spi_device* spi_dev, u16 reg, u16* value)
+{
+    struct neuronspi_op_buffer send_buf;
+    struct neuronspi_op_buffer recv_buf;
+    u8 send_data[4+2+2]; // cmd: 4B, value 2B, crc 2B
+    u8 recv_data[4+2+2];    
+    int ret_code;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	s32 frequency = NEURONSPI_DEFAULT_FREQ;
+	if (d_data) {
+		frequency = d_data->ideal_frequency;
+	}
+    send_buf.second_message = send_data;
+    recv_buf.second_message = recv_data;
+
+    send_buf.first_message[0] = 0x03;  // OP_READ_REGISTERS
+    send_buf.first_message[1] = 4+2;
+    *((u16*)(send_buf.first_message + 2)) = reg;
+	memcpy(send_data, send_buf.first_message, 4);
+	send_data[1] = 1;
+
+	ret_code = neuronspi_spi_send_op(spi_dev, &send_buf, &recv_buf, 4+2, frequency, 35,
+                                    UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC, 0);
+	if (ret_code == 0) {
+        if ((recv_data[0] == 0x03) && (recv_data[1]==1)) {  // check opcode and register count
+            *value = *((u16*)(recv_data + 4));
+        } else {
+            //unipi_spi_trace("Read reg: %d %8ph\n", reg, recv_data);
+            ret_code = 2;
+        }
+    }
+    unipi_spi_trace("Read reg: %d ret: %d %8ph\n", reg, ret_code, recv_data);
+    return ret_code;
+}
+
+int unipispi_modbus_read_u32(struct spi_device* spi_dev, u16 reg, u32* value)
+{
+    struct neuronspi_op_buffer send_buf;
+    struct neuronspi_op_buffer recv_buf;
+    u8 send_data[4+4+2]; // cmd: 4B, value 4B, crc 2B
+    u8 recv_data[4+4+2];    
+    int ret_code;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	s32 frequency = NEURONSPI_DEFAULT_FREQ;
+	if (d_data) {
+		frequency = d_data->ideal_frequency;
+	}
+    send_buf.second_message = send_data;
+    recv_buf.second_message = recv_data;
+
+    send_buf.first_message[0] = 0x03;  // OP_READ_REGISTERS
+    send_buf.first_message[1] = 4+4;
+    *((u16*)(send_buf.first_message + 2)) = reg;
+	memcpy(send_data, send_buf.first_message, 4);
+	send_data[1] = 2;
+    
+	ret_code = neuronspi_spi_send_op(spi_dev, &send_buf, &recv_buf, 4+4, frequency, 35,
+                                    UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC, 0);
+	if (ret_code == 0) {
+        if ((recv_data[0] == 0x03) && (recv_data[1]==2)) {
+            *value = *((u32*)(recv_data + 4));
+        } else {
+            ret_code = 2;
+            unipi_spi_error("Read reg32 error: %d ret: %d %10ph\n", reg, ret_code, recv_data);
+        }
+    }
+    unipi_spi_trace("Read reg32: %d ret: %d %10ph\n", reg, ret_code, recv_data);
+    return ret_code;
+}
+
+int unipispi_modbus_read_many(struct spi_device* spi_dev, u16 reg, u16* value, int register_count)
+{
+	printk(KERN_ERR "UNIPISPI: modbus read many(%d) UNIMPLENETED\n", register_count);
+    //ToDo: 
+    return 0;
+}
+
+
+int unipispi_modbus_write_register(struct spi_device* spi_dev, u16 reg, u16 value)
+{
+    struct neuronspi_op_buffer send_buf;
+    struct neuronspi_op_buffer recv_buf;
+    u8 send_data[4+2+2]; // cmd: 4B, value 2B, crc 2B
+    u8 recv_data[4+2+2];    
+    int ret_code;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	s32 frequency = NEURONSPI_DEFAULT_FREQ;
+	if (d_data) {
+		frequency = d_data->ideal_frequency;
+	}
+    send_buf.second_message = send_data;
+    recv_buf.second_message = recv_data;
+
+    send_buf.first_message[0] = 0x06;   // OP_WRITE_REGISTERS
+    send_buf.first_message[1] = 4+2;
+    *((u16*)(send_buf.first_message + 2)) = reg;
+	memcpy(send_data, send_buf.first_message, 4);
+	send_data[1] = 1;
+    *((u16*)(send_data + 4)) = value;
+    
+	ret_code = neuronspi_spi_send_op(spi_dev, &send_buf, &recv_buf, 4+2, frequency, 35,
+                                    UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC, 0);
+	if (ret_code == 0) {
+        if ((recv_data[0] != 0x06) || (recv_data[1]!=1)) {
+            //unipi_spi_trace("Write reg: %d %8ph\n", reg, recv_data);
+            ret_code = 2;
+            unipi_spi_error("Write reg error: %d ret: %d %8ph\n", reg, ret_code, recv_data);
+        }
+    }
+    unipi_spi_trace("Write reg: %d ret: %d %8ph\n", reg, ret_code, recv_data);
+    return ret_code;
+}
+
+int unipispi_modbus_write_u32(struct spi_device* spi_dev, u16 reg, u32 value)
+{
+    struct neuronspi_op_buffer send_buf;
+    struct neuronspi_op_buffer recv_buf;
+    u8 send_data[4+4+2]; // cmd: 4B, value 4B, crc 2B
+    u8 recv_data[4+4+2];    
+    int ret_code;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	s32 frequency = NEURONSPI_DEFAULT_FREQ;
+	if (d_data) {
+		frequency = d_data->ideal_frequency;
+	}
+    send_buf.second_message = send_data;
+    recv_buf.second_message = recv_data;
+
+    send_buf.first_message[0] = 0x06;    // OP_WRITE_REGISTERS
+    send_buf.first_message[1] = 4+4;
+    *((u16*)(send_buf.first_message + 2)) = reg;
+	memcpy(send_data, send_buf.first_message, 4);
+	send_data[1] = 2;
+    *((u32*)(send_data + 4)) = value;
+    
+	ret_code = neuronspi_spi_send_op(spi_dev, &send_buf, &recv_buf, 4+4, frequency, 35,
+                                    UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC, 0);
+	if (ret_code == 0) {
+        if ((recv_data[0] != 0x06) || (recv_data[1]!=2)) {
+            ret_code = 2;
+            unipi_spi_error("Write reg32 error: %d ret: %d %10ph\n", reg, ret_code, recv_data);
+        }
+    }
+    unipi_spi_trace("Write reg32: %d ret: %d %10ph\n", reg, ret_code, recv_data);
+    return ret_code;
+}
+
+int unipispi_modbus_write_many(struct spi_device* spi_dev, u16 reg, u16* value, int register_count)
+{
+	printk(KERN_ERR "UNIPISPI: modbus write many(%d) UNIMPLENETED\n", register_count);
+    //ToDo:
+    return 0;
+}
+
+int unipispi_modbus_write_coil(struct spi_device* spi_dev, u16 coil, int value)
+{
+    struct neuronspi_op_buffer send_buf;
+    struct neuronspi_op_buffer recv_buf;
+    int ret_code;
+	struct neuronspi_driver_data *d_data = spi_get_drvdata(spi_dev);
+	s32 frequency = NEURONSPI_DEFAULT_FREQ;
+	if (d_data) {
+		frequency = d_data->ideal_frequency;
+	}
+
+    send_buf.first_message[0] = 0x05;    // OP_WRITE_SINGLE_COIL
+    send_buf.first_message[1] = value ? 1 : 0;
+    *((u16*)(send_buf.first_message + 2)) = coil;
+    
+	ret_code = neuronspi_spi_send_op(spi_dev, &send_buf, &recv_buf, 0, frequency, 25,
+                                    UNIPISPI_OP_MODE_SEND_HEADER|UNIPISPI_OP_MODE_DO_CRC, 0);
+    return ret_code;
+}
+
+
+void neuronspi_spi_set_irqs(struct spi_device* spi_dev, u16 to)
+{
+    unipispi_modbus_write_register(spi_dev, 1007, to);
+	unipi_spi_trace(KERN_INFO "UNIPISPI: SPI IRQ Set, CS%d, to:0x%x\n", spi_dev->chip_select, to);
+}
+
+void neuronspi_uart_flush_proc(struct kthread_work *ws)
+{
+	struct neuronspi_port *n_port = ((container_of((ws), struct neuronspi_port, flush_work)));
+    struct neuronspi_driver_data *n_spi = n_port->n_spi;
+	struct spi_device *spi = neuronspi_s_dev[n_spi->neuron_index];
+    struct neuronspi_op_buffer recv_buf;
+	unsigned long flags;
+
+    unipi_spi_read_str(spi,  n_port);
+    if (n_port->rx_in_progress) {
+		s32 frequency = NEURONSPI_DEFAULT_FREQ;
+		if (n_spi) {
+			frequency = n_spi->ideal_frequency;
+		}
+		neuronspi_spi_send_const_op(spi, &UNIPISPI_IDLE_MESSAGE, &recv_buf, 0, frequency, 25);
+	}
+
+	spin_lock_irqsave(&n_port->port.lock, flags);
+    n_port->accept_rx = 1;
+    spin_unlock_irqrestore(&n_port->port.lock, flags);
+
+}
+
+void neuronspi_irq_proc(struct kthread_work *ws)
+{
+	struct neuronspi_driver_data *n_spi = ((container_of((ws), struct neuronspi_driver_data, irq_work)));
+	struct spi_device *spi = neuronspi_s_dev[n_spi->neuron_index];
+    struct neuronspi_op_buffer recv_buf;
+
+	s32 frequency = NEURONSPI_DEFAULT_FREQ;
+	if (n_spi) {
+		frequency = n_spi->ideal_frequency;
+	}
+	neuronspi_spi_send_const_op(spi, &UNIPISPI_IDLE_MESSAGE, &recv_buf, 0, frequency, 25);
+}
+
+
+// callback of poll_timer. Schedule ->irq_work
+static enum hrtimer_restart neuronspi_poll_timer_func(struct hrtimer *timer)
+{
+    struct neuronspi_driver_data* n_spi = ((container_of((timer), struct neuronspi_driver_data, poll_timer)));
+    //struct spi_device *spi = neuronspi_s_dev [n_spi->neuron_index];
+    
+	unipi_spi_trace_1(KERN_INFO "UNIPISPI: nspi%d POLL IRQ\n", n_spi->neuron_index);
+	kthread_queue_work(n_spi->primary_worker, &n_spi->irq_work);
+    //unipi_spi_idle_op(spi);
+	return HRTIMER_NORESTART;
+}
+
+
+irqreturn_t neuronspi_spi_irq(s32 irq, void *dev_id)
+{
+	// real irq handler - schedule idle op to read irq status (irq_work = neuronspi_irq_proc)
+    struct spi_device *spi = (struct spi_device *)dev_id;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+
+	unipi_spi_trace(KERN_INFO "UNIPISPI: nspi%d SPI IRQ\n", n_spi->neuron_index);
+	kthread_queue_work(n_spi->primary_worker, &n_spi->irq_work);
+    //unipi_spi_idle_op(spi);
+	return IRQ_HANDLED;
+}
+
+void neuronspi_enable_uart_interrupt(struct neuronspi_port* n_port)
+{
+    // ToDo: save, which port requested enable to support disabling
+    struct spi_device *spi = neuronspi_s_dev[n_port->dev_index];
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+    neuronspi_spi_set_irqs(spi, 0x5);
+    if (n_spi->no_irq) {
+        // start polling
+        n_spi->poll_enabled = 1;
+        // invoke first probe -> which invokes hrtimer
+        kthread_queue_work(n_spi->primary_worker, &n_spi->irq_work);
+        //unipi_spi_idle_op(spi);
+    }
+}
+
+#define REG1000(first_probe,reg)    ((u16)(first_probe[4+2*(reg-1000)] | (first_probe[5+2*(reg-1000)] << 8)))
+#define REG1000_lo(first_probe,reg) (first_probe[4+2*(reg-1000)])
+#define REG1000_hi(first_probe,reg) (first_probe[5+2*(reg-1000)])
+#define lo(x) (x & 0xff)
+#define hi(x) (x >> 8)
+const char name_unknown[] = "UNKNOWN\0";
+
+s32 neuronspi_spi_probe(struct spi_device *spi)
+{
+	//const struct neuronspi_devtype *devtype;
+	struct neuronspi_driver_data *n_spi;
+    struct neuronspi_op_buffer recv_op;
+    u8  first_probe[UNIPISPI_PROBE_MESSAGE_LEN];
+	s32 ret, i, no_irq = 0;
+	u8 uart_count = 0;
+    u16 hardware_model, lower_board;
+    u8  upper_board = 0;
+    const char *board_name = name_unknown;
+    u32 probe_always_succeeds = 0;
+	u32 always_create_uart = 0;
+    struct kthread_worker   *worker;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
+    struct spi_delay inactive_delay;
+#endif
+
+	unsigned long flags;
+
+	n_spi = kzalloc(sizeof *n_spi, GFP_ATOMIC);
+	spin_lock_irqsave(neuronspi_probe_spinlock, flags);
+	neuronspi_probe_count++;
+	spin_unlock_irqrestore(neuronspi_probe_spinlock, flags);
+	if (!n_spi)
+		return -ENOMEM;
+	unipi_spi_trace(KERN_INFO "UNIPISPI: CS%d Probe Started\n", spi->chip_select);
+	if (spi == NULL) {
+        kfree(n_spi);
+		return -8;
+	}
+
+	/* Setup SPI bus */
+	spi->bits_per_word	= 8;
+	spi->mode		    = spi->mode ? spi->mode : SPI_MODE_0;
+	spi->max_speed_hz	= spi->max_speed_hz ? spi->max_speed_hz : 12000000;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
+	spi->rt = 1;
+#endif
+	ret = spi_setup(spi);
+	if (ret) {
+        kfree(n_spi);
+		return ret;
+    }
+
+	n_spi->neuron_index = spi->chip_select - 1;
+	n_spi->reserved_device = 0;
+
+	unipi_spi_trace(KERN_DEBUG "UNIPISPI: CS%d, Chip Max Hz-%d %d\n", spi->chip_select, spi->master->max_speed_hz, spi->max_speed_hz);
+	if (spi->dev.of_node) {
+		const struct of_device_id *of_id =
+			of_match_device(neuronspi_id_match, &spi->dev);
+		if (!of_id) {
+			printk(KERN_DEBUG "UNIPISPI: Probe %s does not match a device!\n", *(&spi->dev.of_node->full_name));
+            kfree(n_spi);
+			return -ENODEV;
+		}
+		of_property_read_u32_array(spi->dev.of_node, "neuron-board-index", &(n_spi->neuron_index), 1);
+		of_property_read_u32_array(spi->dev.of_node, "neuron-probe-always-succeeds", &(probe_always_succeeds), 1);
+		of_property_read_u32_array(spi->dev.of_node, "neuron-always-create-tty", &(always_create_uart), 1);
+		//devtype = (struct neuronspi_devtype *)of_id->data;
+		unipi_spi_trace(KERN_INFO "UNIPISPI: CS%d, Device Tree Node defined index=%d\n", spi->chip_select, n_spi->neuron_index);
+
+	} else {
+		//const struct spi_device_id *id_entry = spi_get_device_id(spi);
+		//devtype = (struct neuronspi_devtype *)id_entry->driver_data;
+	}
+
+	//Validate board index range
+	if ((n_spi->neuron_index < 0) || ((n_spi->neuron_index > NEURONSPI_MAX_DEVS))) {
+		printk(KERN_ERR "UNIPISPI: %s has invalid board index (%d)!\n", *(&spi->dev.of_node->full_name), n_spi->neuron_index);
+        kfree(n_spi);
+		return -ENODEV;
+	}
+
+	//Check if board index is not already assigned
+	if (neuronspi_s_dev[n_spi->neuron_index] != NULL) {
+		printk(KERN_ERR "UNIPISPI: %s has duplicit board index (%d)!\n", *(&spi->dev.of_node->full_name), n_spi->neuron_index);
+        kfree(n_spi);
+		return -ENODEV;
+	}
+
+	// We perform an initial probe of registers 1000-1004 to identify the device, using a premade message
+	neuronspi_spi_send_const_op(spi, &UNIPISPI_IDLE_MESSAGE, &recv_op, 0, NEURONSPI_DEFAULT_FREQ, 25);
+	// Throw away the first message - the associated SPI Master is sometimes not properly initialised at this point
+
+    recv_op.second_message = first_probe;
+
+	for (i=0; i< 5; i++) {
+        neuronspi_spi_send_const_op(spi, &UNIPISPI_PROBE_MESSAGE, &recv_op, UNIPISPI_PROBE_MESSAGE_LEN, NEURONSPI_DEFAULT_FREQ, 25);
+		if (first_probe[0] != 0) break;
+	}
+
+    n_spi->combination_id = 0xff;
+	if (first_probe[0] != 0) {
+        // Board found, try to find model in table
+        n_spi->firmware_version = REG1000   (first_probe,1000);
+		uart_count              = REG1000_lo(first_probe,1002) & 0xf;
+        hardware_model          = REG1000_hi(first_probe,1003);
+        lower_board             = REG1000   (first_probe,1004) & 0xfff0;
+		for (i = 0; i < NEURONSPI_BOARDTABLE_LEN; i++) {
+			if (hardware_model == NEURONSPI_BOARDTABLE[i].index) {
+                //if ((lower_board>>8) != NEURONSPI_BOARDTABLE[i].lower_board_id) { // strange combination  //break;
+                n_spi->combination_id = i;
+                upper_board = NEURONSPI_BOARDTABLE[i].upper_board_id;
+                n_spi->features = &(NEURONSPI_BOARDTABLE[n_spi->combination_id].definition->features);
+                board_name = NEURONSPI_BOARDTABLE[n_spi->combination_id].definition->combination_name;
+                break;
+			}
+		}
+        //n_spi->ideal_frequency = neuronspi_is_slower_model(lower_board) ? NEURONSPI_SLOWER_FREQ : NEURONSPI_COMMON_FREQ; 
+        n_spi->ideal_frequency = neuronspi_frequency_by_model(lower_board);
+        no_irq = neuronspi_is_noirq_model(lower_board);
+
+        printk(KERN_INFO "UNIPISPI: UniPi Board %s (L:%x U:%x C:%x) at CS%d (nspi%d %dkHz) detected.\n\t\t\tFw: v%d.%d Uarts:%d, reg1001-4: %04x %04x %04x %04x\n",
+				board_name, hi(lower_board), upper_board, hardware_model, spi->chip_select, n_spi->neuron_index, n_spi->ideal_frequency/1000,
+                hi(n_spi->firmware_version), lo(n_spi->firmware_version), uart_count, 
+                REG1000(first_probe,1001), REG1000(first_probe,1002), REG1000(first_probe,1003), REG1000(first_probe,1004));
+
+	} else if (probe_always_succeeds) {
+        // dummy board
+        if (always_create_uart) uart_count = 1;
+        n_spi->ideal_frequency = NEURONSPI_SLOWER_FREQ;
+		no_irq = 1;
+		printk(KERN_INFO "UNIPISPI: DUMMY UniPi Board at CS%d (nspi%d) assigned. Uarts:%d, uses freq. %d Hz\n",
+				spi->chip_select,  n_spi->neuron_index, uart_count, n_spi->ideal_frequency);
+
+    } else {
+		ret = -ENODEV;
+		kfree(n_spi);
+		printk(KERN_INFO "UNIPISPI: Probe did not detect a valid UniPi device at CS%d\n", spi->chip_select);
+		return ret;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+    if (spi->controller->set_cs != unipi_spi_set_cs) {
+        unipi_spi_master_set_cs = spi->controller->set_cs;
+        unipi_spi_master_flag = spi->controller->flags;
+        spi->controller->set_cs = unipi_spi_set_cs;
+        spi->controller->flags |= SPI_MASTER_GPIO_SS;
+    }
+    if (gpio_is_valid(spi->cs_gpio)) {
+        spi->cs_gpio = -spi->cs_gpio;
+    }
+#else
+    inactive_delay.value = 40;
+    inactive_delay.unit = SPI_DELAY_UNIT_USECS;
+	spi_set_cs_timing(spi, NULL, NULL, &inactive_delay);
+#endif
+
+    // Prepare worker for interrupt, LEDs, UARTs
+    worker = kthread_create_worker(0, "unipispi%d", n_spi->neuron_index);
+	if (IS_ERR(worker)) {
+        kfree(n_spi);
+		return PTR_ERR(worker);
+    }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+	sched_setscheduler(worker->task, SCHED_FIFO, &neuronspi_sched_param);
+#else
+	sched_set_fifo(worker->task);
+#endif
+    n_spi->primary_worker = worker;
+    
+    // Prepare Register map
+	n_spi->reg_map = regmap_init(&(spi->dev), &neuronspi_regmap_bus, spi, &neuronspi_regmap_config_default);
+	spin_lock_init(&n_spi->sysfs_regmap_lock);
+	if (n_spi->features) {
+		n_spi->regstart_table = kzalloc(sizeof(struct neuronspi_board_regstart_table), 1);
+		neuronspi_create_reg_starts(n_spi->regstart_table, NEURONSPI_BOARDTABLE[n_spi->combination_id].definition);
+	} else {
+		n_spi->regstart_table = NULL;
+	}
+
+    // Save spi device into global array
+	spin_lock_irqsave(neuronspi_probe_spinlock, flags);
+	spi_set_drvdata(spi, n_spi);
+	neuronspi_s_dev[n_spi->neuron_index] = spi;
+
+	if (neuronspi_probe_count == NEURONSPI_MAX_DEVS) {	//TODO - model guess procedure is obsolete - will be removed
+		neuronspi_model_id = neuronspi_find_model_id(neuronspi_probe_count);
+	}
+	spin_unlock_irqrestore(neuronspi_probe_spinlock, flags);
+
+	if (neuronspi_model_id != -1) {
+		printk(KERN_INFO "UNIPISPI: Detected UniPi board combination corresponding to %s\n", NEURONSPI_MODELTABLE[neuronspi_model_id].model_name);
+	}
+
+    /* Platform LED, GPIO, IIO sysfs subsystem init */
+	if (neuron_plc_dev == NULL) {
+        // global platform root
+		neuron_plc_dev = platform_device_alloc("unipi_plc", -1);
+		neuron_plc_dev->dev.groups = neuron_plc_attr_groups;
+		platform_device_add(neuron_plc_dev);
+	}
+    // Add platform iogroup_x and LEDs, GPIOs, IIOs
+    n_spi->board_device = neuronspi_board_device_probe(n_spi);
+
+ 
+    n_spi->uart_count_to_probe = uart_count;
+	if (uart_count) {
+        if (neuronspi_uart_driver_global != NULL) {	
+            // Normally is port registration done after unipispi driver probe. (in the end of __init__)
+            unipi_spi_trace(KERN_DEBUG "UNIPISPI: UART registration\n");
+            neuronspi_uart_probe(spi, n_spi);
+
+        } else {
+            unipi_spi_trace(KERN_DEBUG "UNIPISPI: Uart driver not registered yet. Uart port add later.\n");
+        }
+	}
+
+	neuronspi_spi_set_irqs(spi, 0x5);
+
+    kthread_init_work(&(n_spi->irq_work), neuronspi_irq_proc); // prepare work function for interrupt status checking
+	if (!no_irq) {
+		n_spi->no_irq = 0;
+		//ret = devm_request_irq(&(spi->dev), spi->irq, neuronspi_spi_irq, 0x81, dev_name(&(spi->dev)), spi);
+		//ret = devm_request_irq(&(spi->dev), spi->irq, neuronspi_spi_irq, IRQF_TRIGGER_HIGH, dev_name(&(spi->dev)), spi);
+        // load setting of EDGE/LEVEL from devicetree
+		ret = devm_request_irq(&(spi->dev), spi->irq, neuronspi_spi_irq, 0, dev_name(&(spi->dev)), spi);
+		unipi_spi_trace(KERN_DEBUG "UNIPISPI: SPI IRQ %d registration: ret=%d\n", spi->irq, ret);
+        no_irq = (ret !=0);
+        ret = 0;
+    }
+	if (no_irq) {
+        n_spi->no_irq = 1;
+        hrtimer_init(&n_spi->poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+        n_spi->poll_timer.function = neuronspi_poll_timer_func;
+        unipi_spi_trace(KERN_DEBUG "UNIPISPI: NO IRQ ON THIS MODEL !!\n");
+	}
+
+	return ret;
+}
+
+s32 neuronspi_spi_remove(struct spi_device *spi)
+{
+    int neuron_index;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+
+    if (n_spi) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+        if ((spi->cs_gpio < 0) && (spi->cs_gpio != -ENOENT)) { spi->cs_gpio = -spi->cs_gpio; }
+        if (spi->controller->set_cs == unipi_spi_set_cs) {
+            spi->controller->set_cs = unipi_spi_master_set_cs;
+            if (unipi_spi_master_flag & SPI_MASTER_GPIO_SS) {
+                spi->controller->flags |= SPI_MASTER_GPIO_SS;
+            } else {
+                spi->controller->flags &= ~SPI_MASTER_GPIO_SS;
+            }
+        }
+#endif
+        neuron_index = n_spi->neuron_index; 
+		if (n_spi->no_irq) {
+            hrtimer_cancel(&n_spi->poll_timer);
+        } else {
+            devm_free_irq(&(spi->dev), spi->irq, spi);             
+        }
+        neuronspi_uart_remove(spi);
+
+		if (n_spi->board_device) {
+            neuronspi_board_device_remove(n_spi->board_device);
+		}
+        if (n_spi->reg_map) 
+            regmap_exit(n_spi->reg_map); 
+        if (n_spi->regstart_table)
+            kfree(n_spi->regstart_table);
+
+        kthread_destroy_worker(n_spi->primary_worker);
+        // clear global array item
+        neuronspi_s_dev[neuron_index] = NULL; 
+		kfree(n_spi);
+        printk(KERN_INFO "UNIPISPI: UniPi Board nspi%d removed\n", neuron_index);
+	}
+	return 0;
+}
+
+
+struct file_operations file_ops =
+{
+	.open 				= neuronspi_open,
+	.read 				= neuronspi_read,
+	.write 				= neuronspi_write,
+	.release 			= neuronspi_release,
+	.owner				= THIS_MODULE
+};
+
+
+int char_register_driver(void)
+{
+    int major;
+    struct device *parent = NULL;
+	if (neuronspi_cdrv.major_number >= 0) return 0;
+
+	// Character device registration
+	unipi_spi_trace(KERN_DEBUG "UNIPISPI: CDEV Initialising Character Device\n");
+
+	major = register_chrdev(0, NEURON_DEVICE_NAME, &file_ops);
+	if (major < 0){
+	   printk(KERN_ALERT "NEURONSPI: CDEV Failed to register chrdev\n");
+	   return major;
+	}
+	unipi_spi_trace_1(KERN_DEBUG "UNIPISPI: CDEV major number %d\n", major);
+
+	// Character class registration
+	neuronspi_cdrv.driver_class = class_create(THIS_MODULE, NEURON_DEVICE_CLASS);
+	if (IS_ERR(neuronspi_cdrv.driver_class)) {
+		unregister_chrdev(major, NEURON_DEVICE_NAME);
+		printk(KERN_ALERT "NEURONSPI: CDEV Failed to register device class\n");
+		return PTR_ERR(neuronspi_cdrv.driver_class);
+	}
+	unipi_spi_trace_1(KERN_DEBUG "UNIPISPI: CDEV Device class registered\n");
+
+	// Device driver registration
+	/*neuronspi_cdrv.dev = device_create_with_groups(neuronspi_cdrv.driver_class, &(neuron_plc_dev->dev), \
+                            MKDEV(major, 0), NULL, neuron_plc_attr_groups, NEURON_DEVICE_NAME);*/
+
+    if (neuron_plc_dev != NULL) parent = &(neuron_plc_dev->dev);
+	neuronspi_cdrv.dev = device_create(neuronspi_cdrv.driver_class, parent, MKDEV(major, 0), \
+                            neuron_plc_dev, NEURON_DEVICE_NAME);
+	if (IS_ERR(neuronspi_cdrv.dev)) {
+		class_destroy(neuronspi_cdrv.driver_class);
+        unregister_chrdev(major, NEURON_DEVICE_NAME);
+        printk(KERN_ALERT "NEURONSPI: CDEV Failed to create the device\n");
+        return PTR_ERR(neuronspi_cdrv.dev);
+	}
+	printk(KERN_DEBUG "UNIPISPI: ModBus/SPI interface /dev/%s (%d:0) created.\n", NEURON_DEVICE_NAME, major);
+
+    neuronspi_cdrv.major_number = major;
+	return 0;
+}
+
+void char_unregister_driver(void)
+{
+    if (neuronspi_cdrv.major_number < 0) return;
+
+	device_destroy(neuronspi_cdrv.driver_class, MKDEV(neuronspi_cdrv.major_number, 0));     // Destroy the device
+	class_destroy(neuronspi_cdrv.driver_class);                             				// Destroy the class
+	unregister_chrdev(neuronspi_cdrv.major_number, NEURON_DEVICE_NAME);             		// Unregister the major number
+	unipi_spi_trace(KERN_INFO "UNIPISPI: CDEV unloaded\n");
+}
+
+/*********************
+ * Final definitions *
+ *********************/
+MODULE_DEVICE_TABLE(of, neuronspi_id_match);
+
+struct spi_driver neuronspi_spi_driver =
+{
+	.driver =
+	{
+		.name			= NEURON_DRIVER_NAME,
+		.of_match_table	= of_match_ptr(neuronspi_id_match)
+	},
+	.probe				= neuronspi_spi_probe,
+	.remove				= neuronspi_spi_remove,
+};
+
+
+MODULE_ALIAS("spi:unipispi");
+
+
+
+static s32 __init neuronspi_init(void)
+{
+	s32 ret = 0;
+
+	neuronspi_probe_spinlock = kzalloc(sizeof(struct spinlock), GFP_ATOMIC);
+	spin_lock_init(neuronspi_probe_spinlock);
+	spin_lock_init(&unipi_spi_master_lock);
+	//mutex_init(&neuronspi_master_mutex);
+	mutex_init(&unipi_inv_speed_mutex);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
+    loop_per_us = ((loops_per_jiffy) * HZ )/ 1000000;
+    if (loop_per_us == 0) loop_per_us = 1;
+#endif
+    // clear global neuron spi devices list
+	memset(&neuronspi_s_dev, 0, sizeof(neuronspi_s_dev));
+	ret = spi_register_driver(&neuronspi_spi_driver);
+
+	if (ret < 0) {
+		printk(KERN_ERR "UNIPISPI: Failed to init spi driver --> %d\n", ret);
+		return ret;
+	}
+	printk(KERN_INFO "UNIPISPI: SPI Driver Registered, Major Version: %s\n", NEURONSPI_MAJOR_VERSIONSTRING);
+
+    neuronspi_invalidate_thread = kthread_run(neuronspi_regmap_invalidate, NULL, "unipispi_inv");
+    if (IS_ERR(neuronspi_invalidate_thread)) {
+        neuronspi_invalidate_thread = NULL;
+    }
+
+	char_register_driver();
+
+    neuronspi_uart_driver_init();
+    neuronspi_uart_probe_all();
+
+	unipi_tty_init();
+	return ret;
+}
+
+module_init(neuronspi_init);
+
+static void __exit neuronspi_exit(void)
+{
+	unipi_spi_trace(KERN_INFO "UNIPISPI: Open Counter is %d\n", neuronspi_cdrv.open_counter);
+
+    if (neuronspi_invalidate_thread) {
+		kthread_stop(neuronspi_invalidate_thread);
+        neuronspi_invalidate_thread = NULL;
+	}
+	char_unregister_driver();
+    neuronspi_uart_driver_exit();
+    unipi_tty_exit();
+	spi_unregister_driver(&neuronspi_spi_driver);
+	if (neuron_plc_dev) {
+		platform_device_unregister(neuron_plc_dev);
+	}
+	printk(KERN_INFO "UNIPISPI: SPI Driver Unregistered\n");
+}
+module_exit(neuronspi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tomas Knot <knot@faster.cz>");
+MODULE_DESCRIPTION("UniPi PLC Driver");
diff --git a/drivers/unipi/unipi_spi.h b/drivers/unipi/unipi_spi.h
new file mode 100644
index 000000000000..e855abc3ab04
--- /dev/null
+++ b/drivers/unipi/unipi_spi.h
@@ -0,0 +1,222 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_SPI_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_SPI_H_
+
+/************
+ * Includes *
+ ************/
+#include <linux/version.h>
+
+#include "unipi_common.h"
+#include "unipi_platform.h"
+#include "unipi_sysfs.h"
+#include "unipi_iio.h"
+
+/********************
+ * Module Constants *
+ ********************/
+/*
+#define NEURONSPI_SLOWER_MODELS_LEN 					3
+static const u16 NEURONSPI_SLOWER_MODELS[NEURONSPI_SLOWER_MODELS_LEN] = {
+		0xb10, 0xc10, 0xf10, 0xb20
+};
+*/
+
+struct neuronspi_frequecy_map
+{
+    u16  model;
+    u16  mask;
+    int  frequency;
+};
+
+#define NEURONSPI_FREQUENCY_LEN      2
+static const struct neuronspi_frequecy_map NEURONSPI_FREQUENCY_MAP[NEURONSPI_FREQUENCY_LEN] = {
+	{model:0x0b00, mask:0xff00, frequency:NEURONSPI_SLOWER_FREQ },
+	{model:0x0000, mask:0x0000, frequency:NEURONSPI_COMMON_FREQ}
+};
+
+
+#define NEURONSPI_CRC16TABLE_LEN						256
+static const u16 NEURONSPI_CRC16TABLE[NEURONSPI_CRC16TABLE_LEN] = {
+    0,  1408,  3968,  2560,  7040,  7680,  5120,  4480, 13184, 13824, 15360,
+14720, 10240, 11648, 10112,  8704, 25472, 26112, 27648, 27008, 30720, 32128,
+30592, 29184, 20480, 21888, 24448, 23040, 19328, 19968, 17408, 16768, 50048,
+50688, 52224, 51584, 55296, 56704, 55168, 53760, 61440, 62848, 65408, 64000,
+60288, 60928, 58368, 57728, 40960, 42368, 44928, 43520, 48000, 48640, 46080,
+45440, 37760, 38400, 39936, 39296, 34816, 36224, 34688, 33280, 33665, 34305,
+35841, 35201, 38913, 40321, 38785, 37377, 45057, 46465, 49025, 47617, 43905,
+44545, 41985, 41345, 57345, 58753, 61313, 59905, 64385, 65025, 62465, 61825,
+54145, 54785, 56321, 55681, 51201, 52609, 51073, 49665, 16385, 17793, 20353,
+18945, 23425, 24065, 21505, 20865, 29569, 30209, 31745, 31105, 26625, 28033,
+26497, 25089,  9089,  9729, 11265, 10625, 14337, 15745, 14209, 12801,  4097,
+ 5505,  8065,  6657,  2945,  3585,  1025,   385,   899,  1539,  3075,  2435,
+ 6147,  7555,  6019,  4611, 12291, 13699, 16259, 14851, 11139, 11779,  9219,
+ 8579, 24579, 25987, 28547, 27139, 31619, 32259, 29699, 29059, 21379, 22019,
+23555, 22915, 18435, 19843, 18307, 16899, 49155, 50563, 53123, 51715, 56195,
+56835, 54275, 53635, 62339, 62979, 64515, 63875, 59395, 60803, 59267, 57859,
+41859, 42499, 44035, 43395, 47107, 48515, 46979, 45571, 36867, 38275, 40835,
+39427, 35715, 36355, 33795, 33155, 32770, 34178, 36738, 35330, 39810, 40450,
+37890, 37250, 45954, 46594, 48130, 47490, 43010, 44418, 42882, 41474, 58242,
+58882, 60418, 59778, 63490, 64898, 63362, 61954, 53250, 54658, 57218, 55810,
+52098, 52738, 50178, 49538, 17282, 17922, 19458, 18818, 22530, 23938, 22402,
+20994, 28674, 30082, 32642, 31234, 27522, 28162, 25602, 24962,  8194,  9602,
+12162, 10754, 15234, 15874, 13314, 12674,  4994,  5634,  7170,  6530,  2050,
+ 3458,  1922,   514
+};
+
+static const struct of_device_id neuronspi_id_match[] = {
+		{.compatible = "unipi,neuron"},
+		{.compatible = "unipi,axon"},
+		{.compatible = NEURON_DEVICE_NAME},
+		{}
+};
+
+/***************
+ * Definitions *
+ ***************/
+
+#define NEURON_INT_RX_NOT_EMPTY 			0x1
+#define NEURON_INT_TX_FINISHED  			0x2
+#define NEURON_INT_RX_MODBUS    			0x4
+#define NEURON_INT_DI_CHANGED   			0x8
+#define NEURON_INT_ID_MASK      			0x0f
+#define NEURON_INT_NO_INT_BIT   			0x0f
+
+#define NEURONSPI_RECONF_MD					(1 << 0)
+#define NEURONSPI_RECONF_IER				(1 << 1)
+#define NEURONSPI_RECONF_RS485				(1 << 2)
+
+//#define MODBUS_FIRST_DATA_BYTE				10
+
+#define MODBUS_MAX_READ_BITS                2000
+#define MODBUS_MAX_WRITE_BITS               1968
+#define MODBUS_MAX_READ_REGISTERS           125
+#define MODBUS_MAX_WRITE_REGISTERS          123
+#define MODBUS_MAX_WR_WRITE_REGISTERS       121
+#define MODBUS_MAX_WR_READ_REGISTERS        125
+
+#define UNIPISPI_OP_MODE_SEND_HEADER        0x1
+#define UNIPISPI_OP_MODE_DO_CRC             0x2
+#define UNIPISPI_OP_MODE_HAVE_CRC_SPACE     0x4
+
+/*************************
+ * Function Declarations *
+ *************************/
+
+s32 neuronspi_spi_uart_write(struct spi_device *spi, u8 *send_buf, int length, u8 uart_index);
+void neuronspi_spi_uart_read(struct spi_device* spi_dev, u8 *recv_buf, s32 len, u8 uart_index);
+int unipispi_modbus_read_register(struct spi_device* spi_dev, u16 reg, u16* value);
+int unipispi_modbus_read_u32(struct spi_device* spi_dev, u16 reg, u32* value);
+int unipispi_modbus_read_many(struct spi_device* spi_dev, u16 reg, u16* value, int register_count);
+int unipispi_modbus_write_register(struct spi_device* spi_dev, u16 reg, u16 value);
+int unipispi_modbus_write_u32(struct spi_device* spi_dev, u16 reg, u32 value);
+int unipispi_modbus_write_many(struct spi_device* spi_dev, u16 reg, u16* value, int register_count);
+int unipispi_modbus_write_coil(struct spi_device* spi_dev, u16 coil, int value);
+int unipi_spi_write_str(struct spi_device* spi, struct neuronspi_port* port, int length);
+int unipi_spi_get_tx_fifo(struct spi_device* spi, struct neuronspi_port* port);
+
+void neuronspi_enable_uart_interrupt(struct neuronspi_port* n_port);
+void neuronspi_uart_flush_proc(struct kthread_work *ws);
+
+/***********************
+ * Function structures *
+ ***********************/
+
+// Host driver struct
+extern struct spi_driver neuronspi_spi_driver;
+
+extern struct mutex unipi_inv_speed_mutex;
+
+static const struct regmap_bus neuronspi_regmap_bus =
+{
+	.fast_io 					= 0,
+	.write 						= neuronspi_regmap_hw_write,
+	.gather_write 				= neuronspi_regmap_hw_gather_write,
+	.reg_write					= neuronspi_regmap_hw_reg_write,
+	.read						= neuronspi_regmap_hw_read,
+	.reg_read					= neuronspi_regmap_hw_reg_read,
+	.reg_format_endian_default  = REGMAP_ENDIAN_NATIVE,
+	.val_format_endian_default  = REGMAP_ENDIAN_NATIVE,
+	.max_raw_read				= 200,								// CRC and other overhead not included
+	.max_raw_write				= 200,								// CRC and other overhead not included
+};
+
+static const struct regmap_config neuronspi_regmap_config_default =
+{
+		.name 					= "UniPiSPI Regmap",
+		.reg_bits				= 16,
+		.reg_stride				= 0,
+		.pad_bits				= 0,
+		.val_bits				= 16,
+		.max_register			= 65535,
+		.cache_type				= REGCACHE_RBTREE,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,20,6)
+		.use_single_read			= 0,
+		.use_single_write			= 0,
+#else
+		.use_single_rw			= 0,
+#endif
+		.can_multi_write		= 1,
+};
+
+
+// These defines need to be at the end
+#define to_neuronspi_uart_data(p,e)  ((container_of((p), struct neuronspi_uart_data, e)))
+#define to_neuronspi_port(p,e)	((container_of((p), struct neuronspi_port, e)))
+#define to_led_driver(p,e)	((container_of((p), struct neuronspi_led_driver, e)))
+#define to_uart_port(p,e)	((container_of((p), struct uart_port, e)))
+
+
+/*********************
+ * In-line Functions *
+ *********************/
+
+static __always_inline u16 neuronspi_spi_crc(u8* inputstring, s32 length, u16 initval)
+{
+    s32 i;
+    u16 result = initval;
+    for (i=0; i<length; i++) {
+        result = (result >> 8) ^ NEURONSPI_CRC16TABLE[(result ^ inputstring[i]) & 0xff];
+    }
+    return result;
+}
+
+static __always_inline int neuronspi_frequency_by_model(u16 model)
+{
+    int i;
+    for (i = 0; i < NEURONSPI_FREQUENCY_LEN; i++) {
+        if ((NEURONSPI_FREQUENCY_MAP[i].mask & model) == NEURONSPI_FREQUENCY_MAP[i].model) 
+			return NEURONSPI_FREQUENCY_MAP[i].frequency;
+    }
+	return NEURONSPI_COMMON_FREQ;
+/*
+    for (i = 0; i < NEURONSPI_SLOWER_MODELS_LEN; i++) {
+        if (NEURONSPI_SLOWER_MODELS[i] == model) return 1;
+    }
+    return 0;
+*/
+}
+
+static __always_inline int neuronspi_is_noirq_model(u16 model)
+{
+    int i;
+    for (i = 0; i < NEURONSPI_NO_INTERRUPT_MODELS_LEN; i++) {
+        if (NEURONSPI_NO_INTERRUPT_MODELS[i] == model) return 1;
+    }
+    return 0;
+}
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_SPI_H_ */
diff --git a/drivers/unipi/unipi_sysfs.c b/drivers/unipi/unipi_sysfs.c
new file mode 100644
index 000000000000..f34b26927224
--- /dev/null
+++ b/drivers/unipi/unipi_sysfs.c
@@ -0,0 +1,1367 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_sysfs.h"
+#include "unipi_spi.h"
+#include "unipi_platform.h"
+
+/*********************
+ * Data Declarations *
+ *********************/
+
+int unipi_use_custom_speed = 0;
+u32 unipi_custom_speed_value = NEURONSPI_DEFAULT_SYSFS_SPEED;
+
+/************************
+ * Static Functions *
+ ************************/
+
+static ssize_t neuronspi_show_model(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	if (neuronspi_model_id != -1) {
+		ret = scnprintf(buf, 255, "%s\n", NEURONSPI_MODELTABLE[neuronspi_model_id].model_name);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_show_sysfs_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	mutex_lock(&unipi_inv_speed_mutex);
+	ret = scnprintf(buf, 255, "%d Hz\n", unipi_custom_speed_value);
+	mutex_unlock(&unipi_inv_speed_mutex);
+	return ret;
+}
+
+static ssize_t neuronspi_store_sysfs_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (val == NEURONSPI_DEFAULT_SYSFS_SPEED) {
+		unipi_use_custom_speed = 0;
+		mutex_lock(&unipi_inv_speed_mutex);
+		unipi_custom_speed_value = 50;
+		mutex_unlock(&unipi_inv_speed_mutex);
+	} else if (val > 0) {
+		unipi_use_custom_speed = 1;
+		mutex_lock(&unipi_inv_speed_mutex);
+		unipi_custom_speed_value = val > 1000 ? 1000 : val;
+		mutex_unlock(&unipi_inv_speed_mutex);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_show_driver_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+#ifdef NEURONSPI_MAJOR_VERSIONSTRING
+	ret = scnprintf(buf, 255, "%s\n", NEURONSPI_MAJOR_VERSIONSTRING);
+#else
+	ret = scnprintf(buf, 255, "%s\n", "Unspecified Driver Version");
+#endif
+	return ret;
+}
+
+static ssize_t neuronspi_show_eeprom(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	if (neuronspi_model_id != -1) {
+		ret = scnprintf(buf, 255, "%s\n", NEURONSPI_MODELTABLE[neuronspi_model_id].eeprom_name);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_show_serial(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val[2] = {0, 0};
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->sys_serial_num, val);
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->sys_serial_num + 1, &(val[1]));
+		ret = scnprintf(buf, 255, "%d\n", val[0]);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_show_hw_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->sys_hw_ver, &val);
+		ret = scnprintf(buf, 255, "%x.%x\n", (val & 0xF0) >> 4, val & 0xF);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_show_hw_flash_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->sys_hw_flash_ver, &val);
+		ret = scnprintf(buf, 255, "%x.%x\n", (val & 0xF0) >> 4, val & 0xF);
+	}
+	return ret;
+}
+
+
+static ssize_t neuronspi_spi_show_fw_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->sys_sw_ver, &val);
+		ret = scnprintf(buf, 255, "%x.%d\n", (val & 0xF00) >> 8, (int)(val & 0xFF));
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_show_uart_queue_length(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->regstart_table->uart_queue_reg) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->uart_queue_reg, &val);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_show_uart_config(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->regstart_table->uart_conf_reg) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->uart_conf_reg, &val);
+		ret = scnprintf(buf, 255, "%x\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_store_uart_config(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->regstart_table->uart_conf_reg) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->uart_conf_reg, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_show_uart_timeout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u16 value = 0;
+	struct spi_device *spi;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+#if NEURONSPI_DETAILED_DEBUG > 0
+	printk(KERN_INFO "UNIPISPI: Index %d\n", n_spi->neuron_index);
+#endif
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->regstart_table->uart_conf_reg) {
+        spi = neuronspi_s_dev[n_spi->neuron_index];
+        if (unipispi_modbus_read_register(spi, 504, &value) == 0) {
+             ret = scnprintf(buf, 255, "%d\n", value);
+        }
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_store_uart_timeout(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct spi_device *spi;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+#if NEURONSPI_DETAILED_DEBUG > 0
+	printk(KERN_INFO "UNIPISPI: Index %d\n", n_spi->neuron_index);
+#endif
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->regstart_table->uart_conf_reg) {
+        spi = neuronspi_s_dev[n_spi->neuron_index];
+        unipispi_modbus_write_register(spi, 504, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_show_watchdog_status(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->wd_val_reg, &val);
+		ret = scnprintf(buf, 255, "%x\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_store_watchdog_status(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->wd_val_reg, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_show_watchdog_timeout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->wd_timeout_reg, &val);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_store_watchdog_timeout(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+        if (val > 0xffff) val = 0xffff;
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->wd_timeout_reg, val);
+	}
+err_end:
+	return count;
+}
+
+
+static ssize_t neuronspi_spi_gpio_show_pwm_presc(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->do_pwm_ps_reg, &val);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_store_pwm_presc(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->do_pwm_ps_reg, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_show_pwm_freq(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->do_pwm_c_reg, &val);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_store_pwm_freq(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->do_pwm_c_reg, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_show_pwm_cycle(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->do_pwm_reg + n_do->io_index, &val);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_store_pwm_cycle(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->do_pwm_reg + n_do->io_index, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_di_show_counter(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	u32 val_upper = 0;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_counter_reg + (2 * n_di->io_index), &val);
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_counter_reg + 1 + (2 * n_di->io_index), &val_upper);
+		val |= val_upper << 16;
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_di_store_counter(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->di_counter_reg + (2 * n_di->io_index), val & 0xFFFF);
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->di_counter_reg + 1 + (2 * n_di->io_index), val >> 16);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_di_show_debounce(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	u32 val = 0;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->features && n_spi->features->di_count > n_di->io_index) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_deboun_reg + n_di->io_index, &val);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_di_store_debounce(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->features && n_spi->features->di_count > n_di->io_index) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->di_deboun_reg + n_di->io_index, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_di_show_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	int val;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->di_count > n_di->io_index) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_val_reg + (n_di->io_index / 16), &val);
+		val = val & (0x1 << (n_di->io_index % 16)) ? 1:0;
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_do_show_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	int val;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->do_count > n_do->io_index) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->do_val_reg + (n_do->io_index / 16), &val);
+		val = val & (0x1 << (n_do->io_index % 16)) ? 1:0;
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_do_store_value(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	int inp = 0;
+	unsigned int val;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	err = kstrtoint(buf, 0, &inp);
+	if (err < 0) goto err_end;
+	if (inp > 1 || inp < 0) {
+		goto err_end;
+	}
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->do_count > n_do->io_index) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->do_val_reg + (n_do->io_index / 16), &val);
+		val &= ~(0x1 << (n_do->io_index % 16));
+		val |= inp << (n_do->io_index % 16);
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->do_val_reg + (n_do->io_index / 16), val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_ro_show_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	int val;
+	struct neuronspi_gpio_port *n_ro;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_ro = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_ro->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->ro_count > n_ro->io_index) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->ro_val_reg + (n_ro->io_index / 16), &val);
+		val &= 0x1 << (n_ro->io_index % 16);
+		val = val >> (n_ro->io_index % 16);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_ro_store_value(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	int inp = 0;
+	unsigned int val;
+	struct neuronspi_gpio_port *n_ro;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_ro = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_ro->spi);
+	err = kstrtoint(buf, 0, &inp);
+	if (err < 0) goto err_end;
+	if (inp > 1 || inp < 0) {
+		goto err_end;
+	}
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->ro_count > n_ro->io_index) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->ro_val_reg + (n_ro->io_index / 16), &val);
+		val &= ~(0x1 << (n_ro->io_index % 16));
+		val |= inp << (n_ro->io_index % 16);
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->ro_val_reg + (n_ro->io_index / 16), val);
+	}
+err_end:
+	return count;
+}
+
+
+static ssize_t neuronspi_spi_gpio_show_ds_enable(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	int val;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->ds_count) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_direct_reg + (n_di->io_index / 16), &val);
+		val &= 0x1 << (n_di->io_index % 16);
+		val = val >> (n_di->io_index % 16);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_ds_toggle(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	int val;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->ds_count) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_toggle_reg + (n_di->io_index / 16), &val);
+		val &= 0x1 << (n_di->io_index % 16);
+		val = val >> (n_di->io_index % 16);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_ds_polarity(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	int val;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi && n_spi->combination_id != -1 && n_spi->features && n_spi->features->ds_count) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_polar_reg + (n_di->io_index / 16), &val);
+		val &= 0x1 << (n_di->io_index % 16);
+		val = val >> (n_di->io_index % 16);
+		ret = scnprintf(buf, 255, "%d\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_store_ds_enable(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	int inp = 0;
+	unsigned int val;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	err = kstrtoint(buf, 0, &inp);
+	if (err < 0) goto err_end;
+	if (inp > 1 || inp < 0) {
+		goto err_end;
+	}
+	if (n_spi && n_spi->combination_id != -1 && n_spi->features && n_spi->features->ds_count) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_direct_reg + (n_di->io_index / 16), &val);
+		val &= ~(0x1 << (n_di->io_index % 16));
+		val |= inp << (n_di->io_index % 16);
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->di_direct_reg + (n_di->io_index / 16), val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_store_ds_toggle(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	int inp = 0;
+	unsigned int val;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	err = kstrtoint(buf, 0, &inp);
+	if (err < 0) goto err_end;
+	if (inp > 1 || inp < 0) {
+		goto err_end;
+	}
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->ds_count) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_toggle_reg + (n_di->io_index / 16), &val);
+		val &= ~(0x1 << (n_di->io_index % 16));
+		val |= inp << (n_di->io_index % 16);
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->di_toggle_reg + (n_di->io_index / 16), val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_gpio_store_ds_polarity(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	int inp = 0;
+	unsigned int val;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	err = kstrtoint(buf, 0, &inp);
+	if (err < 0) goto err_end;
+	if (inp > 1 || inp < 0) {
+		goto err_end;
+	}
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->features && n_spi->features->ds_count) {
+		regmap_read(n_spi->reg_map, n_spi->regstart_table->di_polar_reg + (n_di->io_index / 16), &val);
+		val &= ~(0x1 << (n_di->io_index % 16));
+		val |= inp << (n_di->io_index % 16);
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->di_polar_reg + (n_di->io_index / 16), val);
+	}
+err_end:
+	return count;
+}
+
+
+static ssize_t neuronspi_spi_show_register(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/*u8 *inp_buf, *outp_buf;
+	int read_length;*/
+	ssize_t ret = 0;
+	u16 val = 0;
+    u16 reg;
+	unsigned long flags;
+	struct spi_device *spi;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	spi = neuronspi_s_dev[n_spi->neuron_index];
+	if (n_spi && n_spi->reg_map) {
+		spin_lock_irqsave(&n_spi->sysfs_regmap_lock, flags);
+        reg = n_spi->sysfs_register_target;
+		/*read_length = neuronspi_spi_compose_single_register_read(n_spi->sysfs_register_target, &inp_buf, &outp_buf);*/
+		spin_unlock_irqrestore(&n_spi->sysfs_regmap_lock, flags);
+        if (unipispi_modbus_read_register(spi, reg, &val)==0) {
+            ret = scnprintf(buf, 255, "%x\n", (u32)val);
+        }
+        /*neuronspi___spi_send_message(spi, inp_buf, outp_buf, read_length, n_spi->ideal_frequency, 125, 1, 0);
+		memcpy(&val, &outp_buf[NEURONSPI_HEADER_LENGTH], sizeof(u16));
+		ret = scnprintf(buf, 255, "%x\n", (u32)val); */
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_store_register_value(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	/*u8 *inp_buf, *outp_buf;
+	int write_length;*/
+	ssize_t err = 0;
+	unsigned int val = 0;
+    u16 reg;
+	unsigned long flags;
+	struct spi_device *spi;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	spi = neuronspi_s_dev[n_spi->neuron_index];
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->reg_map && (val < 65536) && (val >= 0)) {
+		spin_lock_irqsave(&n_spi->sysfs_regmap_lock, flags);
+        reg = n_spi->sysfs_register_target;
+		//write_length = neuronspi_spi_compose_single_register_read(n_spi->sysfs_register_target, &inp_buf, &outp_buf);
+		spin_unlock_irqrestore(&n_spi->sysfs_regmap_lock, flags);
+        unipispi_modbus_write_register(spi, reg, val);
+		//neuronspi___spi_send_message(spi, inp_buf, outp_buf, write_length, n_spi->ideal_frequency, 125, 1, 0);
+	}
+err_end:
+	return count;
+}
+
+
+static ssize_t neuronspi_spi_store_register(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	unsigned long flags;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->reg_map && val < 65536) {
+		spin_lock_irqsave(&n_spi->sysfs_regmap_lock, flags);
+		n_spi->sysfs_register_target = val;
+		spin_unlock_irqrestore(&n_spi->sysfs_regmap_lock, flags);
+	}
+err_end:
+	return count;
+}
+
+
+
+static ssize_t neuronspi_show_regmap(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	unsigned int target = 0;
+	u32 val = 0;
+	unsigned long flags;
+	//struct spi_device *spi;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	//spi = neuronspi_s_dev[n_spi->neuron_index];
+	if (n_spi && n_spi->reg_map) {
+		spin_lock_irqsave(&n_spi->sysfs_regmap_lock, flags);
+		target = n_spi->sysfs_regmap_target;
+		spin_unlock_irqrestore(&n_spi->sysfs_regmap_lock, flags);
+		regmap_read(n_spi->reg_map, target, &val);
+		ret = scnprintf(buf, 255, "%x\n", val);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_store_regmap(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	unsigned long flags;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->reg_map && val < 65536) {
+		spin_lock_irqsave(&n_spi->sysfs_regmap_lock, flags);
+		n_spi->sysfs_regmap_target = val;
+		spin_unlock_irqrestore(&n_spi->sysfs_regmap_lock, flags);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_store_regmap_value(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	unsigned int target = 0;
+	unsigned long flags;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->reg_map && val < 65536) {
+		spin_lock_irqsave(&n_spi->sysfs_regmap_lock, flags);
+		target = n_spi->sysfs_regmap_target;
+		spin_unlock_irqrestore(&n_spi->sysfs_regmap_lock, flags);
+		regmap_write(n_spi->reg_map, n_spi->sysfs_regmap_target, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_spi_store_reboot(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct spi_device *spi;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+#if NEURONSPI_DETAILED_DEBUG > 0
+	printk(KERN_INFO "UNIPISPI: Index %d\n", n_spi->neuron_index);
+#endif
+	err = kstrtouint(buf, 0, &val);
+	if (err >= 0) {
+		if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+	        spi = neuronspi_s_dev[n_spi->neuron_index];
+	        unipispi_modbus_write_coil(spi, 1002, val);
+		}
+	}
+	return count;
+}
+
+static ssize_t neuronspi_spi_store_save_initial_state(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct spi_device *spi;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+#if NEURONSPI_DETAILED_DEBUG > 0
+	printk(KERN_INFO "UNIPISPI: Index %d\n", n_spi->neuron_index);
+#endif
+	err = kstrtouint(buf, 0, &val);
+	if (err >= 0) {
+		if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->regstart_table->uart_conf_reg) {
+	        spi = neuronspi_s_dev[n_spi->neuron_index];
+	        unipispi_modbus_write_coil(spi, 1003, val);
+		}
+	}
+	return count;
+}
+
+static ssize_t neuronspi_spi_show_board(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi->combination_id != 0xFF && n_spi->combination_id < NEURONSPI_BOARDTABLE_LEN) {
+		ret = scnprintf(buf, 255, "%s\n", NEURONSPI_BOARDTABLE[n_spi->combination_id].definition->combination_name);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_show_lboard_id(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi->combination_id != 0xFF && n_spi->combination_id < NEURONSPI_BOARDTABLE_LEN) {
+		ret = scnprintf(buf, 255, "%d\n", NEURONSPI_BOARDTABLE[n_spi->combination_id].definition->lower_board_id);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_show_uboard_id(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct platform_device *plat = to_platform_device(dev);
+    struct neuronspi_board_device_data *board_device_data = platform_get_drvdata(plat);
+	struct neuronspi_driver_data *n_spi = board_device_data->n_spi;
+	if (n_spi->combination_id != 0xFF && n_spi->combination_id < NEURONSPI_BOARDTABLE_LEN) {
+		ret = scnprintf(buf, 255, "%d\n", NEURONSPI_BOARDTABLE[n_spi->combination_id].definition->upper_board_id);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_do_prefix(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	if (n_spi->features && n_spi->features->do_count > 0) {
+		ret = scnprintf(buf, 255, "%s_%d\n", n_do->gpio_c.label, n_spi->neuron_index + 1);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_di_prefix(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi->features && n_spi->features->di_count > 0) {
+		ret = scnprintf(buf, 255, "%s_%d\n", n_di->gpio_c.label, n_spi->neuron_index + 1);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_ro_prefix(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_ro;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_ro = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_ro->spi);
+	if (n_spi->features && n_spi->features->ro_count > 0) {
+		ret = scnprintf(buf, 255, "%s_%d\n", n_ro->gpio_c.label, n_spi->neuron_index + 1);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_do_base(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	if (n_spi->features && n_spi->features->do_count > 0) {
+		ret = scnprintf(buf, 255, "%d\n", n_do->gpio_c.base);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_di_base(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi->features && n_spi->features->di_count > 0) {
+		ret = scnprintf(buf, 255, "%d\n", n_di->gpio_c.base);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_ro_base(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_ro;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_ro = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_ro->spi);
+	if (n_spi->features && n_spi->features->ro_count > 0 ) {
+		ret = scnprintf(buf, 255, "%d\n", n_ro->gpio_c.base);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_do_count(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_do;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_do = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_do->spi);
+	if (n_spi->features && n_spi->features->do_count > 0) {
+		ret = scnprintf(buf, 255, "%d\n", n_do->gpio_c.ngpio);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_di_count(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_di;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_di = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_di->spi);
+	if (n_spi->features && n_spi->features->di_count > 0) {
+		ret = scnprintf(buf, 255, "%d\n", n_di->gpio_c.ngpio);
+	}
+	return ret;
+}
+
+static ssize_t neuronspi_spi_gpio_show_ro_count(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct neuronspi_gpio_port *n_ro;
+	struct neuronspi_driver_data *n_spi;
+	struct platform_device *plat = to_platform_device(dev);
+	n_ro = platform_get_drvdata(plat);
+	n_spi = spi_get_drvdata(n_ro->spi);
+	if (n_spi->features && n_spi->features->ro_count > 0 ) {
+		ret = scnprintf(buf, 255, "%d\n", n_ro->gpio_c.ngpio);
+	}
+	return ret;
+}
+
+
+static ssize_t neuronspi_iio_show_stm_ai_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ai_mode_reg + ai_data->index, &val);
+	ret = scnprintf(buf, 255, "%d\n", val);
+	return ret;
+}
+
+static ssize_t neuronspi_iio_store_stm_ai_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->stm_ai_mode_reg + ai_data->index, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_iio_show_stm_ao_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->stm_ao_mode_reg + ao_data->index, &val);
+	ret = scnprintf(buf, 255, "%d\n", val);
+	return ret;
+}
+
+static ssize_t neuronspi_iio_store_stm_ao_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != -1 && n_spi->reg_map) {
+#if NEURONSPI_DETAILED_DEBUG > 0
+		printk(KERN_INFO "UNIPISPI: Mode register %d set to %x", n_spi->regstart_table->stm_ao_mode_reg + ao_data->index, val);
+#endif
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->stm_ao_mode_reg + ao_data->index, val);
+	}
+err_end:
+	return count;
+}
+
+static ssize_t neuronspi_iio_show_external_ai_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ai_mode_reg + ai_data->index, &val);
+	ret = scnprintf(buf, 255, "%d\n", val);
+	return ret;
+}
+
+static ssize_t neuronspi_iio_store_external_ai_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ai_data = iio_priv(indio_dev);
+	struct spi_device *spi = ai_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->sec_ai_mode_reg + ai_data->index, val);
+	}
+err_end:
+	return count;
+}
+/*
+static ssize_t neuronspi_iio_show_external_ao_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	regmap_read(n_spi->reg_map, n_spi->regstart_table->sec_ao_mode_reg + ao_data->index, &val);
+	ret = scnprintf(buf, 255, "%d\n", val);
+	return ret;
+}
+
+static ssize_t neuronspi_iio_store_external_ao_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	ssize_t err = 0;
+	unsigned int val = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct neuronspi_analog_data *ao_data = iio_priv(indio_dev);
+	struct spi_device *spi = ao_data->parent;
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+	err = kstrtouint(buf, 0, &val);
+	if (err < 0) goto err_end;
+	if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map) {
+		regmap_write(n_spi->reg_map, n_spi->regstart_table->sec_ao_mode_reg + ao_data->index, val);
+	}
+err_end:
+	return count;
+}
+*/
+
+/**********************************
+ * Function Structure Definitions *
+ **********************************/
+
+static DEVICE_ATTR(model_name, 0444, neuronspi_show_model, NULL);
+static DEVICE_ATTR(sys_reading_freq, 0660, neuronspi_show_sysfs_speed, neuronspi_store_sysfs_speed);
+static DEVICE_ATTR(sys_eeprom_name, 0444, neuronspi_show_eeprom, NULL);
+static DEVICE_ATTR(driver_version, 0444, neuronspi_show_driver_version, NULL);
+static DEVICE_ATTR(register_read, 0660, neuronspi_spi_show_register, neuronspi_spi_store_register);
+static DEVICE_ATTR(register_set, 0220, NULL, neuronspi_spi_store_register_value);
+static DEVICE_ATTR(regmap_read, 0660, neuronspi_show_regmap, neuronspi_store_regmap);
+static DEVICE_ATTR(regmap_set, 0220, NULL, neuronspi_store_regmap_value);
+static DEVICE_ATTR(reboot_group, 0220, NULL, neuronspi_spi_store_reboot);
+static DEVICE_ATTR(save_initial_state, 0220, NULL, neuronspi_spi_store_save_initial_state);
+static DEVICE_ATTR(sys_board_serial, 0440, neuronspi_spi_show_serial, NULL);
+static DEVICE_ATTR(sys_board_name, 0444, neuronspi_spi_show_board, NULL);
+static DEVICE_ATTR(sys_primary_major_id, 0444, neuronspi_spi_show_lboard_id, NULL);
+static DEVICE_ATTR(sys_secondary_major_id, 0444, neuronspi_spi_show_uboard_id, NULL);
+static DEVICE_ATTR(sys_primary_minor_id, 0444, neuronspi_spi_show_hw_version, NULL);
+static DEVICE_ATTR(sys_secondary_minor_id, 0444, neuronspi_spi_show_hw_flash_version, NULL);
+static DEVICE_ATTR(firmware_version, 0444, neuronspi_spi_show_fw_version, NULL);
+static DEVICE_ATTR(watchdog_status, 0660, neuronspi_spi_show_watchdog_status, neuronspi_spi_store_watchdog_status);
+static DEVICE_ATTR(watchdog_timeout, 0660, neuronspi_spi_show_watchdog_timeout, neuronspi_spi_store_watchdog_timeout);
+static DEVICE_ATTR(sys_gpio_do_count, 0440, neuronspi_spi_gpio_show_do_count, NULL);
+static DEVICE_ATTR(sys_gpio_do_prefix, 0440, neuronspi_spi_gpio_show_do_prefix, NULL);
+static DEVICE_ATTR(sys_gpio_do_base, 0440, neuronspi_spi_gpio_show_do_base, NULL);
+static DEVICE_ATTR(sys_gpio_di_count, 0440, neuronspi_spi_gpio_show_di_count, NULL);
+static DEVICE_ATTR(sys_gpio_di_prefix, 0440, neuronspi_spi_gpio_show_di_prefix, NULL);
+static DEVICE_ATTR(ro_value, 0660, neuronspi_spi_gpio_ro_show_value, neuronspi_spi_gpio_ro_store_value);
+static DEVICE_ATTR(do_value, 0660, neuronspi_spi_gpio_do_show_value, neuronspi_spi_gpio_do_store_value);
+static DEVICE_ATTR(counter, 0660, neuronspi_spi_gpio_di_show_counter, neuronspi_spi_gpio_di_store_counter);
+static DEVICE_ATTR(debounce, 0660, neuronspi_spi_gpio_di_show_debounce, neuronspi_spi_gpio_di_store_debounce);
+static DEVICE_ATTR(di_value, 0440, neuronspi_spi_gpio_di_show_value, NULL);
+static DEVICE_ATTR(direct_switch_enable, 0660, neuronspi_spi_gpio_show_ds_enable, neuronspi_spi_gpio_store_ds_enable);
+static DEVICE_ATTR(direct_switch_toggle, 0660, neuronspi_spi_gpio_show_ds_toggle, neuronspi_spi_gpio_store_ds_toggle);
+static DEVICE_ATTR(direct_switch_polarity, 0660, neuronspi_spi_gpio_show_ds_polarity, neuronspi_spi_gpio_store_ds_polarity);
+static DEVICE_ATTR(pwm_frequency_cycle, 0660, neuronspi_spi_gpio_show_pwm_freq, neuronspi_spi_gpio_store_pwm_freq);
+static DEVICE_ATTR(pwm_prescale, 0660, neuronspi_spi_gpio_show_pwm_presc, neuronspi_spi_gpio_store_pwm_presc);
+static DEVICE_ATTR(pwm_duty_cycle, 0660, neuronspi_spi_gpio_show_pwm_cycle, neuronspi_spi_gpio_store_pwm_cycle);
+static DEVICE_ATTR(uart_queue_length, 0440, neuronspi_spi_show_uart_queue_length, NULL);
+static DEVICE_ATTR(uart_config, 0664, neuronspi_spi_show_uart_config, neuronspi_spi_store_uart_config);
+static DEVICE_ATTR(uart_timeout, 0664, neuronspi_spi_show_uart_timeout, neuronspi_spi_store_uart_timeout);
+static DEVICE_ATTR(sys_gpio_di_base, 0440, neuronspi_spi_gpio_show_di_base, NULL);
+static DEVICE_ATTR(sys_gpio_ro_count, 0440, neuronspi_spi_gpio_show_ro_count, NULL);
+static DEVICE_ATTR(sys_gpio_ro_prefix, 0440, neuronspi_spi_gpio_show_ro_prefix, NULL);
+static DEVICE_ATTR(sys_gpio_ro_base, 0440, neuronspi_spi_gpio_show_ro_base, NULL);
+static DEVICE_ATTR(mode_ai_voltage_current, 0660, neuronspi_iio_show_stm_ai_mode, neuronspi_iio_store_stm_ai_mode);
+static DEVICE_ATTR(mode_ao_voltage_current_resistance, 0660, neuronspi_iio_show_stm_ao_mode, neuronspi_iio_store_stm_ao_mode);
+static DEVICE_ATTR(mode_ai_voltage_current_resistance, 0660, neuronspi_iio_show_external_ai_mode, neuronspi_iio_store_external_ai_mode);
+
+static struct attribute *neuron_plc_attrs[] = {
+		&dev_attr_model_name.attr,
+		&dev_attr_sys_reading_freq.attr,
+		&dev_attr_sys_eeprom_name.attr,
+		&dev_attr_driver_version.attr,
+		NULL,
+};
+
+static struct attribute *neuron_board_attrs[] = {
+		&dev_attr_sys_board_name.attr,
+		&dev_attr_sys_primary_major_id.attr,
+		&dev_attr_sys_secondary_major_id.attr,
+		&dev_attr_sys_primary_minor_id.attr,
+		&dev_attr_sys_secondary_minor_id.attr,
+		&dev_attr_firmware_version.attr,
+		&dev_attr_watchdog_status.attr,
+		&dev_attr_watchdog_timeout.attr,
+		&dev_attr_sys_board_serial.attr,
+		&dev_attr_uart_queue_length.attr,
+		&dev_attr_uart_config.attr,
+		&dev_attr_uart_timeout.attr,
+		&dev_attr_register_read.attr,
+		&dev_attr_register_set.attr,
+		&dev_attr_regmap_read.attr,
+		&dev_attr_regmap_set.attr,
+		&dev_attr_reboot_group.attr,
+		&dev_attr_save_initial_state.attr,
+		NULL,
+};
+
+static struct attribute *neuron_gpio_di_attrs[] = {
+		&dev_attr_sys_gpio_di_count.attr,
+		&dev_attr_sys_gpio_di_prefix.attr,
+		&dev_attr_sys_gpio_di_base.attr,
+		&dev_attr_direct_switch_enable.attr,
+		&dev_attr_direct_switch_toggle.attr,
+		&dev_attr_direct_switch_polarity.attr,
+		&dev_attr_di_value.attr,
+		&dev_attr_counter.attr,
+		&dev_attr_debounce.attr,
+		NULL,
+};
+
+static struct attribute *neuron_gpio_do_attrs[] = {
+		&dev_attr_sys_gpio_do_count.attr,
+		&dev_attr_sys_gpio_do_prefix.attr,
+		&dev_attr_sys_gpio_do_base.attr,
+		&dev_attr_pwm_frequency_cycle.attr,
+		&dev_attr_pwm_prescale.attr,
+		&dev_attr_pwm_duty_cycle.attr,
+		&dev_attr_do_value.attr,
+		NULL,
+};
+
+static struct attribute *neuron_gpio_ro_attrs[] = {
+		&dev_attr_sys_gpio_ro_count.attr,
+		&dev_attr_sys_gpio_ro_prefix.attr,
+		&dev_attr_sys_gpio_ro_base.attr,
+		&dev_attr_ro_value.attr,
+		NULL,
+};
+
+static struct attribute *neuron_stm_ai_attrs[] = {
+		&dev_attr_mode_ai_voltage_current.attr,
+		NULL,
+};
+
+static struct attribute *neuron_stm_ao_attrs[] = {
+		&dev_attr_mode_ao_voltage_current_resistance.attr,
+		NULL,
+};
+
+static struct attribute *neuron_sec_ai_attrs[] = {
+		&dev_attr_mode_ai_voltage_current_resistance.attr,
+		NULL,
+};
+
+/*
+ * static struct attribute *neuron_sec_ao_attrs[] = {
+		&dev_attr_mode_ao_voltage.attr,
+		NULL,
+};
+*/
+
+static struct attribute_group neuron_plc_attr_group = {
+	.attrs = neuron_plc_attrs,
+};
+
+static struct attribute_group neuron_board_attr_group = {
+	.attrs = neuron_board_attrs,
+};
+
+static struct attribute_group neuron_gpio_di_attr_group = {
+	.attrs = neuron_gpio_di_attrs,
+};
+
+static struct attribute_group neuron_gpio_do_attr_group = {
+	.attrs = neuron_gpio_do_attrs,
+};
+
+static struct attribute_group neuron_gpio_ro_attr_group = {
+	.attrs = neuron_gpio_ro_attrs,
+};
+
+const struct attribute_group neuron_stm_ai_group = {
+	.attrs = neuron_stm_ai_attrs,
+};
+
+const struct attribute_group neuron_stm_ao_group = {
+	.attrs = neuron_stm_ao_attrs,
+};
+
+const struct attribute_group neuron_sec_ai_group = {
+	.attrs = neuron_sec_ai_attrs,
+};
+
+/*
+const struct attribute_group neuron_sec_ao_group = {
+	.attrs = neuron_sec_ao_attrs,
+};
+*/
+
+const struct attribute_group *neuron_plc_attr_groups[] = {
+	&neuron_plc_attr_group,
+	NULL,
+};
+
+const struct attribute_group *neuron_board_attr_groups[] = {
+	&neuron_board_attr_group,
+	NULL,
+};
+
+const struct attribute_group *neuron_gpio_di_attr_groups[] = {
+	&neuron_gpio_di_attr_group,
+	NULL,
+};
+
+const struct attribute_group *neuron_gpio_do_attr_groups[] = {
+	&neuron_gpio_do_attr_group,
+	NULL,
+};
+
+const struct attribute_group *neuron_gpio_ro_attr_groups[] = {
+	&neuron_gpio_ro_attr_group,
+	NULL,
+};
diff --git a/drivers/unipi/unipi_sysfs.h b/drivers/unipi/unipi_sysfs.h
new file mode 100644
index 000000000000..cef9f3e4ecda
--- /dev/null
+++ b/drivers/unipi/unipi_sysfs.h
@@ -0,0 +1,41 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_SYSFS_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_SYSFS_H_
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_common.h"
+#include "unipi_platform.h"
+
+#define NEURONSPI_DEFAULT_SYSFS_SPEED 50
+
+extern int unipi_use_custom_speed;
+extern u32 unipi_custom_speed_value;
+
+extern const struct attribute_group neuron_stm_ai_group;
+extern const struct attribute_group neuron_stm_ao_group;
+extern const struct attribute_group neuron_sec_ai_group;
+//extern const struct attribute_group neuron_sec_ao_group;
+
+extern const struct attribute_group *neuron_plc_attr_groups[];
+extern const struct attribute_group *neuron_board_attr_groups[];
+extern const struct attribute_group *neuron_gpio_di_attr_groups[];
+extern const struct attribute_group *neuron_gpio_do_attr_groups[];
+extern const struct attribute_group *neuron_gpio_ro_attr_groups[];
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_SYSFS_H_ */
diff --git a/drivers/unipi/unipi_tty.c b/drivers/unipi/unipi_tty.c
new file mode 100644
index 000000000000..76c01849ef50
--- /dev/null
+++ b/drivers/unipi/unipi_tty.c
@@ -0,0 +1,1117 @@
+/*
+ * Implements line discpline for using with Neuron/Axon.
+ * 
+ * Author: Miroslav Ondra <ondra@faster.cz>
+ *
+ * Derivated from n_tty.c --- implements the N_PROFIBUS line discipline.
+ *
+ * This code used to be in tty_io.c, but things are getting hairy
+ * enough that it made sense to split things off.  (The N_TTY
+ * processing has changed so much that it's hardly recognizable,
+ * anyway...)
+ *
+ * Note that the open routine for N_TTY is guaranteed never to return
+ * an error.  This is because Linux will fall back to setting a line
+ * to N_TTY if it can not switch to any other line discipline.
+ *
+ * Written by Theodore Ts'o, Copyright 1994.
+ *
+ * This file also contains code originally written by Linus Torvalds,
+ * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.
+ *
+ * This file may be redistributed under the terms of the GNU General Public
+ * License.
+ *
+ * Reduced memory usage for older ARM systems  - Russell King.
+ *
+ * 2000/01/20   Fixed SMP locking on put_tty_queue using bits of
+ *		the patch by Andrew J. Kroll <ag784@freenet.buffalo.edu>
+ *		who actually finally proved there really was a race.
+ *
+ * 2002/03/18   Implemented unipi_tty_wakeup to send SIGIO POLL_OUTs to
+ *		waiting writing processes-Sapan Bhatia <sapan@corewars.org>.
+ *		Also fixed a bug in BLOCKING mode where unipi_tty_write returns
+ *		EAGAIN
+ */
+
+#include <linux/types.h>
+#include <linux/major.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/timer.h>
+#include <linux/ctype.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/bitops.h>
+#include <linux/audit.h>
+#include <linux/file.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/ratelimit.h>
+#include <linux/vmalloc.h>
+#include <linux/version.h>
+
+#include "unipi_tty.h"
+
+// #undef UNIPI_TTY_TRACE
+#if NEURONSPI_DETAILED_DEBUG > 0
+# define unipi_tty_trace(f, args...)	trace_printk(f, ##args)
+#else
+# define unipi_tty_trace(f, args...)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
+
+
+/* number of characters left in xmit buffer before select has we have room */
+#define WAKEUP_CHARS 256
+
+/*
+ * This defines the low- and high-watermarks for throttling and
+ * unthrottling the TTY driver.  These watermarks are used for
+ * controlling the space in the read buffer.
+ */
+#define TTY_THRESHOLD_THROTTLE		128 /* now based on remaining room */
+#define TTY_THRESHOLD_UNTHROTTLE	128
+
+
+
+struct unipi_tty_data {
+	/* producer-published */
+	size_t read_head;
+	size_t commit_head;
+	//DECLARE_BITMAP(char_map, 256);
+
+	/* private to unipi_tty_receive_overrun (single-threaded) */
+	/* non-atomic */
+	bool no_room;
+
+	/* shared by producer and consumer */
+	char read_buf[N_TTY_BUF_SIZE];
+
+	/* consumer-published */
+	size_t read_tail;
+
+
+	struct mutex atomic_read_lock;
+	struct mutex output_lock;
+};
+
+static inline size_t read_cnt(struct unipi_tty_data *ldata)
+{
+	return ldata->read_head - ldata->read_tail;
+}
+
+static inline unsigned char read_buf(struct unipi_tty_data *ldata, size_t i)
+{
+	return ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+}
+
+static inline unsigned char *read_buf_addr(struct unipi_tty_data *ldata, size_t i)
+{
+	return &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+}
+
+
+/**
+ *	tty_throttle_safe	-	flow control
+ *	@tty: terminal
+ *
+ *	Similar to tty_throttle() but will only attempt throttle
+ *	if tty->flow_change is TTY_THROTTLE_SAFE. Prevents an accidental
+ *	throttle due to race conditions when throttling is conditional
+ *	on factors evaluated prior to throttling.
+ *
+ *	Returns 0 if tty is throttled (or was already throttled)
+ */
+
+int unipi_tty_throttle_safe(struct tty_struct *tty)
+{
+	int ret = 0;
+
+	mutex_lock(&tty->throttle_mutex);
+	if (!tty_throttled(tty)) {
+		if (tty->flow_change != TTY_THROTTLE_SAFE)
+			ret = 1;
+		else {
+			set_bit(TTY_THROTTLED, &tty->flags);
+			if (tty->ops->throttle)
+				tty->ops->throttle(tty);
+		}
+	}
+	mutex_unlock(&tty->throttle_mutex);
+
+	return ret;
+}
+
+/**
+ *	tty_unthrottle_safe	-	flow control
+ *	@tty: terminal
+ *
+ *	Similar to tty_unthrottle() but will only attempt unthrottle
+ *	if tty->flow_change is TTY_UNTHROTTLE_SAFE. Prevents an accidental
+ *	unthrottle due to race conditions when unthrottling is conditional
+ *	on factors evaluated prior to unthrottling.
+ *
+ *	Returns 0 if tty is unthrottled (or was already unthrottled)
+ */
+
+int unipi_tty_unthrottle_safe(struct tty_struct *tty)
+{
+	int ret = 0;
+
+	mutex_lock(&tty->throttle_mutex);
+	if (tty_throttled(tty)) {
+		if (tty->flow_change != TTY_UNTHROTTLE_SAFE)
+			ret = 1;
+		else {
+			clear_bit(TTY_THROTTLED, &tty->flags);
+			if (tty->ops->unthrottle)
+				tty->ops->unthrottle(tty);
+		}
+	}
+	mutex_unlock(&tty->throttle_mutex);
+
+	return ret;
+}
+
+
+/**
+ *	unipi_tty_kick_worker - start input worker (if required)
+ *	@tty: terminal
+ *
+ *	Re-schedules the flip buffer work if it may have stopped
+ *
+ *	Caller holds exclusive termios_rwsem
+ *	   or
+ *	unipi_tty_read()/consumer path:
+ *		holds non-exclusive termios_rwsem
+ */
+
+static void unipi_tty_kick_worker(struct tty_struct *tty)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+    struct tty_port *port = tty->port;
+
+	/* Did the input worker stop? Restart it */
+	if (unlikely(ldata->no_room)) {
+		ldata->no_room = 0;
+
+		WARN_RATELIMIT(tty->port->itty == NULL,
+				"scheduling with invalid itty\n");
+		/* see if ldisc has been killed - if so, this means that
+		 * even though the ldisc has been halted and ->buf.work
+		 * cancelled, ->buf.work is about to be rescheduled
+		 */
+		WARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &tty->flags),
+			       "scheduling buffer work for halted ldisc\n");
+		//tty_buffer_restart_work(tty->port);
+        queue_work(system_unbound_wq, &port->buf.work);
+	}
+}
+
+static ssize_t chars_in_buffer(struct tty_struct *tty)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+	ssize_t n = 0;
+
+    n = ldata->commit_head - ldata->read_tail;
+	return n;
+}
+
+/**
+ *	unipi_tty_write_wakeup	-	asynchronous I/O notifier
+ *	@tty: tty device
+ *
+ *	Required for the ptys, serial driver etc. since processes
+ *	that attach themselves to the master and rely on ASYNC
+ *	IO must be woken up
+ */
+
+static void unipi_tty_write_wakeup(struct tty_struct *tty)
+{
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Wakeup start.");
+
+	clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
+	kill_fasync(&tty->fasync, SIGIO, POLL_OUT);
+}
+
+static void unipi_tty_check_throttle(struct tty_struct *tty)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+
+	/*
+	 * Check the remaining room for the input canonicalization
+	 * mode.  We don't want to throttle the driver if we're in
+	 * canonical mode and don't have a newline yet!
+	 */
+
+	while (1) {
+		int throttled;
+		tty_set_flow_change(tty, TTY_THROTTLE_SAFE);
+		if (N_TTY_BUF_SIZE - read_cnt(ldata) >= TTY_THRESHOLD_THROTTLE)
+			break;
+		throttled = unipi_tty_throttle_safe(tty);
+		if (!throttled)
+			break;
+	}
+	__tty_set_flow_change(tty, 0);
+}
+
+static void unipi_tty_check_unthrottle(struct tty_struct *tty)
+{
+	if (tty->driver->type == TTY_DRIVER_TYPE_PTY) {
+		if (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)
+			return;
+		unipi_tty_kick_worker(tty);
+		tty_wakeup(tty->link);
+		return;
+	}
+
+	/* If there is enough space in the read buffer now, let the
+	 * low-level driver know. We use chars_in_buffer() to
+	 * check the buffer, as it now knows about canonical mode.
+	 * Otherwise, if the driver is throttled and the line is
+	 * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,
+	 * we won't get any more characters.
+	 */
+
+	while (1) {
+		int unthrottled;
+		tty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);
+		if (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)
+			break;
+		unipi_tty_kick_worker(tty);
+		unthrottled = unipi_tty_unthrottle_safe(tty);
+		if (!unthrottled)
+			break;
+	}
+	__tty_set_flow_change(tty, 0);
+}
+
+/**
+ *	reset_buffer_flags	-	reset buffer state
+ *	@tty: terminal to reset
+ *
+ *	Reset the read buffer counters and clear the flags.
+ *	Called from unipi_tty_open() and unipi_tty_flush_buffer().
+ *
+ *	Locking: caller holds exclusive termios_rwsem
+ *		 (or locking is not required)
+ */
+
+static void reset_buffer_flags(struct unipi_tty_data *ldata)
+{
+	ldata->read_head =  ldata->read_tail = 0;
+	ldata->commit_head = 0;
+
+}
+
+static void unipi_tty_packet_mode_flush(struct tty_struct *tty)
+{
+	unsigned long flags;
+
+	if (tty->link->packet) {
+		spin_lock_irqsave(&tty->ctrl_lock, flags);
+		tty->ctrl_status |= TIOCPKT_FLUSHREAD;
+		spin_unlock_irqrestore(&tty->ctrl_lock, flags);
+		wake_up_interruptible(&tty->link->read_wait);
+	}
+}
+
+/**
+ *	unipi_tty_flush_buffer	-	clean input queue
+ *	@tty:	terminal device
+ *
+ *	Flush the input buffer. Called when the tty layer wants the
+ *	buffer flushed (eg at hangup) or when the N_TTY line discipline
+ *	internally has to clean the pending queue (for example some signals).
+ *
+ *	Holds termios_rwsem to exclude producer/consumer while
+ *	buffer indices are reset.
+ *
+ *	Locking: ctrl_lock, exclusive termios_rwsem
+ */
+
+static void unipi_tty_flush_buffer(struct tty_struct *tty)
+{
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Flush start.");
+
+	down_write(&tty->termios_rwsem);
+	reset_buffer_flags(tty->disc_data);
+	unipi_tty_kick_worker(tty);
+
+	if (tty->link)
+		unipi_tty_packet_mode_flush(tty);
+	up_write(&tty->termios_rwsem);
+}
+
+
+
+static void __receive_buf(struct tty_struct *tty, const unsigned char *cp,
+			  char *fp, int count)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+	size_t n, head;
+
+	head = ldata->read_head & (N_TTY_BUF_SIZE - 1);
+	n = min_t(size_t, count, N_TTY_BUF_SIZE - head);
+	memcpy(read_buf_addr(ldata, head), cp, n);
+	ldata->read_head += n;
+	cp += n;
+	count -= n;
+
+	head = ldata->read_head & (N_TTY_BUF_SIZE - 1);
+	n = min_t(size_t, count, N_TTY_BUF_SIZE - head);
+	memcpy(read_buf_addr(ldata, head), cp, n);
+	ldata->read_head += n;
+
+	/* publish read_head to consumer */
+	smp_store_release(&ldata->commit_head, ldata->read_head);
+
+	if (read_cnt(ldata)) {
+		kill_fasync(&tty->fasync, SIGIO, POLL_IN);
+		wake_up_interruptible_poll(&tty->read_wait, POLLIN);
+	}
+}
+
+/**
+ *	unipi_tty_receive_buf_common	-	process input
+ *	@tty: device to receive input
+ *	@cp: input chars
+ *	@fp: flags for each char (if NULL, all chars are TTY_NORMAL)
+ *	@count: number of input chars in @cp
+ *
+ *	Called by the terminal driver when a block of characters has
+ *	been received. This function must be called from soft contexts
+ *	not from interrupt context. The driver is responsible for making
+ *	calls one at a time and in order (or using flush_to_ldisc)
+ *
+ *	Returns the # of input chars from @cp which were processed.
+ *
+ *	In canonical mode, the maximum line length is 4096 chars (including
+ *	the line termination char); lines longer than 4096 chars are
+ *	truncated. After 4095 chars, input data is still processed but
+ *	not stored. Overflow processing ensures the tty can always
+ *	receive more input until at least one line can be read.
+ *
+ *	In non-canonical mode, the read buffer will only accept 4095 chars;
+ *	this provides the necessary space for a newline char if the input
+ *	mode is switched to canonical.
+ *
+ *	Note it is possible for the read buffer to _contain_ 4096 chars
+ *	in non-canonical mode: the read buffer could already contain the
+ *	maximum canon line of 4096 chars when the mode is switched to
+ *	non-canonical.
+ *
+ *	unipi_tty_receive_buf()/producer path:
+ *		claims non-exclusive termios_rwsem
+ *		publishes commit_head or canon_head
+ */
+static int
+unipi_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,
+			 char *fp, int count, int flow)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+	int room, n, rcvd = 0;
+
+	down_read(&tty->termios_rwsem);
+
+	while (1) {
+
+		size_t tail = smp_load_acquire(&ldata->read_tail);
+
+		room = N_TTY_BUF_SIZE - (ldata->read_head - tail);
+		room--;
+		if (room <= 0) {
+            room = 0;
+			ldata->no_room = flow;
+		}
+		n = min(count, room);
+		if (!n)
+			break;
+
+		__receive_buf(tty, cp, fp, n);
+
+		cp += n;
+		count -= n;
+		rcvd += n;
+	}
+
+	tty->receive_room = room;
+
+	/* Unthrottle if handling overflow on pty */
+	if (tty->driver->type == TTY_DRIVER_TYPE_PTY) {
+	} else
+		unipi_tty_check_throttle(tty);
+
+	up_read(&tty->termios_rwsem);
+
+	return rcvd;
+}
+
+static void unipi_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,
+			      char *fp, int count)
+{
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Buf start.");
+	unipi_tty_receive_buf_common(tty, cp, fp, count, 0);
+}
+
+static int unipi_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,
+			      char *fp, int count)
+{
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Buf2 start.");
+	return unipi_tty_receive_buf_common(tty, cp, fp, count, 1);
+}
+
+/**
+ *	unipi_tty_set_termios	-	termios data changed
+ *	@tty: terminal
+ *	@old: previous data
+ *
+ *	Called by the tty layer when the user changes termios flags so
+ *	that the line discipline can plan ahead. This function cannot sleep
+ *	and is protected from re-entry by the tty layer. The user is
+ *	guaranteed that this function will not be re-entered or in progress
+ *	when the ldisc is closed.
+ *
+ *	Locking: Caller holds tty->termios_rwsem
+ */
+
+static void unipi_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+    int lx=0; int ix=0; int ox=0; int cx = 0;
+    if (old) {
+        lx = old->c_lflag; 
+        ix = old->c_iflag; 
+        ox = old->c_oflag; 
+        cx = old->c_cflag; 
+    }
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Termios new:0x%x %x %x %x old:0x%x %x %x %x", \
+         tty->termios.c_lflag, tty->termios.c_iflag, tty->termios.c_oflag,  tty->termios.c_cflag,\
+         lx, ix, ox, cx);
+	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {
+		ldata->commit_head = ldata->read_head;
+	}
+
+	/*
+	 * Fix tty hang when I_IXON(tty) is cleared, but the tty
+	 * been stopped by STOP_CHAR(tty) before it.
+	 */
+	if (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {
+		start_tty(tty);
+	}
+
+	/* The termios change make the tty ready for I/O */
+	wake_up_interruptible(&tty->write_wait);
+	wake_up_interruptible(&tty->read_wait);
+}
+
+/**
+ *	unipi_tty_close		-	close the ldisc for this tty
+ *	@tty: device
+ *
+ *	Called from the terminal layer when this line discipline is
+ *	being shut down, either because of a close or becsuse of a
+ *	discipline change. The function will not be called while other
+ *	ldisc methods are in progress.
+ */
+
+static void unipi_tty_close(struct tty_struct *tty)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+
+	if (tty->link)
+		unipi_tty_packet_mode_flush(tty);
+
+	vfree(ldata);
+	tty->disc_data = NULL;
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Close OK.");
+}
+
+static int unipi_is_port_unipi(struct tty_struct *tty)
+{
+    struct uart_state *state = tty->driver_data;
+    struct uart_port *uport;
+
+    uport = state->uart_port;
+    return (uport->type == PORT_NEURONSPI);
+}
+
+/**
+ *	unipi_tty_open		-	open an ldisc
+ *	@tty: terminal to open
+ *
+ *	Called when this line discipline is being attached to the
+ *	terminal device. Can sleep. Called serialized so that no
+ *	other events will occur in parallel. No further open will occur
+ *	until a close.
+ */
+
+static int unipi_tty_open(struct tty_struct *tty)
+{
+	struct unipi_tty_data *ldata;
+
+	if (!unipi_is_port_unipi(tty))
+        goto err;
+        
+	/* Currently a malloc failure here can panic */
+	ldata = vmalloc(sizeof(*ldata));
+	if (!ldata)
+		goto err;
+
+	mutex_init(&ldata->atomic_read_lock);
+	mutex_init(&ldata->output_lock);
+
+	tty->disc_data = ldata;
+	reset_buffer_flags(tty->disc_data);
+	ldata->no_room = 0;
+	tty->closing = 0;
+	/* indicate buffer work may resume */
+	clear_bit(TTY_LDISC_HALTED, &tty->flags);
+	unipi_tty_set_termios(tty, NULL);
+	tty_unthrottle(tty);
+
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Open OK.");
+
+	return 0;
+err:
+	return -ENOMEM;
+}
+
+static inline int input_available_p(struct tty_struct *tty, int poll)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+	int amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;
+
+    return ldata->commit_head - ldata->read_tail >= amt;
+}
+
+/**
+ *	copy_from_read_buf	-	copy read data directly
+ *	@tty: terminal device
+ *	@b: user data
+ *	@nr: size of data
+ *
+ *	Helper function to speed up unipi_tty_read.  It is only called when
+ *	ICANON is off; it copies characters straight from the tty queue to
+ *	user space directly.  It can be profitably called twice; once to
+ *	drain the space from the tail pointer to the (physical) end of the
+ *	buffer, and once to drain the space from the (physical) beginning of
+ *	the buffer to head pointer.
+ *
+ *	Called under the ldata->atomic_read_lock sem
+ *
+ *	unipi_tty_read()/consumer path:
+ *		caller holds non-exclusive termios_rwsem
+ *		read_tail published
+ */
+
+static int copy_from_read_buf(struct tty_struct *tty,
+				      unsigned char __user **b,
+				      size_t *nr)
+
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+	int retval;
+	size_t n;
+	size_t head = smp_load_acquire(&ldata->commit_head);
+	size_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);
+
+	retval = 0;
+	n = min(head - ldata->read_tail, N_TTY_BUF_SIZE - tail);
+	n = min(*nr, n);
+	if (n) {
+		const unsigned char *from = read_buf_addr(ldata, tail);
+		retval = copy_to_user(*b, from, n);
+		n -= retval;
+		//tty_audit_add_data(tty, from, n);
+		smp_store_release(&ldata->read_tail, ldata->read_tail + n);
+		*b += n;
+		*nr -= n;
+	}
+	return retval;
+}
+
+
+
+/**
+ *	unipi_tty_read		-	read function for tty
+ *	@tty: tty device
+ *	@file: file object
+ *	@buf: userspace buffer pointer
+ *	@nr: size of I/O
+ *
+ *	Perform reads for the line discipline. We are guaranteed that the
+ *	line discipline will not be closed under us but we may get multiple
+ *	parallel readers and must handle this ourselves. We may also get
+ *	a hangup. Always called in user context, may sleep.
+ *
+ *	This code must be sure never to sleep through a hangup.
+ *
+ *	unipi_tty_read()/consumer path:
+ *		claims non-exclusive termios_rwsem
+ *		publishes read_tail
+ */
+
+static ssize_t unipi_tty_read(struct tty_struct *tty, struct file *file,
+			 unsigned char __user *buf, size_t nr)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+    struct tty_port *port = tty->port;
+	unsigned char __user *b = buf;
+	DEFINE_WAIT_FUNC(wait, woken_wake_function);
+	int minimum, time;
+	ssize_t retval = 0;
+	long timeout;
+	int packet;
+	size_t tail;
+
+	/*
+	 *	Internal serialization of reads.
+	 */
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Read start.");
+	if (file->f_flags & O_NONBLOCK) {
+		if (!mutex_trylock(&ldata->atomic_read_lock))
+			return -EAGAIN;
+	} else {
+		if (mutex_lock_interruptible(&ldata->atomic_read_lock))
+			return -ERESTARTSYS;
+	}
+
+	down_read(&tty->termios_rwsem);
+
+	minimum = time = 0;
+	timeout = MAX_SCHEDULE_TIMEOUT;
+
+	minimum = MIN_CHAR(tty);
+	if (minimum) {
+		time = (HZ / 10) * TIME_CHAR(tty);
+	} else {
+		timeout = (HZ / 10) * TIME_CHAR(tty);
+		minimum = 1;
+	}
+
+	packet = tty->packet;
+	tail = ldata->read_tail;
+
+	add_wait_queue(&tty->read_wait, &wait);
+	while (nr) {
+		/* First test for status change. */
+		if (packet && tty->link->ctrl_status) {		
+ 			unsigned char cs;
+			if (b != buf)
+				break;
+			spin_lock_irq(&tty->link->ctrl_lock);
+			cs = tty->link->ctrl_status;
+			tty->link->ctrl_status = 0;
+			spin_unlock_irq(&tty->link->ctrl_lock);
+			if (put_user(cs, b)) {
+				retval = -EFAULT;
+				break;
+			}
+			b++;
+			nr--;
+			break;
+		}
+
+		if (!input_available_p(tty, 0)) {
+			up_read(&tty->termios_rwsem);
+			//tty_buffer_flush_work(tty->port);
+            flush_work(&port->buf.work);
+			down_read(&tty->termios_rwsem);
+			if (!input_available_p(tty, 0)) {
+				if (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {
+					retval = -EIO;
+					break;
+				}
+				if (tty_hung_up_p(file))
+					break;
+				/*
+				 * Abort readers for ttys which never actually
+				 * get hung up.  See __tty_hangup().
+				 */
+#ifdef TTY_HUPPING                 
+				if (test_bit(TTY_HUPPING, &tty->flags))
+					break;
+#endif
+				if (!timeout)
+					break;
+				if (file->f_flags & O_NONBLOCK) {
+					retval = -EAGAIN;
+					break;
+				}
+				if (signal_pending(current)) {
+					retval = -ERESTARTSYS;
+					break;
+				}
+				up_read(&tty->termios_rwsem);
+
+				timeout = wait_woken(&wait, TASK_INTERRUPTIBLE,
+						timeout);
+
+				down_read(&tty->termios_rwsem);
+				continue;
+			}
+		}
+
+        {
+			int uncopied;
+
+			/* Deal with packet mode. */
+			if (packet && b == buf) {
+				if (put_user(TIOCPKT_DATA, b)) {
+					retval = -EFAULT;
+					break;
+				}
+				b++;
+				nr--;
+			}
+
+			uncopied = copy_from_read_buf(tty, &b, &nr);
+			uncopied += copy_from_read_buf(tty, &b, &nr);
+			if (uncopied) {
+				retval = -EFAULT;
+				break;
+			}
+		}
+
+		unipi_tty_check_unthrottle(tty);
+
+		if (b - buf >= minimum)
+			break;
+		if (time)
+			timeout = time;
+	}
+	if (tail != ldata->read_tail)
+		unipi_tty_kick_worker(tty);
+	up_read(&tty->termios_rwsem);
+
+	remove_wait_queue(&tty->read_wait, &wait);
+	mutex_unlock(&ldata->atomic_read_lock);
+
+	if (b - buf)
+		retval = b - buf;
+
+	return retval;
+}
+
+/**
+ *	unipi_tty_write		-	write function for tty
+ *	@tty: tty device
+ *	@file: file object
+ *	@buf: userspace buffer pointer
+ *	@nr: size of I/O
+ *
+ *	Write function of the terminal device.  This is serialized with
+ *	respect to other write callers but not to termios changes, reads
+ *	and other such events.  Since the receive code will echo characters,
+ *	thus calling driver write methods, the output_lock is used in
+ *	the output processing functions called here as well as in the
+ *	echo processing function to protect the column state and space
+ *	left in the buffer.
+ *
+ *	This code must be sure never to sleep through a hangup.
+ *
+ *	Locking: output_lock to protect column state and space left
+ *		 (note that the process_output*() functions take this
+ *		  lock themselves)
+ */
+
+static ssize_t unipi_tty_write(struct tty_struct *tty, struct file *file,
+			   const unsigned char *buf, size_t nr)
+{
+	const unsigned char *b = buf;
+	DEFINE_WAIT_FUNC(wait, woken_wake_function);
+    struct unipi_tty_data *ldata;
+	int c;
+	ssize_t retval = 0;
+
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Write start.");
+	down_read(&tty->termios_rwsem);
+
+	add_wait_queue(&tty->write_wait, &wait);
+	while (1) {
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+		if (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {
+			retval = -EIO;
+			break;
+		}
+        
+		ldata = tty->disc_data;
+
+		while (nr > 0) {
+			mutex_lock(&ldata->output_lock);
+			c = tty->ops->write(tty, b, nr);
+			mutex_unlock(&ldata->output_lock);
+			if (c < 0) {
+				retval = c;
+				goto break_out;
+			}
+			if (!c)
+				break;
+			b += c;
+			nr -= c;
+		}
+		
+		if (!nr)
+			break;
+		if (file->f_flags & O_NONBLOCK) {
+			retval = -EAGAIN;
+			break;
+		}
+		up_read(&tty->termios_rwsem);
+
+		wait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
+
+		down_read(&tty->termios_rwsem);
+	}
+break_out:
+	remove_wait_queue(&tty->write_wait, &wait);
+	if (nr && tty->fasync)
+		set_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);
+	up_read(&tty->termios_rwsem);
+	return (b - buf) ? b - buf : retval;
+}
+
+/**
+ *	unipi_tty_poll		-	poll method for N_TTY
+ *	@tty: terminal device
+ *	@file: file accessing it
+ *	@wait: poll table
+ *
+ *	Called when the line discipline is asked to poll() for data or
+ *	for special events. This code is not serialized with respect to
+ *	other events save open/close.
+ *
+ *	This code must be sure never to sleep through a hangup.
+ *	Called without the kernel lock held - fine
+ */
+
+static unsigned int unipi_tty_poll(struct tty_struct *tty, struct file *file,
+							poll_table *wait)
+{
+	unsigned int mask = 0;
+    struct tty_port *port = tty->port;
+
+	//unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Poll start.");
+	poll_wait(file, &tty->read_wait, wait);
+	poll_wait(file, &tty->write_wait, wait);
+	if (input_available_p(tty, 1))
+		mask |= POLLIN | POLLRDNORM;
+	else {
+		//tty_buffer_flush_work(tty->port);
+        flush_work(&port->buf.work);
+		if (input_available_p(tty, 1))
+			mask |= POLLIN | POLLRDNORM;
+	}
+	if (tty->packet && tty->link->ctrl_status)
+		mask |= POLLPRI | POLLIN | POLLRDNORM;
+	if (test_bit(TTY_OTHER_CLOSED, &tty->flags))
+		mask |= POLLHUP;
+	if (tty_hung_up_p(file))
+		mask |= POLLHUP;
+	if (tty->ops->write && !tty_is_writelocked(tty) &&
+			tty_chars_in_buffer(tty) < WAKEUP_CHARS &&
+			tty_write_room(tty) > 0)
+		mask |= POLLOUT | POLLWRNORM;
+	return mask;
+}
+
+
+static int unipi_tty_ioctl(struct tty_struct *tty, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct unipi_tty_data *ldata = tty->disc_data;
+	int retval;
+
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Ioctl start. cmd=%x", cmd);
+	switch (cmd) {
+	case TIOCOUTQ:
+		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
+	case TIOCINQ:
+		down_write(&tty->termios_rwsem);
+        retval = read_cnt(ldata);
+		up_write(&tty->termios_rwsem);
+		return put_user(retval, (unsigned int __user *) arg);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+    case 0x5481:
+	case 0x5480:
+		if (tty->ops->ioctl != NULL) {
+			retval = tty->ops->ioctl(tty, cmd, arg);
+			if (retval != -ENOIOCTLCMD)
+				return retval;
+		}
+        // fall through
+#endif
+	default:
+		return  n_tty_ioctl_helper(tty, file, cmd, arg);
+	}
+}
+
+#ifdef CONFIG_COMPAT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+
+static long unipi_tty_compat_ioctl(struct tty_struct *tty, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	int retval;
+
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Compat_ioctl start. cmd=%x", cmd);
+	switch (cmd) {
+	case 0x5481:
+	case 0x5480:
+		if (tty->ops->ioctl) {
+			retval = tty->ops->ioctl(tty, cmd,  (unsigned long) compat_ptr(arg));
+			if (retval != -ENOIOCTLCMD)
+				return retval;
+		}
+		//return tty_mode_ioctl(tty, file, cmd, (unsigned long) compat_ptr(arg));
+	default:
+		return n_tty_compat_ioctl_helper(tty, file, cmd, arg);
+	}
+}
+#endif
+#endif
+
+static struct tty_ldisc_ops unipi_tty_ops = {
+	.magic           = TTY_LDISC_MAGIC,
+  	.owner 			 = THIS_MODULE,
+	.name            = "unipi_tty",
+	.open            = unipi_tty_open,
+	.close           = unipi_tty_close,
+	.flush_buffer    = unipi_tty_flush_buffer,
+	.read            = unipi_tty_read,
+	.write           = unipi_tty_write,
+	.ioctl           = unipi_tty_ioctl,
+#ifdef CONFIG_COMPAT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+	.compat_ioctl    = unipi_tty_compat_ioctl,
+#endif
+#endif
+	.set_termios     = unipi_tty_set_termios,
+	.poll            = unipi_tty_poll,
+	.receive_buf     = unipi_tty_receive_buf,
+	.write_wakeup    = unipi_tty_write_wakeup,
+	.receive_buf2	 = unipi_tty_receive_buf2,
+};
+
+
+
+int __init unipi_tty_init(void)
+{
+	int err;
+	unipi_tty_trace(KERN_INFO "UNIPISPI: TTY Init\n");
+	err = tty_register_ldisc(N_PROFIBUS_FDL, &unipi_tty_ops);
+	if (err) {
+		printk(KERN_INFO "UNIPISPI: UniPi line discipline registration failed. (%d)", err);
+		return err;
+	}
+	return 0;
+}
+
+void __exit unipi_tty_exit(void)
+{
+     tty_unregister_ldisc(N_PROFIBUS_FDL);
+}
+
+#else
+
+struct tty_ldisc_ops unipi_tty_ldisc;
+static void (*alias_n_tty_receive_buf)(struct tty_struct *tty, const unsigned char *cp,
+			      char *fp, int count);
+static int (*alias_n_tty_receive_buf2)(struct tty_struct *tty, const unsigned char *cp,
+			      char *fp, int count);
+static int (*alias_n_tty_ioctl)(struct tty_struct *tty, struct file *file,
+               unsigned int cmd, unsigned long arg);
+
+static void unipi_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,
+			      char *fp, int count)
+{
+    int is_parmrk = I_PARMRK(tty);
+    if (is_parmrk) {
+        tty->termios.c_iflag = tty->termios.c_iflag & (~PARMRK);
+    }
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Buf start.");
+	alias_n_tty_receive_buf(tty, cp, fp, count);
+    if (is_parmrk) {
+        tty->termios.c_iflag = tty->termios.c_iflag | (PARMRK);
+    }
+}
+
+static int unipi_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,
+			      char *fp, int count)
+{
+    int ret;
+    int is_parmrk = I_PARMRK(tty);
+    if (is_parmrk) {
+        tty->termios.c_iflag = tty->termios.c_iflag & (~PARMRK);
+    }
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Buf2 start.");
+	ret = alias_n_tty_receive_buf2(tty, cp, fp, count);
+    if (is_parmrk) {
+        tty->termios.c_iflag = tty->termios.c_iflag | (PARMRK);
+    }
+    return ret;
+}
+
+static int unipi_tty_ioctl(struct tty_struct *tty, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	int retval;
+
+	unipi_tty_trace(KERN_INFO "UNIPI_LDISC: Ioctl start. cmd=%x", cmd);
+	switch (cmd) {
+    case 0x5481:
+	case 0x5480:
+		if (tty->ops->ioctl != NULL) {
+			retval = tty->ops->ioctl(tty, cmd, arg);
+			if (retval != -ENOIOCTLCMD)
+				return retval;
+		}
+	}
+	return  alias_n_tty_ioctl(tty, file, cmd, arg);
+}
+
+int __init unipi_tty_init(void)
+{
+    int err;
+	unipi_tty_trace(KERN_INFO "UNIPISPI: TTY Init\n");
+
+    memset(&unipi_tty_ldisc, 0, sizeof(unipi_tty_ldisc));
+    n_tty_inherit_ops(&unipi_tty_ldisc);
+    unipi_tty_ldisc.magic           = TTY_LDISC_MAGIC;
+    unipi_tty_ldisc.name            = "unipi_tty";
+    unipi_tty_ldisc.owner           = THIS_MODULE;
+
+	alias_n_tty_receive_buf = unipi_tty_ldisc.receive_buf;
+	alias_n_tty_receive_buf2 = unipi_tty_ldisc.receive_buf2;
+	alias_n_tty_ioctl = unipi_tty_ldisc.ioctl;
+
+	unipi_tty_ldisc.receive_buf     = unipi_tty_receive_buf;
+	unipi_tty_ldisc.receive_buf2	= unipi_tty_receive_buf2;
+	unipi_tty_ldisc.ioctl	        = unipi_tty_ioctl;
+
+    err = tty_register_ldisc(N_PROFIBUS_FDL, &unipi_tty_ldisc);
+    if (err) {
+        printk(KERN_INFO "UniPi line discipline registration failed. (%d)", err);
+        return err;
+    }
+    return 0;
+}
+
+void __exit unipi_tty_exit(void)
+{
+     tty_unregister_ldisc(N_PROFIBUS_FDL);
+}
+#endif
diff --git a/drivers/unipi/unipi_tty.h b/drivers/unipi/unipi_tty.h
new file mode 100644
index 000000000000..b4a6cc31f97c
--- /dev/null
+++ b/drivers/unipi/unipi_tty.h
@@ -0,0 +1,23 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_UNIPI_SRC_UNIPI_TTY_H_
+#define MODULES_UNIPI_SRC_UNIPI_TTY_H_
+
+#include "unipi_common.h"
+
+int unipi_tty_init(void);
+void unipi_tty_exit(void);
+
+#endif /* MODULES_UNIPI_SRC_UNIPI_TTY_H_ */
diff --git a/drivers/unipi/unipi_uart.c b/drivers/unipi/unipi_uart.c
new file mode 100644
index 000000000000..57944dd22a41
--- /dev/null
+++ b/drivers/unipi/unipi_uart.c
@@ -0,0 +1,792 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_uart.h"
+#include "unipi_spi.h"
+
+#if NEURONSPI_DETAILED_DEBUG > 2
+# define unipi_uart_trace_2(f, args...)	printk(KERN_INFO "UNIPIUART: " f, ##args)
+#else
+# define unipi_uart_trace_2(f, args...)
+#endif
+
+#if NEURONSPI_DETAILED_DEBUG > 1
+# define unipi_uart_trace_1(f, args...)	printk(KERN_INFO "UNIPIUART: " f, ##args)
+#else
+# define unipi_uart_trace_1(f, args...)
+#endif
+
+#if NEURONSPI_DETAILED_DEBUG > 0
+# define unipi_uart_trace(f, args...)	printk(KERN_INFO "UNIPIUART: " f, ##args)
+#else
+# define unipi_uart_trace(f, args...)
+#endif
+
+/********************
+ * Data Definitions *
+ ********************/
+
+struct neuronspi_uart_data  *neuronspi_uart_data_global = NULL;
+struct uart_driver          *neuronspi_uart_driver_global = NULL;
+
+
+/********************
+ * Static Functions *
+ ********************/
+
+void neuronspi_uart_update_timeout(struct neuronspi_port *n_port, unsigned int cflag, unsigned int baud);
+
+#define NEURONSPI_UART_CFLAGS_REGISTER 	500
+#define NEURONSPI_UART_IFLAGS_REGISTER 	502
+#define NEURONSPI_UART_LDISC_REGISTER 	503
+#define NEURONSPI_UART_TIMEOUT_REGISTER 504
+#define NEURONSPI_UART_FIFO_REGISTER    505
+
+static inline int port_to_uartregs(u8 port, u16 reg)
+{
+    return reg + ((port==0) ? 0 : (10*(port+1)));
+}
+
+static void neuronspi_uart_set_cflag(struct neuronspi_port *n_port, u32 to)
+{
+	struct spi_device *spi = neuronspi_s_dev[n_port->dev_index];
+    unipispi_modbus_write_u32(spi, port_to_uartregs(n_port->dev_port, NEURONSPI_UART_CFLAGS_REGISTER), to);
+	unipi_uart_trace("ttyNS%d Set cflag: %08x\n", n_port->port.line, to);
+}
+
+
+static void neuronspi_uart_set_iflags(struct neuronspi_port *n_port, int to)
+{
+	struct spi_device *spi = neuronspi_s_dev[n_port->dev_index];
+	unipi_uart_trace("ttyNS%d Set iflag: %s\n", n_port->port.line, (to & PARMRK)? "PARMRK" : "0");
+
+    unipispi_modbus_write_register(spi, port_to_uartregs(n_port->dev_port, NEURONSPI_UART_IFLAGS_REGISTER), to);
+}
+
+
+/*******************
+ * Empty functions *
+ *******************/
+
+void neuronspi_uart_power(struct uart_port *port, s32 on)
+{
+    /* Do nothing */
+}
+void neuronspi_uart_set_mctrl(struct uart_port *port, u32 mctrl)
+{
+    /* Do nothing */
+}
+void neuronspi_uart_break_ctl(struct uart_port *port, int break_state)
+{
+    /* Do nothing */
+}
+void neuronspi_uart_null_void(struct uart_port *port)
+{
+	/* Do nothing */
+}
+
+void neuronspi_uart_stop_rx(struct uart_port *port)
+{
+	struct neuronspi_port *n_port = to_neuronspi_port(port, port);
+    /*unsigned long flags;*/
+
+    /*spin_lock_irqsave(&port->lock, flags);*/
+    n_port->accept_rx = 0;
+    /*spin_unlock_irqrestore(&port->lock, flags);*/
+}
+
+void neuronspi_uart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_NEURONSPI;
+	}
+}
+
+s32 neuronspi_uart_verify_port(struct uart_port *port, struct serial_struct *s)
+{
+	if ((s->type != PORT_UNKNOWN) && (s->type != PORT_NEURONSPI))
+		return -EINVAL;
+	if (s->irq != port->irq)
+		return -EINVAL;
+
+	return 0;
+}
+
+void neuronspi_uart_pm(struct uart_port *port, u32 state, u32 oldstate)
+{
+	neuronspi_uart_power(port, (state == UART_PM_STATE_ON) ? 1 : 0);
+}
+
+/************************
+ * Non-static Functions *
+ ************************/
+ 
+u32 neuronspi_spi_uart_get_cflag(struct spi_device* spi_dev, u8 port)
+{
+    u32 value;
+    unipispi_modbus_read_u32(spi_dev, port_to_uartregs(port, NEURONSPI_UART_CFLAGS_REGISTER), &value);
+	unipi_uart_trace_1("Get cflag val:%08x\n", value);
+    return value;
+}
+
+void neuronspi_uart_set_ldisc(struct uart_port *port, struct ktermios *kterm)
+{
+	struct neuronspi_port *n_port = to_neuronspi_port(port, port);
+	struct spi_device *spi = neuronspi_s_dev[n_port->dev_index];
+
+	unipi_uart_trace("ttyNS%d Set ldisc: dsc=%d\n", port->line, kterm->c_line);
+    unipispi_modbus_write_register(spi, port_to_uartregs(n_port->dev_port, NEURONSPI_UART_LDISC_REGISTER), kterm->c_line);
+}
+
+
+
+
+void neuronspi_uart_flush_buffer(struct uart_port* port)
+{ 
+	struct neuronspi_port *n_port = to_neuronspi_port(port, port);
+	struct neuronspi_driver_data *n_spi = n_port->n_spi;
+	/*struct spi_device *spi = neuronspi_s_dev[n_port->dev_index];
+	struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+    */
+    //port->lock taken, This call must not sleep
+	unipi_uart_trace("ttyNS%d Flush buffer\n", port->line);
+    n_port->accept_rx = 0;
+	kthread_queue_work(n_spi->primary_worker, &n_port->flush_work);
+    //unipi_spi_idle_op(spi);
+}
+
+
+u32 neuronspi_uart_tx_empty(struct uart_port *port)
+{
+	struct neuronspi_port *n_port = to_neuronspi_port(port, port);
+    int len = n_port->tx_fifo_len;
+    if (len > 0) {
+        unipi_spi_get_tx_fifo(neuronspi_s_dev[n_port->dev_index], n_port);
+    }
+	unipi_uart_trace("ttyNS%d Tx empty? %s\n", port->line, (len==0)?"Yes":"No");
+	return (len==0) ? TIOCSER_TEMT : 0;
+}
+
+u32 neuronspi_uart_get_mctrl(struct uart_port *port)
+{
+	unipi_uart_trace_1("ttyNS%d Get mctrl\n", port->line);
+	return TIOCM_DSR | TIOCM_CAR;
+}
+
+int	neuronspi_uart_ioctl (struct uart_port *port, unsigned int ioctl_code, unsigned long ioctl_arg)
+{
+    u32 value;
+	struct neuronspi_port *n_port = to_neuronspi_port(port, port);
+	struct spi_device *spi = neuronspi_s_dev[n_port->dev_index];
+
+	switch (ioctl_code) {
+	case TIOCSETD: {
+		unipi_uart_trace("ttyNS%d Ioctl TIOCSETD (processed via set_termios)\n", port->line);
+		return 1;
+	}
+	case 0x5481: {
+        value = ((ioctl_arg * 1000000) / n_port->baud);
+        if (value > 0xffff) value = 0xffff;
+		unipi_uart_trace("ttyNS%d Ioctl 0x5481 set timeout=%d\n", port->line, value);
+        unipispi_modbus_write_register(spi, port_to_uartregs(n_port->dev_port, NEURONSPI_UART_TIMEOUT_REGISTER), value);
+		return 0;
+	}
+	case 0x5480: {
+        value = (ioctl_arg * 10);
+        if (value > 0xffff) value = 0xffff;
+		unipi_uart_trace("ttyNS%d Ioctl 0x5480 set timeout=%d\n", port->line, value);
+        unipispi_modbus_write_register(spi, port_to_uartregs(n_port->dev_port, NEURONSPI_UART_TIMEOUT_REGISTER), value);
+		return 0;
+	}
+	default: {
+		return -ENOIOCTLCMD;
+	}
+	}
+}
+
+
+void neuronspi_uart_set_termios(struct uart_port *port, struct ktermios *termios, struct ktermios *old)
+{
+	struct neuronspi_port *n_port;
+	n_port = to_neuronspi_port(port, port);
+
+    if (old) {
+        unipi_uart_trace("ttyNS%d Termios old:0x%04x %04x %04x %04x ldisc:%d", port->line,\
+         old->c_cflag, old->c_iflag, \
+         old->c_oflag, old->c_lflag, old->c_line);
+    }
+    if (termios) {
+        unipi_uart_trace("ttyNS%d Termios new:0x%04x %04x %04x %04x ldisc:%d", port->line,\
+         termios->c_cflag, termios->c_iflag, \
+         termios->c_oflag, termios->c_lflag, termios->c_line);
+        spin_lock_irq(&port->lock);
+        n_port->accept_rx = 0;
+        spin_unlock_irq(&port->lock);
+        neuronspi_uart_set_cflag(n_port, termios->c_cflag);
+        spin_lock_irq(&port->lock);
+        n_port->accept_rx = 1;
+        spin_unlock_irq(&port->lock);
+    }
+
+	if (termios && (!old || ((old->c_iflag) != (termios->c_iflag)))) {
+		neuronspi_uart_set_iflags(n_port, termios->c_iflag);
+	}
+	if (termios && !old) {
+        // set line discipline only in case of new setting - Mervis behavior
+        neuronspi_uart_set_ldisc(port, termios);
+	}
+	n_port->baud = uart_get_baud_rate(port, termios, old, 134, 115200);
+	uart_update_timeout(port, termios->c_cflag, n_port->baud);
+    neuronspi_uart_update_timeout(n_port, termios->c_cflag, n_port->baud);
+}
+
+s32 neuronspi_uart_config_rs485(struct uart_port *port, struct serial_rs485 *rs485)
+{
+	port->rs485 = *rs485;
+	return 0;
+}
+
+
+void neuronspi_uart_update_timeout(struct neuronspi_port *n_port, unsigned int cflag, unsigned int baud)
+{
+	unsigned int bits;
+
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS5:
+		bits = 7;
+		break;
+	case CS6:
+		bits = 8;
+		break;
+	case CS7:
+		bits = 9;
+		break;
+	default:
+		bits = 10;
+		break; /* CS8 */
+	}
+
+	if (cflag & CSTOPB)
+		bits++;
+	if (cflag & PARENB)
+		bits++;
+	/*
+	 * time in nanoseconds for sending one character
+	 */
+	n_port->one_char_nsec = (((long)1000000 * bits) / baud)*1000;
+}
+
+const char* neuronspi_uart_type(struct uart_port *port)
+{
+	return port->type == PORT_NEURONSPI ? "UNIPISPI_NAME" : NULL;
+}
+
+s32 neuronspi_uart_request_port(struct uart_port *port)
+{
+	unipi_uart_trace("ttyNS%d Request port\n", port->line);
+	return 0;
+}
+
+
+/*
+// set port->tx_fifo_len by reading modbus register
+// return 0 if success, 1 if couldnt read register - fifo len has old value
+int static neuronspi_uart_read_tx_fifo_len(struct neuronspi_port *port) 
+{
+    u16 read_length16 = - 1;
+	struct spi_device *spi;
+	int ret = 1;
+    
+    if (port->tx_fifo_reg) {
+        spi = neuronspi_s_dev[port->dev_index];
+        if (unipispi_modbus_read_register(spi, port->tx_fifo_reg, &read_length16) == 0) {
+            ret = 0;
+            port->tx_fifo_len = read_length16;
+        }
+	} else {
+        // unknown port!
+        port->tx_fifo_len = 0;
+        ret = 0;
+    }
+	unipi_uart_trace("ttyNS%d Get tx fifo len:%d err:%d\n", port->port.line, read_length16, ret);
+	return ret;
+}
+*/
+
+void neuronspi_uart_handle_rx(struct neuronspi_port *port, int rxlen, u8* pbuf)
+{
+	unsigned long flags;
+	u32 ch, flag, i;
+    
+    unipi_uart_trace("ttyNS%d Insert Chars (%d): %16ph\n", port->port.line, rxlen, pbuf);
+
+	if (rxlen) {
+		spin_lock_irqsave(&port->port.lock, flags);
+		if (port->accept_rx) {
+			port->port.icount.rx++;
+			flag = TTY_NORMAL;
+			for (i = 0; i < rxlen; ++i) {
+				ch = *pbuf;
+            			pbuf++;
+				if (uart_handle_sysrq_char(&port->port, ch))
+					continue;
+
+				uart_insert_char(&port->port, 0, 0, ch, flag);
+			}
+		}
+		spin_unlock_irqrestore(&port->port.lock, flags);
+	}
+	tty_flip_buffer_push(&port->port.state->port);
+}
+
+
+#define start_tx_timer(port, lowlimit, delta) hrtimer_start_range_ns(&port->tx_timer, lowlimit * port->one_char_nsec, delta*port->one_char_nsec, HRTIMER_MODE_REL)
+
+#define MAX_TXLEN	(NEURONSPI_FIFO_SIZE >> 1)
+/*
+void neuronspi_uart_handle_tx(struct neuronspi_port *port)
+{
+	int to_send, to_send_packet, ret, need;
+	u8	tx_buf[MAX_TXLEN + 16];
+	unsigned long flags;
+	struct spi_device *spi;
+	struct neuronspi_driver_data *d_data;
+	struct circ_buf *xmit;
+	int new_tail;
+
+	spi = neuronspi_s_dev[port->dev_index];
+	d_data = spi_get_drvdata(spi);
+
+	if (unlikely(port->port.x_char)) {
+		neuronspi_spi_uart_write(spi, &port->port.x_char, 1, port->dev_port);
+		spin_lock_irqsave(&port->port.lock, flags);
+		port->port.icount.tx++;
+		spin_unlock_irqrestore(&port->port.lock, flags);
+		port->port.x_char = 0;
+        kthread_queue_work(port->n_spi->primary_worker, &port->tx_work);
+		return;
+	}
+
+	xmit = &port->port.state->xmit;
+	spin_lock_irqsave(&port->port.lock, flags);
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&port->port)) {
+		spin_unlock_irqrestore(&port->port.lock, flags);
+        // check tx_fifo status
+        if (port->tx_fifo_len) {
+            ret = neuronspi_uart_read_tx_fifo_len(port);
+            if (ret || port->tx_fifo_len) {
+                // set timer to check tx_empty
+                unipi_uart_trace_1("ttyNS%d Handle TX. Start timer=%llu", port->port.line, port->tx_fifo_len * port->one_char_nsec);
+                start_tx_timer(port, port->tx_fifo_len, 2);
+            }
+        }
+		return;
+	}
+	spin_unlock_irqrestore(&port->port.lock, flags);
+
+	// Get length of data pending in circular buffer
+	to_send = uart_circ_chars_pending(xmit);
+	unipi_uart_trace("ttyNS%d Handle TX. tty->pending=%d", port->port.line, to_send);
+
+	if (likely(to_send)) {
+		
+		// Limit to size of (TX FIFO / 2)
+		to_send_packet = (to_send > MAX_TXLEN) ? MAX_TXLEN : to_send;
+        if (port->tx_fifo_len + to_send_packet > NEURONSPI_FIFO_SIZE) {
+                // read current tx_fifo_len
+                ret = neuronspi_uart_read_tx_fifo_len(port);
+                need = to_send_packet - (NEURONSPI_FIFO_SIZE - port->tx_fifo_len);
+                if ((ret != 0) || (need > 0)) {
+                    // reschedule work with pause
+                    start_tx_timer(port, need, NEURONSPI_FIFO_SIZE/4);
+                    return;
+                }
+        }
+        
+		// Read data from tty buffer and send it to spi
+        spin_lock_irqsave(&port->port.lock, flags);
+		port->port.icount.tx += to_send_packet;
+		new_tail = (xmit->tail + to_send_packet) & (UART_XMIT_SIZE - 1);
+		if (new_tail <= xmit->tail) {
+			memcpy(tx_buf, xmit->buf+xmit->tail, UART_XMIT_SIZE - xmit->tail);
+			memcpy(tx_buf+UART_XMIT_SIZE - xmit->tail, xmit->buf, new_tail);
+		} else {
+			memcpy(tx_buf, xmit->buf+xmit->tail, to_send_packet);
+		}
+		xmit->tail = new_tail;
+
+        spin_unlock_irqrestore(&port->port.lock, flags);
+
+        unipi_uart_trace("ttyNS%d Handle TX Send: %d %16ph\n", port->port.line, to_send_packet, tx_buf);
+        neuronspi_spi_uart_write(spi, tx_buf, to_send_packet, port->dev_port);
+        port->tx_fifo_len += to_send_packet;
+           
+		spin_lock_irqsave(&port->port.lock, flags);
+		to_send = uart_circ_chars_pending(xmit);
+		if (to_send < WAKEUP_CHARS) {
+			uart_write_wakeup(&port->port);
+		}
+		spin_unlock_irqrestore(&port->port.lock, flags);
+        if (to_send) {
+            // reschedule work
+			kthread_queue_work(port->n_spi->primary_worker, &port->tx_work);
+		} else {
+            // set timer to check tx_empty
+            unipi_uart_trace_1("ttyNS%d Handle TX. Start timer=%llu", port->port.line, to_send_packet * port->one_char_nsec);
+            start_tx_timer(port, to_send_packet, 2);
+        }
+	}
+}
+*/
+
+
+void unipi_uart_handle_tx(struct neuronspi_port *port, int calling) /* new async ver */
+{
+	int to_send, to_send_packet, need;
+	//unsigned long flags;
+	struct circ_buf *xmit;
+	int new_tail;
+	struct spi_device *spi = neuronspi_s_dev[port->dev_index];
+	//struct neuronspi_driver_data *d_data = spi_get_drvdata(spi);
+
+    //port->port.lock taken, This call must not sleep
+
+	if (unlikely(port->port.x_char)) {
+        // zatim nevim, co s tim
+		port->port.icount.tx++;
+		port->port.x_char = 0;
+	}
+
+ 	xmit = &port->port.state->xmit;
+	//spin_lock_irqsave(&port->port.lock, flags);
+	// Get length of data pending in circular buffer
+	to_send = uart_circ_chars_pending(xmit);
+    unipi_uart_trace("ttyNS%d Handle TX. to_send=%d calling=%d\n", port->port.line, to_send, calling);
+	if ((to_send == 0) || uart_tx_stopped(&port->port)) {
+		port->pending_txop = 0;
+		//spin_unlock_irqrestore(&port->port.lock, flags);
+        // check tx_fifo status
+        if (port->tx_fifo_len) {
+            unipi_uart_trace_1("ttyNS%d Handle TX. Start timer=%llu", port->port.line, port->tx_fifo_len * port->one_char_nsec);
+            start_tx_timer(port, port->tx_fifo_len, 2);
+        }
+		return;
+	}
+   
+    // Limit to size of (TX FIFO / 2)
+    to_send_packet = (to_send > MAX_TXLEN) ? MAX_TXLEN : to_send;
+    need = to_send_packet - (NEURONSPI_FIFO_SIZE - port->tx_fifo_len);
+    if (need > 0) {
+		//spin_unlock_irqrestore(&port->port.lock, flags);
+        if (calling!=CB_GETTXFIFO) {
+            if (unipi_spi_get_tx_fifo(spi, port) == 0) return;
+		}
+        // reschedule work with pause
+		port->pending_txop = 0;
+        start_tx_timer(port, need, NEURONSPI_FIFO_SIZE/4);
+        return;
+    }
+            
+    // Read data from tty buffer and send it to spi
+    //spin_lock_irqsave(&port->port.lock, flags);
+    port->port.icount.tx += to_send_packet;
+    new_tail = (xmit->tail + to_send_packet) & (UART_XMIT_SIZE - 1);
+    if (new_tail <= xmit->tail) {
+        memcpy(port->tx_send_msg, xmit->buf+xmit->tail, UART_XMIT_SIZE - xmit->tail);
+        memcpy(port->tx_send_msg+UART_XMIT_SIZE - xmit->tail, xmit->buf, new_tail);
+    } else {
+        memcpy(port->tx_send_msg, xmit->buf+xmit->tail, to_send_packet);
+    }
+    xmit->tail = new_tail;
+    //spin_unlock_irqrestore(&port->port.lock, flags);
+
+    unipi_uart_trace("ttyNS%d Handle TX Send: %d %16ph\n", port->port.line, to_send_packet, port->tx_send_msg);
+    if (unipi_spi_write_str(spi, port, to_send_packet) != 0) {
+		//ERROR, try later
+		port->pending_txop = 0;
+        start_tx_timer(port, 10, NEURONSPI_FIFO_SIZE/4);
+	} else if ((to_send-to_send_packet) < WAKEUP_CHARS) {
+        uart_write_wakeup(&port->port);
+    }
+}
+
+void unipi_uart_start_tx(struct uart_port *port)
+{
+	struct neuronspi_port *n_port = to_neuronspi_port(port,port);
+	unsigned long flags;
+	unipi_uart_trace("Start TX. is_pending=%d\n", n_port->pending_txop);
+
+	if (!n_port->pending_txop) {
+		spin_lock_irqsave(&n_port->txop_lock, flags);
+		if (!n_port->pending_txop) {
+			n_port->pending_txop = 1;
+			spin_unlock_irqrestore(&n_port->txop_lock, flags);
+			unipi_uart_handle_tx(n_port, START_TX);
+			return;
+		}
+		spin_unlock_irqrestore(&n_port->txop_lock, flags);
+	}
+}
+
+
+// callback of tx_timer. Schedule port->tx_work
+static enum hrtimer_restart unipi_uart_timer_func(struct hrtimer *timer)
+{
+    struct neuronspi_port* n_port = ((container_of((timer), struct neuronspi_port, tx_timer)));
+	struct spi_device *spi = neuronspi_s_dev[n_port->dev_index];
+	unsigned long flags;
+	
+	if (!n_port->pending_txop) {
+		spin_lock_irqsave(&n_port->txop_lock, flags);
+		if (!n_port->pending_txop) {
+			n_port->pending_txop = 1;
+			spin_unlock_irqrestore(&n_port->txop_lock, flags);
+			if (unipi_spi_get_tx_fifo(spi, n_port) != 0) {
+				n_port->pending_txop = 0; // ERROR
+			}
+			return HRTIMER_NORESTART;
+		}
+		spin_unlock_irqrestore(&n_port->txop_lock, flags);
+	}
+	return HRTIMER_NORESTART;
+}
+
+/*
+// callback of tx_timer. Schedule port->tx_work
+static enum hrtimer_restart neuronspi_uart_timer_func(struct hrtimer *timer)
+{
+    struct neuronspi_port* n_port = ((container_of((timer), struct neuronspi_port, tx_timer)));
+
+	kthread_queue_work(n_port->n_spi->primary_worker, &n_port->tx_work);
+	return HRTIMER_NORESTART;
+}
+
+
+void neuronspi_uart_tx_proc(struct kthread_work *ws)
+{
+	struct neuronspi_port *n_port = to_neuronspi_port(ws, tx_work);
+	neuronspi_uart_handle_tx(n_port);
+}
+*/
+
+// Initialise the driver - called once on open
+s32 neuronspi_uart_startup(struct uart_port *port)
+{
+	struct neuronspi_port *n_port = to_neuronspi_port(port, port);
+
+    n_port->accept_rx = 0;
+	neuronspi_enable_uart_interrupt(n_port);
+	neuronspi_uart_power(port, 1);
+	// TODO: /* Reset FIFOs*/
+    unipi_uart_trace("ttyNS%d Startup\n", port->line);
+	return 0;
+}
+
+
+void neuronspi_uart_shutdown(struct uart_port *port)
+{
+    unipi_uart_trace("ttyNS%d Shutdown\n", port->line);
+    neuronspi_uart_power(port, 0);
+}
+
+
+void neuronspi_uart_remove(struct spi_device* spi)
+{
+    struct neuronspi_driver_data *n_spi = spi_get_drvdata(spi);
+    struct neuronspi_port *port; 
+	int i, uart_count;
+
+    uart_count = n_spi->uart_count;
+    n_spi->uart_count = 0;
+
+	for (i = 0; i < uart_count; i++) {
+        port = neuronspi_uart_data_global->p + i + n_spi->uart_pindex;
+        hrtimer_cancel(&port->tx_timer);
+		uart_remove_one_port(neuronspi_uart_driver_global, &port->port);
+        //kthread_flush_work(&(port->tx_work));
+
+		neuronspi_uart_power(&port->port, 0);
+        printk(KERN_INFO "UNIPIUART: Serial port ttyNS%d removed\n", i + n_spi->uart_pindex);
+	}
+}
+
+
+static const struct uart_ops neuronspi_uart_ops =
+{
+	.tx_empty			= neuronspi_uart_tx_empty,
+	.set_mctrl			= neuronspi_uart_set_mctrl,
+	.get_mctrl			= neuronspi_uart_get_mctrl,
+	.stop_tx			= neuronspi_uart_null_void,
+	.start_tx			= unipi_uart_start_tx,
+	.stop_rx			= neuronspi_uart_stop_rx,
+	.flush_buffer		= neuronspi_uart_flush_buffer,
+	.break_ctl			= neuronspi_uart_break_ctl,
+	.startup			= neuronspi_uart_startup,
+	.shutdown			= neuronspi_uart_shutdown,
+	.set_termios		= neuronspi_uart_set_termios,
+	.set_ldisc			= neuronspi_uart_set_ldisc,
+	.type				= neuronspi_uart_type,
+	.request_port		= neuronspi_uart_request_port,
+	.release_port		= neuronspi_uart_null_void,
+	.config_port		= neuronspi_uart_config_port,
+	.verify_port		= neuronspi_uart_verify_port,
+	.pm					= neuronspi_uart_pm,
+	.ioctl				= neuronspi_uart_ioctl,
+};
+
+
+int neuronspi_uart_probe(struct spi_device* spi, struct neuronspi_driver_data *n_spi)
+{
+    struct neuronspi_port* port;
+    int i, ret = 0;
+    
+    if (n_spi->uart_count_to_probe) {
+        n_spi->uart_pindex = neuronspi_uart_data_global->p_count;
+        for (i=0; i<n_spi->uart_count_to_probe; i++) {
+            // port is pointer to item ->p[x]
+            port = neuronspi_uart_data_global->p + neuronspi_uart_data_global->p_count;
+
+            port->port.dev	= &(spi->dev);
+            port->dev_index = n_spi->neuron_index;
+            port->dev_port  = i; 
+            port->n_spi     = n_spi; // shorthand to n_spi
+
+            port->port.line	= neuronspi_uart_data_global->p_count;
+            port->port.irq	= spi->irq;
+            port->port.type	= PORT_NEURONSPI;
+            port->port.fifosize	= NEURONSPI_FIFO_SIZE*8;
+            port->port.flags	= UPF_FIXED_TYPE | UPF_LOW_LATENCY;
+            port->port.iotype	= UPIO_PORT;
+            port->port.uartclk	= 9600;
+            port->port.rs485_config = neuronspi_uart_config_rs485;
+            port->port.ops	= &neuronspi_uart_ops;
+            spin_lock_init(&port->port.lock);
+
+            spin_lock_init(&port->rx_in_progress_lock);
+            port->rx_send_buf.second_message = port->rx_send_msg;
+            port->rx_recv_buf.second_message = port->rx_recv_msg;
+
+            spin_lock_init(&port->txop_lock);
+            port->tx_send_buf.second_message = port->tx_send_msg;
+            port->tx_recv_buf.second_message = port->tx_recv_msg;
+
+            port->tx_fifo_len = 0x7fff; //set it to big number; invoke reading current value from Neuron
+            if (n_spi && (n_spi->firmware_version >= 0x0519) ) {
+                port->tx_fifo_reg = port_to_uartregs(i,NEURONSPI_UART_FIFO_REGISTER);        // define modbus register
+            } else if (n_spi && n_spi->combination_id != 0xFF && n_spi->reg_map && n_spi->regstart_table->uart_queue_reg) {
+                port->tx_fifo_reg = n_spi->regstart_table->uart_queue_reg;      // define modbus register
+            }
+
+            hrtimer_init(&port->tx_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+            port->tx_timer.function = unipi_uart_timer_func;
+
+            //kthread_init_work(&(port->tx_work), neuronspi_uart_tx_proc);
+            kthread_init_work(&(port->flush_work), neuronspi_uart_flush_proc); // prepare work function for port flushing
+            uart_add_one_port(neuronspi_uart_driver_global, &port->port);
+            printk(KERN_INFO "UNIPIUART: Serial port ttyNS%d on UniPi Board nspi%d port:%d created\n", neuronspi_uart_data_global->p_count, port->dev_index, port->dev_port);
+            unipi_uart_trace("Probe cflag:%08x\n", neuronspi_spi_uart_get_cflag(spi, i));
+
+            n_spi->uart_count++;
+
+            if (neuronspi_uart_data_global->p_count < NEURONSPI_MAX_UART) {
+                neuronspi_uart_data_global->p_count++;
+            } else {
+                printk(KERN_INFO "UNIPIUART: PROBE maximum UART devices reached!\n");
+                ret = 1;
+                break;
+            }
+        }
+        n_spi->uart_count_to_probe = 0;
+    }
+    return ret;
+}
+
+int neuronspi_uart_probe_all(void)
+{
+	struct spi_device* spi;
+    struct neuronspi_driver_data* n_spi;// = spi_get_drvdata(dev);
+	int si, ret=0;
+    
+    for (si=0; si < NEURONSPI_MAX_DEVS; si++) {
+        spi = neuronspi_s_dev[si];
+        if (spi == NULL) {
+            continue;
+        }
+        n_spi = spi_get_drvdata(spi);
+        if (n_spi->uart_count_to_probe == 0) continue;
+        
+        if (neuronspi_uart_data_global->p == NULL) {
+            
+            neuronspi_uart_data_global->p = kzalloc(sizeof(struct neuronspi_port[NEURONSPI_MAX_UART]), GFP_ATOMIC);
+            unipi_uart_trace("Allocated port structure for %d ttyNS devices", NEURONSPI_MAX_UART);
+        }
+        
+        ret = neuronspi_uart_probe(spi, n_spi);
+        if (ret)  break; // max number of uarts reached
+	}
+	return ret;
+}
+
+
+int neuronspi_uart_driver_init(void)
+{
+    int ret;
+	if (neuronspi_uart_driver_global != NULL) {
+        return 0;
+    }
+    // Register UART if not registered
+	neuronspi_uart_driver_global = kzalloc(sizeof(struct uart_driver), GFP_ATOMIC);
+	neuronspi_uart_driver_global->owner		= THIS_MODULE;
+	neuronspi_uart_driver_global->dev_name	= "ttyNS";
+	neuronspi_uart_driver_global->driver_name = "ttyNS";
+	neuronspi_uart_driver_global->nr	= NEURONSPI_MAX_UART;
+	ret = uart_register_driver(neuronspi_uart_driver_global);
+	if (ret) {
+        printk(KERN_ERR "UNIPIUART: Failed to register the neuronspi uart driver, ERR:%d\n", ret);
+        kfree(neuronspi_uart_driver_global);
+        neuronspi_uart_driver_global = NULL;
+        return ret;
+	}
+	unipi_uart_trace("UART driver registered successfully!\n");
+	if (neuronspi_uart_data_global != NULL) {
+		printk(KERN_ERR "UNIPIUART: Uart data already allocated!\n");
+        return 0;
+	}
+	neuronspi_uart_data_global = kzalloc(sizeof(struct neuronspi_uart_data), GFP_ATOMIC);
+	unipi_uart_trace("UART driver data allocated successfully!\n");
+    return 0;
+}
+
+int neuronspi_uart_driver_exit(void)
+{
+    int i;
+	if (neuronspi_uart_driver_global) {
+        for (i = 0; i < NEURONSPI_MAX_DEVS; i++) {
+            if (neuronspi_s_dev[i] != NULL) {
+                neuronspi_uart_remove(neuronspi_s_dev[i]);
+            }
+        }
+		uart_unregister_driver(neuronspi_uart_driver_global);
+        if (neuronspi_uart_data_global->p) 
+            kfree(neuronspi_uart_data_global->p);
+		kfree(neuronspi_uart_driver_global);
+		kfree(neuronspi_uart_data_global);
+	}
+    return 0;
+}
diff --git a/drivers/unipi/unipi_uart.h b/drivers/unipi/unipi_uart.h
new file mode 100644
index 000000000000..14b3980605cd
--- /dev/null
+++ b/drivers/unipi/unipi_uart.h
@@ -0,0 +1,53 @@
+/*
+ * UniPi PLC device driver - Copyright (C) 2018 UniPi Technology
+ * Author: Tomas Knot <tomasknot@gmail.com>
+ *
+ *  Based on the SC16IS7xx driver by Jon Ringle <jringle@gridpoint.com>,
+ *  which was in turn based on max310x.c, by Alexander Shiyan <shc_work@mail.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef MODULES_NEURON_SPI_SRC_UNIPI_UART_H_
+#define MODULES_NEURON_SPI_SRC_UNIPI_UART_H_
+
+/************
+ * Includes *
+ ************/
+
+#include "unipi_common.h"
+#include "unipi_platform.h"
+
+/***************
+ * Definitions *
+ ***************/
+
+
+/*************************
+ * Function Declarations *
+ *************************/
+
+int neuronspi_rx_queue_add(struct neuronspi_port *port, u8 data);
+void neuronspi_rx_queue_swap(struct neuronspi_port *port);
+void neuronspi_uart_handle_rx(struct neuronspi_port *port, int rxlen, u8* pbuf);
+void unipi_uart_handle_tx(struct neuronspi_port *port, int calling);
+
+
+int neuronspi_uart_driver_init(void);
+int neuronspi_uart_driver_exit(void);
+int neuronspi_uart_probe(struct spi_device* spi, struct neuronspi_driver_data *n_spi);
+void neuronspi_uart_remove(struct spi_device* spi);
+int neuronspi_uart_probe_all(void);
+
+/*********************
+ * Data Declarations *
+ *********************/
+
+extern struct neuronspi_uart_data   *neuronspi_uart_data_global;
+extern struct uart_driver           *neuronspi_uart_driver_global;
+
+#endif /* MODULES_NEURON_SPI_SRC_UNIPI_UART_H_ */
